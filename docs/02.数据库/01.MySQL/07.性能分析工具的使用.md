---
title: 性能分析工具的使用
date: 2020-05-13 12:00:39
permalink: /pages/ce175c
article: false
---

## 性能分析工具的使用

在数据库调优中，我们的目标就是响应时间更快，吞吐量更大。利用宏观的监控工具和微观的日志分析可以帮我们快速找到调优的思路和方式。

### 1.数据库服务器的优化步骤

当我们遇到数据库调优问题的时候，该如何思考呢?这里把思考的流程整理成下面这张图。

整个流程划分成了观察〈Show status）和行动(Action）两个部分。字母S的部分代表观察（会使用相应的分析工具)，字母A代表的部分是行动（对应分析可以采取的行动)。

![数据库服务器优化步骤](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BC%98%E5%8C%96%E6%AD%A5%E9%AA%A4.png)

**小结：**

![image-20220301140426599](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BC%98%E5%8C%96%E6%AD%A5%E9%AA%A4%E5%B0%8F%E7%BB%93.png)

### 2.查看系统性能参数

在MySQL中，可以使用SHOW STATUS 语句查询一-些MySQL 数据库服务器的性能参数、执行 频率。
SHOW STATUS语句语法如下:

```mysql
SHOW [GLOBAL | SESBI0N] STATUS LIKE '参数';
```

一些常用的性能参数如下:

- Connections: 连接MySQL服务器的次数。
- Uptime: MySQL服务器的上线时间。
- Slow_ queries: 慢查询的次数。
- Innodb_ _rows_ read: Select查询返回的行数
- Innodb_ rows_ inserted: 执行INSERT操作插入的行数
- Innodb_ _rows_ _updated: 执行UPDATE操作更新的行数
- Innodb_ _rows_ deleted: 执行DELETE操作删除的行数
- Com_ select: 查询操作的次数。
- Com_ jinsert: 插入操作的次数。对于批量插入的INSERT操作，只累加一-次。
- Com_ update: 更新操作的次数。
- Com_ delete: 删除操作的次数。

若查询MySQL服务器的连接次数，则可以执行如下语句:

```mysql
SHOW STATUS LIKE 'Connections';
```


若查询服务器工作时间，则可以执行如下语句:

```mysql
SHOW STATUS LIKE 'Uptime';
```

若查询MySQL服务器的慢查询次数，则可以执行如下语句:

```mysql
SHOW STATUS LIKE 'Slow_queries';
```

慢查询次数参数可以结合慢查询日志找出慢查询语包，然后针对慢查询语句进行表结构优化或者查询语句优化。再比如，如下的指令可以查看相关的指令情况:

```mysql
SHOW STATUS LIKE 'Innodb_rows_%’;
```

### 3.统计SQL的查询成本:last_query_cost

一条SQL查询语句在执行前需要确定查询执行计划，如果存在多种执行计划的话，MysQL会计算每个执行计划所需要的成本，从中选择成本最小的一个作为最终执行的执行计划。

如果我们想要查看某条sQL语句的查询成本，可以在执行完这条SQL语句之后，通过查看当前会话中的last_query_cost变量值来得到当前查询的成本。它通常也是我们评价一个查询的执行效率的一个常用指标。这个查询成本对应的是 SQL语句所需要读取的页的数量。

我们依然使用第8章的student_info表为例:

```mysql
CREATE TABLE student_info(
	id INT(11)NOT NULL AUTO_INCREMENT,
	student_id INT NOT NULL ,
	name VARCHAR(20)DEFAULT NULL,
	course_id INT NOT NULL ,
	class_id INT(11)DEFAULT NULL,
	create_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
	PRIMARY KEY (id)
)ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 ;
```

如果我们想要查询id=900001的记录，然后看下查询成本，我们可以直接在聚簇索引上进行查找:

```mysql
SELECT student_id,class_id，NAME, create_time FROM student_info WHERE id = 900001;
```

运行结果（1条记录，运行时间为0.042s )

然后再看下查询优化器的成本，实际上我们只需要检索一个页即可:

![image-20220301145056507](https://gitee.com/kiteflyer/picture/raw/master/MySQL/last_query_cost%E4%B8%80%E6%9D%A1%E6%95%B0%E6%8D%AE.png)

如果我们想要查询id在900001到 9000100之间的学生记录呢?

```mysql
SELECT student_id,class_id，NAME,create_time FROM student_infoWHERE id BETWEEN 900881 AND 900100;
```

运行结果(100条记录，运行时间为0.046s ) :

然后再看下查询优化器的成本，这时我们大概需要进行20个页的查询。

![image-20220301145125730](https://gitee.com/kiteflyer/picture/raw/master/MySQL/last_query_cost100%E6%9D%A1.png)

你能看到页的数量是刚才的20倍，但是查询的效率并没有明显的变化，实际上这两个SQL查询的时间基本上一样，就是因为采用了顺序读取的方式将页面一次性加载到缓冲池中，然后再进行查找。虽然页数量(last_query_cost）增加了不少，但是通过缓冲池的机制。并没有增加多少查询时间。

**使用场景:**它对于比较开销是非常有用的，特别是我们有好几种查询方式可选的时候。

> SQL查询是一个动态的过程，从页加载的角度来看，我们可以得到以下两点结论:
>
> 1. 位置决定效率。如果页就在数据库缓冲池中儿那么效率是最高的，否则还需要从内存或者磁盘中进行读取，当然针对单个页的读取来说，如果页存在于内存中，会比在磁盘中读取效率高很多
> 2. 批量决定效率。如果我们从磁盘中对单一页进行随机读，那么效率是很低的(差不多10ms)，而采用顺序读取的方式，批量对页进行读取，平均一页的读取效率就会提升很多，甚至要快于单个页面在内存中的随机读取。
>
> 所以说，遇到I/O并不用担心，方法找对了，效率还是很高的。我们首先要考虑数据存放的位置，如果是经常使用的数据就要尽量放到缓冲池中，其次我们可以充分利用磁盘的吞吐能力，一次性批量读取数据，这样单个页的读取效率也就得到了提升。

### 4.定位执行慢的SQL:慢查询日志

MySQL的慢查询日志，用来记录在MysQL中响应时间超过阀值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是运行10秒以上(不含10秒)的语句，认为是超出了我们的最大忍耐时间值。

它的主要作用是，帮助我们发现那些执行时间特别长的SQL查询，并且有针对性地进行优化，从而提高系统的整体效率。当我们的数据库服务器发生阻塞、运行变慢的时候，检查一下慢查询日志，找到那些慢查询，对解决问题很有帮助。比如一条sql执行超过5秒钟，我们就算慢sQL，希望能收集超过5秒的sql，结合explain进行全面分析。

默认情况下，MySQL数据库没有开启慢查询日志，需要我们手动来设置这个参数。如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志记录写入文件。

#### 4.1开启慢查询日志参数

**1.开启slow_query_log**

在使用前，我们需要先看下慢查询是否已经开启，使用下面这条命令即可:

```mysql
mysql > show variables like '%slow_query_log';
```

![image-20220301150108003](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E6%9F%A5%E8%AF%A2%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E9%BB%98%E8%AE%A4%E7%8A%B6%E6%80%81.png)

我们能看到slow query_log=OFF，我们可以把慢查询日志打开，注意设置变量值的时候需要使用global，否则会报错:

```mysql
mysql > set global slow_query_log= 'ON';
```

然后我们再来查看下慢查询日志是否开启，以及慢查询日志文件的位置:

![image-20220301150220009](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E5%AD%98%E6%94%BE%E4%BD%8D%E7%BD%AE.png)

你能看到这时慢查询分析已经开启，同时文件保存在/var/lib/mysql/atguigue2-slow.log文件中。

**2.修改long_query_time阈值**

接下来我们来看下慢查询的时间阈值设置，使用如下命令:

```mysql
mysql > show variables like '%long_query_time%';
```

![image-20220301150424435](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%B6%E9%97%B4%E9%98%88%E5%80%BC.png)

这里如果我们想把时间缩短，比如设置为1秒，可以这样设置:

```mysql
#测试发现:设置global的方式对当前session的long_query_time失效。对新连接的客户端有效。所以可以一并执行下述语句
mysql>  set global long_query_time = 1;
mysql>  show global variables like '%long_query_time%’;
mysql>  set long_query_time=1 ;
mysql>  show variables like '%long_query_time%';
```

![image-20220301150711095](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E8%AE%BE%E7%BD%AE%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%B6%E9%97%B4%E9%98%88%E5%80%BC.png)

**补充:配置文件中一并设置参数**
如下的方式相较于前面的命令行方式，可以看作是永久设置的方式。

修改my.cnf文件，[mysqld]下增加或修改参数long_query_time、slow_query_log 和slow_query_log_file后，然后重启MySQL服务器。

```properties
[mysqld]
slow_query_log=ON #开启慢查询日志的开关
slow_query_log_file=/var/lib/mysql/atguigu_slow.log #慢查询日志的目录和文件名信息
long.uery_time=3 #设置慢查询的阈值为3秒，超出此设定值的SQL即被记录到慢查询日志
log_output=FILE
```

如果不指定存储路径，慢查询日志将默认存储到MySQL数据库的数据文件夹下。如果不指定文件名，默认文件名为hostname-slow.log。

#### 4.2查看慢查询数目

查询当前系统中有多少条慢查询记录

```mysql
SHOW GLOBAL STATUS LIKE '%Slow_queries%';
```

#### 4.3案列演示

**步骤1.建表**

```mysql
CREATE TABLE student (
	id INT ( 11 ) NOT NULL AUTO_INCREMENT,
	stuno INT NOT NULL,
	NAME VARCHAR ( 20 ) DEFAULT NULL,
	age INT ( 3 ) DEFAULT NULL,
	classId INT ( 11 ) DEFAULT NULL,
PRIMARY KEY ( id ) 
) ENGINE = INNODB AUTO_INCREMENT = 1 DEFAULT CHARSET = utf8;
```

**步骤2.设置参数log_bin_trust_function_creators**
创建函数，假如报错:

```mysql
This function has none of DETERMINISTIC. . . . . .
```

- 命令开启:允许创建函数设置:

  ```mysql
  set global log_bin_trust_function_creators=1; #不加global只是当前窗口有效。
  ```

**步骤3.创建函数**
随机产生字符串:(同上一章)

```mysql
DELIMITER //
CREATE FUNCTION rand_string ( n INT ) RETURNS VARCHAR ( 255 ) #该函数会返回一个字符串
BEGIN
	DECLARE
		chars_str VARCHAR ( 100 ) DEFAULT 'abcdefghijklmnopqrstuvwXyzABCDEFJHIJKLMNOPQRSTUVWXYZ';
	DECLARE
		return_str VARCHAR ( 255 ) DEFAULT '';
	DECLARE
		i INT DEFAULT 0;
	WHILE
			i < n DO
			SET return_str = CONCAT(
				return_str,
			SUBSTRING( chars_str, FLOOR( 1+RAND ()* 52 ), 1 ));
		SET i = i + 1;
	END WHILE;
	RETURN return_str;
END // 
DELIMITER;
#测试
SELECT rand_string ( 10 );
```

随机随机数值:(同上一章)

```mysql
DELIMITER //
CREATE FUNCTION rand_num ( from_num INT, to_num INT ) RETURNS INT ( 11 ) BEGIN
	DECLARE
		i INT DEFAULT 0;
	SET i = FLOOR(
		from_num + RAND()*(
			to_num - from_num + 1 
		));
	RETURN i;
END // 
DELIMITER;
#测试:
SELECT rand_num ( 10, 100 );
```

**步骤4.创建存储过程**

```mysql
DELIMITER //
CREATE PROCEDURE insert_stu1 ( START INT, max_num INT ) BEGIN
	DECLARE
		i INT DEFAULT 0;
	SET autocommit = 0;#设置手动提交事务
	REPEAT#循环
		SET i = i + 1;#赋值
		INSERT INTO student ( stuno, `name`, age, classId )
		VALUES
			( ( START + i ), rand_string ( 6 ), rand_num ( 10, 100 ), rand_num ( 10, 1000 ) );
		UNTIL i = max_num 
	END REPEAT;
	COMMIT;#提交事务
END // 
DELIMITER;
```

**步骤5:调用存储过程**

```mysql
#调用刚刚写好的函数，400000日条记录，从100001号开始
CALL insert_stu1 ( 100001, 4008000 );
```

#### 4.4测试及分析

**1.测试**

```mysql
SELECT * FROM student WHERE stuno = 3455655;
SELECT * FROM student WHERE `NAME` = 'oQmLUr';
```

从上面的结果可以看出来，查询学生编号为“3455655""的学生信息花费时间为1.426秒。查询学生姓名为“oQmLUr”的学生信息花费时间为1.547秒。已经达到了秒的数量级，说明目前查询效率是比较低的，下面的小节我们分析一下原因。

**2.分析**

```mysql
show status like 'slow_queries';
```

> **补充说明:**
>
> 除了上述变量，控制慢查询日志的还有一个系统变量: min_examined_row_limit。这个变量的意思是，查询扫描过的最少记录数。这个变量和查询执行时间，共同组成了判别一个查询是否是慢耸询的条件。刘如果时扫描过的记录数大于等于这个变量的值，并且查询执行时间超过long_query_time的值，那么，这个查询就被记录到慢查询日志中;反之，则不被记录到慢查询日志中。
>
> mysql> show status like 'slow_queries';
> +---------------+-------+
> | Variable_name | Value |
> +---------------+-------+
> | Slow_queries  | 0     |
> +---------------+-------+
> 1 row in set (0.00 sec)
>
> 这个值默认是0。与long_query_time=10合在一起，表示只要查询的执行时间超过10秒钟I哪怕一个记录也没有扫描过，都要被记录到慢查询日志中。你也可以根据需要，通过修改“my.ini"文件，来修改查询时长，或者通过SET指令，用SQL语句修改“min_examined_row_limit”的值。

#### 4.5慢查询日志分析工具: mysqldumpslow

在生产环境中，如果要手工分析日志，查找、分析sQL，显然是个体力活，MySQL提供了日志分析工具mysqldumpslow。
查看mysqldumpslow的帮助信息

```mysql
mysqldumpslow --help
```

![image-20220301155018014](https://gitee.com/kiteflyer/picture/raw/master/MySQL/mysqldumpslow%20help.png)

mysqldumpslow 命令的具体参数如下：

- -a: 不将数字抽象成N，字符串抽象成S
- **-s: 是表示按照何种方式排序：**
    - c: 访问次数
    - l: 锁定时间
    - r: 返回记录
    - **t:** **查询时间**
    - al:平均锁定时间
    - ar:平均返回记录数
    - at:平均查询时间 （默认方式）
    - ac:平均查询次数
- **-t: 即为返回前面多少条的数据；**
- **-g: 后边搭配一个正则匹配模式，大小写不敏感的；**

举例：我们想要按照查询时间排序，查看前五条 SQL 语句，这样写即可：

```mysql
mysqldumpslow -s t -t 5 /var/lib/mysql/atguigu01-slow.log
```

![image-20220301155214001](https://gitee.com/kiteflyer/picture/raw/master/MySQL/mysqldumpslow%E6%97%A5%E5%BF%97.png)

**工作常用参考：**

```mysql
#得到返回记录集最多的10个SQL 
mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log 
#得到访问次数最多的10个SQL 
mysqldumpslow -s c -t 10 /var/lib/mysql/atguigu-slow.log 
#得到按照时间排序的前10条里面含有左连接的查询语句 
mysqldumpslow -s t -t 10 -g "left join" /var/lib/mysql/atguigu-slow.log 
#另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况 
mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log | more
```

#### 4.6关闭慢查询日志

MySQL服务器停止慢查询日志功能有两种方法:

**方式1:永久性方式**
修改my.cnf或者my.ini文件，把[mysqld]组下的slow_query_log值设置为OFF，修改保存后，再重启MysQL服务，即可生效;

```properties
[ mysqld]
slow_query_log=OFF
```

或者，把slow_query_log一项注释掉或删除

```properties
[mysqld]
#slow_query_log =OFF
```

重启MySQL服务，执行如下语句查询慢日志功能。

```mysql
SHOW VARIABLES LIKE ‘%slow%' ;#查询慢查询日志所在目录
SHOW VARIABLES LIKE '%long_query_time%' ;#查询超时时长
```

可以看到，MySQL系统中的慢查询日志是关闭的。

**方式2:临时性方式**
使用SET语句来设置。
(1）停止MySQL慢查询日志功能，具体SQL语句如下。

```mysql
SET GLOBAL slow_query_log=off;
```

(2）重启MySQL服务，使用SHOW语句查询慢查询日志功能信息，具体SQL语句如下

```mysql
SHOw VARIABLES LIKE '%slow%';
#以及
SHOW VARIABLES LIKE '%long-query_time%';
```

#### 4.7删除慢查询日志

使用SHOW语句显示慢查询日志信息，具体sQL语句如下。

```mysql
SHOW VARIABLES LIKE 'slow_query_log%';
```

![image-20220301160849195](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95.png)
从执行结果可以看出，慢查询日志的目录默认为MySQL的数据目录，在该目录下手动删除慢查询日志文件即可。使用命令mysqladmin flush-logs 来重新生成查询日志文件，具体命令如下，执行完毕会在数据目录下重新生成慢查询日志文件。

```mysql
mysqladmin -uroot -p flush-logs slow
```

> 提示
> 慢查询日志都是使用mysqladmin flush-logs命令来删除重建的。使用时一定要注意，一旦执行了这个命令，慢查询日志都只存在新的日志文件中，如果需要旧的查询日志，就必须事先备份。

### 5.查看SQL执行成本:SHOW PROFLE

show profile在《逻辑架构》章节中讲过，这里作为复习。

Show Profile是MysQL提供的可以用来分析当前会话中sQL都做了什么、执行的资源消耗情况的工具，可用于sql调优的测量。默认情况下处于关闭状态，并保存最近15次的运行结果。

我们可以在会话级别开启这个功能

```mysql
mysql > show variables like 'profiling';
```

![image-20220301161416462](https://gitee.com/kiteflyer/picture/raw/master/MySQL/profile%E9%BB%98%E8%AE%A4%E7%8A%B6%E6%80%81.png)

通过设置profiling= 'ON’来开启show profile:

```mysql
mysql > set profiling = 'ON';
```

![image-20220301161547734](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E5%BC%80%E5%90%AFprofile.png)

然后执行相关的查询语句。接着看下当前会话都有哪些profiles，使用下面这条命令:

```mysql
mysql > show profiles;
```

![image-20220301161635335](https://gitee.com/kiteflyer/picture/raw/master/MySQL/profile%E6%9F%A5%E8%AF%A2%E5%9B%9E%E8%AF%9D.png)

你能看到当前会话一共有2个查询。如果我们想要查看最近一次查询的开销，可以使用:

```mysql
mysql > show profile ;
```

![image-20220301161726025](https://gitee.com/kiteflyer/picture/raw/master/MySQL/profile%E5%85%B7%E4%BD%93%E7%9A%84%E5%BC%80%E9%94%80.png)

我们也可以查看指定的Query ID的开销，比如 show profile for query 2查询结果是一样的。在SHOW PROFILE中我们可以查看不同部分的开销，比如cpu、block.io等:

```mysql
mysql> show profile cpu, block io for query 2;
```

![image-20220301162652289](https://gitee.com/kiteflyer/picture/raw/master/MySQL/profile%E9%83%A8%E5%88%86%E5%BC%80%E9%94%80.png)

通过上面的结果，我们可以弄清楚每一步骤的耗时，以及在不同部分，比如CPU、block.io 的执行时间，这样我们就可以判断出来sQL到底慢在哪里。

show profile的常用查询参数:

1. ALL:显示所有的开销信息。
2. BLOCK IO:显示块Io开销。
3. CONTEXT SWITCHES: 上下文切换开销。
4. CPU:显示CPU开销信息。
5. IPC:显示发送和接收开销信息。
6. MEMORY:显示内存开销信息。
7. PAGE FAULTS:显示页面错误开销信息。
8. SOURCE:显示和Source_function，Source_file，Source_line相关的开销信息。
9. SWAPS:显示交换次数开销信息。

日常开发需注意的结论:

1. converting HEAP to MyISAM:查询结果太大，内存不够，数据往磁盘上搬了。
2. Creating tmp table:创建临时表。先拷贝数据到临时表，用完后再删除临时表。
3. Copying to tmp table on disk:把内存中临时表复制到磁盘上，警惕!
4. locked 。

如果在show profile诊断结果中出现了以上4条结果中的任何一条，则sql语句需要优化。

> 注意:
>
> 不过 SHOW PROFILE命令将被弃用，我们可以从information_schema中的profiling数据表进行查看。

### 6.分析查询语句：EXPLAIN

#### 6.1概述

6.1概述
定位了查询慢的SQL之后，我们就可以使用EXPLAIN或 DESCRIBE工具做针对性的分析查询语句。DESCRIBE语句的使用方法与EXPLAIN语句是一样的，并且分析结果也是一样的。

MysQL中有专门负责优化SELECT语句的优化器模块，主要功能:通过计算分析系统中收集到的统计信息，为客户端请求的Query提供它认为最优的执行计划（他认为最优的数据检索方式，但不见得是DBA认为是最优的，这部分最耗费时间)。

这个执行计划展示了接下来具体执行查询的方式，比如多表连接的顺序是什么，对于每个表采用什么访问方法来具体执行查询等等。MySQL为我们提供了EXPLAIN语句来帮助我们查看某个查询语句的具体执行计划，大家看懂EXPLAIN语句的各个输出项，可以有针对性的提升我们查询语句的性能。

**1.能做什么?**

- 表的读取顺序
- 数据读取操作的操作类型。
- 哪些索引可以使用
- 哪些索引被实际使用。
- 表之间的引用
- 每张表有多少行被优化器查询

**2.官网介绍**

**https://dev.mysql.com/doc/refman/5.7/en/explain-output.html**

**https://dev.mysql.com/doc/refman/8.0/en/explain-output.html**

![image-20220301165612644](https://gitee.com/kiteflyer/picture/raw/master/MySQL/Mysql%E5%AE%98%E7%BD%91explain.png)

**3.版本情况**

- MySQL 5.6.3以前只能EXPLAIN SELECT;MYSQL 5.6.3以后就可以EXPLAIN SELECT，UPDATE DELETE
- 在5.7以前的版本中，想要显示partitions需要使用explain partitions 命令;想要显示filtered需要使用explain extended命令。在5.7版本后，默认explain直接显示partitions和filtered中的信息。

![image-20220301165828237](https://gitee.com/kiteflyer/picture/raw/master/MySQL/explain%E7%89%88%E6%9C%AC%E6%83%85%E5%86%B5.png)

#### 6.2基本语法

EXPLAIN或 DESCRIBE语句的语法形式如下:

```mysql
EXPLAIN SELECT select_options
或者
DESCRIBE SELECT select_options
```

如果我们想看看某个查询的执行计划的话，可以在具体的查询语句前边加一个EXPLAIN，就像这样:

```mysql
mysql> EXPLAIN SELECT 1;
```

![image-20220301170136285](https://gitee.com/kiteflyer/picture/raw/master/MySQL/EXPLAIN%20SELECT%201.png)

输出的上述信息就是所谓的执行计划。在这个执行计划的辅助下，我们需要知道应该怎样改进自己的查询语句以使查询执行起来更高效。其实除了以SELECT 开头的查询语句，其余的DELETE、INSERT、REPLACE以及UPDATE语句等都可以加上 EXPLAIN，用来查看这些语句的执行计划，只是平时我们对SELECT语句更感兴趣。

注意:执行EXPLAIN时并没有真正的执行该后面的语句，因此可以安全的查看执行计划。

EXPLAIN语句输出的各个列的作用如下:

| 列名          | 描述                                                   |
| ------------- | ------------------------------------------------------ |
| id            | 在一个大的查询语句中每个SELECT关键字都对应一个唯一的id |
| select_type   | SELECT关键字对应的那个查询的类型                       |
| table         | 表名                                                   |
| partitions    | 匹配的分区信息                                         |
| type          | 针对单表的访问方法                                     |
| possible_keys | 可能用到的索引                                         |
| key           | 实际上使用的索引                                       |
| key_len       | 实际使用到的索引长度                                   |
| ref           | 当使用索引列等值查询时，与索引列进行等值匹配的对象信息 |
| rows          | 预估的需要读取的记录条数                               |
| filtered      | 某个表经过搜索条件过滤后剩余记录条数的百分比           |
| Extra         | 一些额外的信息                                         |

在这里把它们都列出来只是为了描述一个轮廓，让大家有一个大致的印象。

#### 6.3数据准备

**1.建表**

```mysql
CREATE TABLE s1 (
	id INT AUTO_INCREMENT,
	key1 VARCHAR ( 100 ),
	key2 INT,
	key3 VARCHAR ( 100 ),
	key_part1 VARCHAR ( 100 ),
	key_part2 VARCHAR ( 100 ),
	key_part3 VARCHAR ( 100 ),
	common_field VARCHAR ( 100 ),
	PRIMARY KEY ( id ),
	INDEX idx_key1 ( key1 ),
	UNIQUE INDEX idx_key2 ( key2 ),
	INDEX idx_key3 ( key3 ),
INDEX idx_key_part ( key_part1, key_part2, key_part3 ) 
) ENGINE = INNODB CHARSET = utf8;
```

```mysql
CREATE TABLE s2 (
	id INT AUTO_INCREMENT,
	key1 VARCHAR ( 100 ),
	key2 INT,
	key3 VARCHAR ( 100 ),
	key_part1 VARCHAR ( 100 ),
	key_part2 VARCHAR ( 100 ),
	key_part3 VARCHAR ( 100 ),
	common_field VARCHAR ( 100 ),
	PRIMARY KEY ( id ),
	INDEX idx_key1 ( key1 ),
	UNIQUE INDEX idx_key2 ( key2 ),
	INDEX idx_key3 ( key3 ),
INDEX idx_key_part ( key_part1, key_part2, key_part3 ) 
) ENGINE = INNODB CHARSET = utf8;
```

**2.** **设置参数** **log_bin_trust_function_creators**

创建函数，假如报错，需开启如下命令：允许创建函数设置：

```mysql
set global log_bin_trust_function_creators=1; # 不加global只是当前窗口有效。
```

**3.** **创建函数**

```mysql
DELIMITER //
CREATE FUNCTION rand_string1 ( n INT ) RETURNS VARCHAR ( 255 ) #该函数会返回一个字符串
BEGIN
DECLARE chars_str VARCHAR ( 100 ) DEFAULT 'abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ';
DECLARE
	return_str VARCHAR ( 255 ) DEFAULT '';
DECLARE
	i INT DEFAULT 0;
WHILE
		i < n DO
		
		SET return_str = CONCAT(
			return_str,
		SUBSTRING( chars_str, FLOOR( 1+RAND ()* 52 ), 1 ));
	
	SET i = i + 1;
	
END WHILE;
RETURN return_str;

END // 
DELIMITER;
```

**4.** **创建存储过程**

创建往s1表中插入数据的存储过程：

```mysql
DELIMITER //
CREATE PROCEDURE insert_s1 (
	IN min_num INT ( 10 ),
	IN max_num INT ( 10 )) BEGIN
	DECLARE
		i INT DEFAULT 0;
	
	SET autocommit = 0;
	REPEAT
			
			SET i = i + 1;
		INSERT INTO s1
		VALUES
			(
				( min_num + i ),
				rand_string1 ( 6 ),
				( min_num + 30 * i + 5 ),
				rand_string1 ( 6 ),
				rand_string1 ( 10 ),
				rand_string1 ( 5 ),
				rand_string1 ( 10 ),
			rand_string1 ( 10 ));
		UNTIL i = max_num 
	END REPEAT;
	COMMIT;

END // 
DELIMITER;
```

创建往s2表中插入数据的存储过程：

```mysql
DELIMITER //
CREATE PROCEDURE insert_s2 (
	IN min_num INT ( 10 ),
	IN max_num INT ( 10 )) BEGIN
	DECLARE
		i INT DEFAULT 0;
	
	SET autocommit = 0;
	REPEAT
			
			SET i = i + 1;
		INSERT INTO s2
		VALUES
			(
				( min_num + i ),
				rand_string1 ( 6 ),
				( min_num + 30 * i + 5 ),
				rand_string1 ( 6 ),
				rand_string1 ( 10 ),
				rand_string1 ( 5 ),
				rand_string1 ( 10 ),
			rand_string1 ( 10 ));
		UNTIL i = max_num 
	END REPEAT;
	COMMIT;
	
END // 
DELIMITER;
```

**5.** **调用存储过程**

s1表数据的添加:加入1万条记录:

```mysql
CALL insert_s1 ( 10001 ,10000);
```

s2表数据的添加:加入1万条记录:

```mysql
CALL insert_s2 ( 10001 , 10000);
```

#### 6.4 EXPLAIN各列作用

为了让大家有比较好的体验，我们调整了下EXPLAIN输出列的顺序。

##### 1.table

不论我们的查询语句有多复杂，里边儿包含了多少个表，到最后也是需要对每个表进行单表访问的，所以MySQL规定EXPLAIN语句输出的每条记录都对应着某个单表的访问方法，该条记录的table列代表着该表的表名(有时不是真实的表名字，可能是简称)。

![image-20220301173416384](https://gitee.com/kiteflyer/picture/raw/master/MySQL/explain1.png)

这个查询语句只涉及对s1表的单表查询，所以EXPLAIN输出中只有一条记录，其中的table列的值是s1，表明这条记录是用来说明对s1表的单表访问方法的。
下边我们看一个连接查询的执行计划:

![image-20220301173640007](https://gitee.com/kiteflyer/picture/raw/master/MySQL/explain2.png)

可以看到这个连接查询的执行计划中有两条记录，这两条记录的table列分别是s1和s2，这两条记录用来分别说明对s1表和s2表的访问方法是什么。

##### 2.id

我们写的查询语句一般都以SELECT 关键字开头，比较简单的查询语句里只有一个SELECT关键字比如下边这个
查询语句:

```mysql
SELECT * FROM s1 WHERE key1 = 'a';
```

稍微复杂一点的连接查询中也只有一个SELECT 关键字，比如:

```mysql
SELECT * FROM s1 INNER JOIN s2
ON s1.key1 = s2.key1
WHERE s1.common_field = 'a ';
```

但是下边两种情况下在一条查询语句中会出现多个SELECT关键字:

查询中包含子查询的情况
比如下边这个查询语句中就包含2个SELECT 关键字:

```mysql
SELECT * FROM s1
WHERE key1 IN ( SELECT key3 FROM s2);
```

查询中包含UNION语句的情况
比如下边这个查询语句中也包含2个SELECT 关键字:

```mysql
SELECT * FROM s1 UNION SELECT * FROM s2 ;
```

查询语句中每出现一个SELECT关键字，MySQL就会为它分配一个唯一的id值。这个id值就是EXPLAIN语句的第一个列，比如下边这个查询中只有一个SELECT关键字，所以EXPLAIN的结果中也就只有一条id列为1的记录:

![image-20220301174530457](https://gitee.com/kiteflyer/picture/raw/master/MySQL/explain3.png)

对于连接查询来说，一个SELECT关键字后边的FROM子句中可以跟随多个表，所以在连接查询的执行计划中，每个表都会对应一条记录，但是这些记录的id值都是相同的，比如:

![image-20220301174659684](https://gitee.com/kiteflyer/picture/raw/master/MySQL/explain4.png)

**小结:**

1. **id如果相同，可以认为是一组，从上往下顺序执行。**
2. **在所有组中，id值越大，优先级越高，越先执行**
3. **关注点:id号每个号码，表示一趟独立的查询,一个sql的查询趟数越少越好**

##### 3.select_type

一条大的查询语句里边可以包含若干个SELECT关键字，每个SELECT关键字代表着一个小的查询语句，而每个SELECT关键字的FROM子句中都可以包含若干张表(这些表用来做连接查询)，每一张表都对应着执行计划输出中的一条记录，对于在同一个SELECT关键字中的表来说，它们的id值是相同的。

MySQL为每一个SELECT关键字代表的小查询都定义了一个称之为select_type的属性，意思是我们只要知道了某个小查询的select_type属性，就知道了这个小查询在整个大查询中扮演了一个什么角色。我们看一下select_type都能取哪些值，请看官方文档:

| 名称                 | 描述                                                         |
| -------------------- | ------------------------------------------------------------ |
| SIMPLE               | Simple SELECT (not using UNION or subqueries)                |
| PRIMARY              | Outermost SELECT                                             |
| UNION                | Second or later SELECT statement in a UNION                  |
| UNION RESULT         | Result of a UNION                                            |
| SUBQUERY             | First SELECT in subquery                                     |
| DEPENDENT SUBQUERY   | First SELECT in subquery, dependent on outer query           |
| DEPENDENT UNION      | Second or later SELECT statement in a UNION, dependent on outer query |
| MATERIALIZED         | Derived table                                                |
| Materialized         | Materialized subquery                                        |
| UNCACHEABLE SUBQUERY | A subquery for which the result cannot be cached and must be re-evaluated for each row of the outer query |
| UNCACHEABLE UNION    | The second or later select in a UNION that belongs to an uncacheable subquery (see UNCACHEABLE SUBQUERY) |

具体分析如下:

- SIMPLE

  查询语句中不包含UNION或者子查询的查询都算作是SIMPLE类型，比方说下边这个单表查询的select_type的值就是 SIMPLE:

  ```mysql
  mysql> EXPLAIN SELECT * FROM s1 ;
  ```

  ![image-20220302101610620](https://gitee.com/kiteflyer/picture/raw/master/MySQL/explain5.png)

当然，连接查询也算是SIMPLE 类型，比如:

```mysql
mysql> EXPLAIN SELECT * FROM s1 INNER JOIN S2;
```

![image-20220302101920522](https://gitee.com/kiteflyer/picture/raw/master/MySQL/explain6.png)

- PRIMARY
  对于包含UNION、UNION ALL或者子查询的大查询来说，它是由几个小查询组成的，其中最左边的那个查询的select_type值就是PRIMARY，比方说:\

  ```mysql
  mysql> EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2;
  ```

  ![image-20220302102247489](https://gitee.com/kiteflyer/picture/raw/master/MySQL/explian7.png)

  从结果中可以看到，最左边的小查询SELECT * FROM s1对应的是执行计划中的第一条记录，它的select_type值就是 PRIMARY。

- UNION
  对于包含UNION或者UNION ALL的大查询来说，它是由几个小查询组成的，其中除了最左边的那个小查询以外，其余的小查询的select_type值就是UNION，可以对比上一个例子的效果。

- UNION RESULT
  MySQL选择使用临时表来完成UNION查询的去重工作，针对该临时表的查询的select_type就是UNIONRESULT，例子上边有。

- SUBQUERY
  如果包含子查询的查询语句不能够转为对应的semi-join的形式，并且该子查询是不相关子查询，并且查询优化器决定采用将该子查询物化的方案来执行该子查询时，该子查询的第一个SELECT关键字代表的那个查询的select_type就是 SUBQUERY，比如下边这个查询:

  ```mysql
  mysq1> EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = 'a';
  ```

  ![image-20220302102515114](https://gitee.com/kiteflyer/picture/raw/master/MySQL/explian8.png)

可以看到，外层查询的select_type 就是PRIMARY，子查询的selecttype就是 SUBQUERY。需要大家注意的是，由于select_type为SUBQUERY的子查询会被物化，所以只需要执行一遍。

- DEPENDENT SUBQUERY

如果包含子查询的查询语句不能够转为对应的semi-join的形式，并且该子查询是相关子查询，则该子查询的第一个SELECT关键字代表的那个查询的select_type就是DEPENDENT SUBQUERY，比如下边这个查询:

```mysql
mysql> EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2 WHERE s1.key2 = s2.key2) OR key3 = 'a';
```

![image-20220302102930813](https://gitee.com/kiteflyer/picture/raw/master/MySQL/explain9.png)

需要大家注意的是，select_type为 DEPENDENT SUBQUERY的查询可能会被执行多次。

- DEPENDENT UNIDN

在包含UNION或者UNION ALL的大查询中，如果各个小查询都依赖于外层查询的话，那除了最左边的那个小查询之外，其余的小查询的select_type的值就是DEPENDENT UNION。比方说下边这个查询

```mysql
mysql> EXPLAIN SELECT * FROM s1 WHERE key1 IN(SELECT key1 FROM s2 WHERE key1 = 'a' UNION SELECT key1 FROM S1 WHERE key1 = 'b');
```

![image-20220302104055890](https://gitee.com/kiteflyer/picture/raw/master/MySQL/explain10.png)

这个查询比较复杂，大查询里包含了一个子查询，子查询里又是由UNION连起来的两个小查询。从执行计划中可以看出来,SELECT key1 FROM s2 WHERE key1 = 'a'这个小查询由于是子查询中第一个查询，所以它的select_type是DEPENDENT SUBQUERY，而SELEcT key1 FROM s1 WHERE key1 = 'b'这个查询的select_type就是 DEPENDENT UNION。

- DERIVED
  对于采用物化的方式执行的包含派生表的查询，该派生表对应的子查询的select_type就是 DERIVED，比方说下边这个查询:

  ```mysql
  mysql> EXPLAIN SELECT * FROM (SELECT key1,count(*) as c FROM s1 GROUP BY key1) AS derived_s1 where c >1;
  ```

  ![image-20220302104508247](https://gitee.com/kiteflyer/picture/raw/master/MySQL/explain11.png)

  从执行计划中可以看出， id为2的记录就代表子查询的执行方式，它的select_type是 DERIVED，说明该子查询是以物化的方式执行的。id为1的记录代表外层查询，大家注意看它的table列显示的是derived2，表示该查询是针对将派生表物化之后的表进行查询的。

  > 小贴士:如果派生表可以通过和外层查询合并的方式执行的话，执行计划又是另一番景象，大家可以试试

- MATERIALIZED
  当查询优化器在执行包含子查询的语句时，选择将子查询物化之后与外层查询进行连接查询时，该子查询对应的select_type属性就是MATERIALIZED，比如下边这个查询:

  ```mysql
  mysql> EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2);
  ```

  ![image-20220302104802298](https://gitee.com/kiteflyer/picture/raw/master/MySQL/explain12.png)

执行计划的第三条记录的id值为2，说明该条记录对应的是一个单表查询，从它的select_type值为MATERIALIZED可以看出，查询优化器是要把子查询先转换成物化表。然后看执行计划的前两条记录的id值都为1，说明这两条记录对应的表进行连接查询，需要注意的是第二条记录的table列的值是subquery2，说明该表其实就是1d为2对应的子查询执行之后产生的物化表，然后将s1和该物化表进行连接查询。

- UNCACHEABLE SUBQUERY

  不常用，就不多说了。

- UNCACHEABLE UNION

  不常用，就不多说了。

##### 4.partitions (可略)

- 代表分区表中的命中情况，非分区表，该项为NULL。一般情况下我们的查询语句的执行计划的partitions列的值都是NULL。

- https://dev.mysql.com/doc/refman/5.7/en/alter-table-partition-operations.html

- 如果想详细了解，可以如下方式测试。创建分区表:

  ```mysql
  -- 创建分区表，
  -- 按照id分区，id<100 p0分区，其他p1分区
  CREATE TABLE user_partitions (
  	id INT auto_increment,
  	NAME VARCHAR ( 12 ),
  	PRIMARY KEY ( id )) PARTITION BY RANGE ( id )(
  	PARTITION p0
  	VALUES
  		less than ( 100 ),
  	PARTITION p1
  	VALUES
  	less than MAXVALUE 
  	);
  ```

  ![image-20220302105754192](https://gitee.com/kiteflyer/picture/raw/master/MySQL/explain13.png)

  查询id大于200 (200>100，p1分区）的记录，查看执行计划，partitions是p1，符合我们的分区规则

##### ==5.type==

执行计划的一条记录就代表着MysQL对某个表的执行查询时的访问方法，又称"访问类型”，其中的type列就表明了这个访问方法是啥，是较为重要的一个指标。比如，看到type列的值是ref，表明MySQL即将使用ref访问方法来执行对s1表的查询。

完整的访问方法如下: system const eq_ref ref fulltext ref_or_null index_merge unique_subquery index_subquery range index ALL。

我们详细解释一下:

- system

  当表中只有一条记录并且该表使用的存储引擎的统计数据是精确的，比如MyISAM、Memory那么对该表的访问方法就是system。比方说我们新建一个MyISAM表，并为其插入一条记录:
  ![image-20220302112154157](https://gitee.com/kiteflyer/picture/raw/master/MySQL/explaintype.png)

然后我们看一下查询这个表的执行计划:

```mysql
mysql> EXPLAIN SELECT FROM t;
```

![image-20220302113053272](https://gitee.com/kiteflyer/picture/raw/master/MySQL/explain14.png)

可以看到type列的值就是system了。

> 测试:可以把表改成使用InnoDB存储引擎，试试看执行计划的type列是什么。ALL

- const
  当我们根据主键或者唯一二级索引列与常数进行等值匹配时，对单表的访问方法就是const比如:

  ```mysql
  mysql>EXPLAIN SELECT * FROM s1 WHERE id = 18005;
  ```

  ![image-20220302113638279](https://gitee.com/kiteflyer/picture/raw/master/MySQL/explain15.png)

- eq_ref
  在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的(如果该主键或者唯一二级索引是联合索引的话，所有的索引列都必须进行等值比较)，则对该被驱动表的访问方法就是eq_ref，比方说:

  ```mysql
  mysql> EXPLAIN SELECT * FROM s1 INNER JOIN S2 ON s1.id = s2.id;
  ```

  ![image-20220302113756688](https://gitee.com/kiteflyer/picture/raw/master/MySQL/explain16.png)

从执行计划的结果中可以看出，MySQL打算将s2作为驱动表，s1作为被驱动表，重点关注s1的访问方法是eq_ref，表明在访问s1表的时候可以通过主键的等值匹配来进行访问。

- ref
  当通过普通的二级索引列与常量进行等值匹配时来查询某个表，那么对该表的访问方法就可能是ref，比方说下边这个查询:

  ```mysql
  my sql> EXPLAIN SELECT * FROM s1 WHERE key1 = 'a' ;
  ```

  ![image-20220302114322660](https://gitee.com/kiteflyer/picture/raw/master/MySQL/explain17.png)

- fulltext

  全文索引

- ref_or _null
  当对普通二级索引进行等值匹配查询，该索引列的值也可以是NLLL值时，那么对该表的访问方法就可能是re f_or_null，比如说:

  ```mysql
  mysql> EXPLAIN SELECT * FROM s1 WHERE key1 = 'a' OR key1 IS NULL;
  ```

  ![image-20220302114516019](https://gitee.com/kiteflyer/picture/raw/master/MySQL/explain18.png)

- index_Imerge

  一般情况下对于某个表的查询只能使用到一个索引，但单表访问方法时在某些场景下可以使用Intersection、Unitn、Sort-Union这三种索引合并的方式来执行查询。我们看一下执行计划中是怎么体现MySQL使用索引合并的方式来对某个表执行查询的:

  ```mysql
  mysql> EXPLAIN SELECT * FROM s1 WHERE key1 = 'a' OR key3 = 'a';
  ```

  ![image-20220302130443567](https://gitee.com/kiteflyer/picture/raw/master/MySQL/explain19.png)

从执行计划的type列的值是index_menge就可以看出，MySQL打算使用索引合并的方式来执行对s1表的查询。

- unique_eubquery
  类似于两表连接中被驱动表的eq_ref访问方法, unique _ sauquery·是针对在一些包含IN子查询的查询语句中，如果查询优化器决定将IN子查询转换为EISTS子查询，而且子查询可以使用到主键进行等值匹配的话，那么该子查询执行计划的rype列的值就是un1que_subquery,比如下边的这个查询语句:

  ```mysql
  mysq1> EXPLAIN SELECT * FROM s1 WHERE key2 IN (SELECT id FROM s2 where s1.key1 = s2.key1) OR key3 = 'a';
  ```

  ![image-20220302130643057](https://gitee.com/kiteflyer/picture/raw/master/MySQL/explain20.png)

可以看到执行计划的第二条记录的type值就是unique_subquery，说明在执行子查询时会使用到id列的索引。

- index_subquery

  index_subquery与unique_subquery类似，只不过访问子查询中的表时使用的是普通的索引，比如这样:

  ```mysql
  mysql> EXPLAIN SELECT * FROM s1 WHERE common_field IN (SELECT key3 FROM s2 where s1.key1 =s2.key1) OR key3 = 'a' ;
  ```

  ![image-20220302131108860](https://gitee.com/kiteflyer/picture/raw/master/MySQL/explain21.png)

- range
  如果使用索引获取某些范围区间的记录，那么就可能使用到r ange访问方法，比如下边的这个查询:

  ```mysql
  mysq1> EXPLAIN SELECT * FROM s1 WHERE key1 IN ( 'a', 'b' , 'c ');
  ```

  ![image-20220302131225574](https://gitee.com/kiteflyer/picture/raw/master/MySQL/explain22.png)

或者:

```mysql
mysqls EXPLAIN SELECT * FROM s1 WHERE key1 > 'a' AND key1 < 'b ';
```

![image-20220302131400379](https://gitee.com/kiteflyer/picture/raw/master/MySQL/explain23.png)

- index
  当我们可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是index，比如这样:

  ```mysql
  mysql> EXPLAIN SELECT key_part2 FROM s1 WHERE key_part3 = 'a';
  ```

  ![image-20220302131515304](https://gitee.com/kiteflyer/picture/raw/master/MySQL/explian24.png)

上述查询中的搜索列表中只有key_part2一个列，而且搜索条件中也只有key_part3一个列，这两个列又恰好包含在idx_key_part这个索引中，可是搜索条件key_part3不能直接使用该索引进行ref或者range方式的访问，只能扫描整个idx_key_part索引的记录，所以查询计划的type列的值就是index 。

> 再一次强调，对于使用InnoDB存储引擎的表来说，二级索引的记录只包含索引列和主键列的值，而聚簇索引中包含用户定义的全部列以及一些隐臧列．所以扫描二级索引的代价比直接全表扫描，也就是扫描聚簇索引的代价更低一些。

- ALL
  最熟悉的全表扫描，就不多说了，直接看例子:

```mysql
mysql> EXPLAIN SELECT * FROM s1;
```

![image-20220302131726318](https://gitee.com/kiteflyer/picture/raw/master/MySQL/explain25.png)

一般来说，这些访问方法中除了All这个访问方法外，其余的访问方法都能用到索引，除了index_merge访问方法外，其余的访问方法都最多只能用到一个索引。

**小结：**

**结果值从最好到最坏依次是:**

<span style="color:blue">system > const > eq_ref > ref </span>> fulltext > ref_or_null >index_merge > unique_subquery > index_subquery ><span style="color:blue" range>index > ALL</span>>
**其中比较重要的几个提取出来(见上图中的蓝色)。SQL性能优化的目标:至少要达到range级别，要求是ref级别，最好是consts级别。(阿里巴巴开发手册要求)**

##### 6.possible_keys和key

在EXPLAIN语句输出的执行计划中，possible_keys列表示在某个查询语句中，对某个表执行单表查询时可能用到的索引有哪些。一般查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用。key列表示实际用到的索引有哪些，如果为NULL，则没有使用索引。比方说下边这个查询:

```mysql
mysql> EXPLAIN SELECT * FROM s1 WHERE key1 > 'Z' AND key3 = 'a';
```

![image-20220302132755584](https://gitee.com/kiteflyer/picture/raw/master/MySQL/explain26.png)

上述执行计划的possible_keys列的值是idx_key1,idx_key3，表示该查询可能使用到idx_key1, idx_key3两个索引，然后key列的值是idx_key3，表示经过查询优化器计算使用不同索引的成本后，最后决定使用idx_key3来执行查询比较划算。

##### ==7.key_len(`待补充`)==

**练习：**

**key_len的长度计算公式：**

```mysql
varchar(10)变长字段且允许NULL = 10 * ( character set： 
	utf8=3,gbk=2,latin1=1)+1(NULL)+2(变长字段) 
varchar(10)变长字段且不允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)+2(变长字段) 
char(10)固定字段且允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)+1(NULL) 
char(10)固定字段且不允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)
```

##### 8.ref(`待补充`)

显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值

当使用索引列等值匹配的条件去执行查询时，也就是在访问方法是const、eq_ref、 ref、ref_or_null、unique_subquery、index_subquery其中之一时,ref列展示的就是与索引列作等值匹配的结构是什么，比如只是一个常数或者是某个列。大家看下边这个查询:

```mysql
mysql> EXPLAIN SELECT * FROM s1 WHERE key1 = 'a';
```

![image-20220302134641684](https://gitee.com/kiteflyer/picture/raw/master/MySQL/explain27.png)

可以看到ref列的值是const，表明在使用idx_key1索引执行查询时，与key1列作等值匹配的对象是一个常数，当然有时候更复杂一点:

```mysql
EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.id = s2.id ;
```

![image-20220302134735045](https://gitee.com/kiteflyer/picture/raw/master/MySQL/explain28.png)

##### ==9.rows(`待补充`)==

##### 10.filtered(`待补充`)

##### ==11.Extra(`待补充`)==

##### 12.小结

- EXPLAIN不考虑各种cache
- EXPLAIN不能显示MySQL在执行查询时所作的优化工作
- EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况。
- 部分统计信息是估算的，并非精确值

### 7.EXPLAIN的进一步使用

#### 7.1EXPLAIN 可以输出四种格式

这里谈谈EXPLAIN的输出格式。EXPLAIN可以输出四种格式:传统格式，JSON格式，TREE格式以及可视化输出。用户可以根据需要选择适用于自己的格式。

##### 1.传统格式

传统格式简单明了，输出是一个表格形式，概要说明查询计划。

```mysql
mysq1> EXPLAIN SELECT s1.key1,s2.key1 FROM s1 LEFT JOIN s2 ON s1.key1 = s2.key1 WHERE s2.common_field IS NOT NULL;
```

![image-20220302135949179](https://gitee.com/kiteflyer/picture/raw/master/MySQL/EXPLAIN%E4%BC%A0%E7%BB%9F%E6%A0%BC%E5%BC%8F.png)

##### 2.JSON格式

第1种格式中介绍的EXPLAIN语句输出中缺少了一个衡量执行计划好坏的重要属性―-成本。而JSON格式是四种格式里面输出信息最详尽的格式，里面包含了执行的成本信息。

- JSON格式:在EXPLAIN单词和真正的查询语句中间加上FORMAT=JSON。

```mysql
EXPLAIN FORMAT=JSGN SELECT ....
```

- EXPLAIN 的column与JSON的对应关系:(来源于MySQL 5.7文档)
  ![image-20220302140039833](https://gitee.com/kiteflyer/picture/raw/master/MySQL/EXPLAINcolumn-json%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB.png)

这样我们就可以得到一个json格式的执行计划，里面包含该计划花费的成本，比如这样:

```mysql
mysql> EXPLAIN FORMAT=JSON SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key2 WHERE s1.common_field = 'a' \G
```

```json
mysql> EXPLAIN FORMAT=JSON SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key2 WHERE s1.common_field = 'a' \G
*************************** 1. row ***************************
EXPLAIN: {
  "query_block": {
    "select_id": 1,      #整个查询语句只有1个SELECT关键字，该关键字对应的id号为1
    "cost_info": {
      "query_cost": "1261.66"      #整个查询的执行成本预计为1261.66
    },
    "nested_loop": [      # 几个表之间采用嵌套循环连接算法执行
      # 以下是参与嵌套循环连接算法的各个表的信息
      {
        "table": {
          "table_name": "s1",        #s1表是驱动表
          "access_type": "ALL",      #访问方法为ALL，意味着使用全表扫描访问
          "possible_keys": [         #可能使用的索引
            "idx_key1"
          ],
          "rows_examined_per_scan": 9166,  # 查询一次s1表大致需要扫描9166条记录
          "rows_produced_per_join": 916,   # 驱动丧s1的扇出是916
          "filtered": "10.00",             # condition filtering代表的百分比
          "cost_info": {
            "read_cost": "849.19",         # 稍后解释
            "eval_cost": "91.66",          # 稍后解释
            "prefix_cost": "940.85",       # 单次查询s1表总共的成本
            "data_read_per_join": "1M"     # 读取的数据量
          },
          "used_columns": [      # 执行查询中涉及到的列
            "id",
            "key1",
            "key2",
            "key3",
            "key_part1",
            "key_part2",
            "key_part3",
            "common_field"
          ],
		  #对s1表访问时针对单表查询的条件
          "attached_condition": "((`baimi_simple`.`s1`.`common_field` = 'a') and (`baimi_simple`.`s1`.`key1` is not null))"
        }
      },
      {
        "table": {
          "table_name": "s2",           # s2表是被驱动表
          "access_type": "eq_ref",      # 访问方法为ref，意味着使用索引等值匹配的方式访问
          "possible_keys": [            # 可能使用的索引
            "idx_key2"
          ],
          "key": "idx_key2",  # 实际使用的索引
          "used_key_parts": [ # 使用到的索引列
            "key2"
          ],
          "key_length": "5", # ken_len
          "ref": [
            "baimi_simple.s1.key1" #与key2列进行等值匹配的对象
          ],
          "rows_examined_per_scan": 1,   # 查询一次s2表大致需要扫描1条记录
          "rows_produced_per_join": 916, # 被驱动表s2的扇出是916(由于后边没有多余的表进行连接，所以这个值也没有什么用)
          "filtered": "100.00",          # condition filtering代表的百分比
		  # s2表使用索引进行查询的搜索条件
          "index_condition": "(cast(`baimi_simple`.`s1`.`key1` as double) = cast(`baimi_simple`.`s2`.`key2` as double))",
          "cost_info": {
            "read_cost": "229.15",      # 稍后解释
            "eval_cost": "91.66",       # 稍后解释
            "prefix_cost": "1261.66",   # 单次查询s1、多次查询s2表总共的成本
            "data_read_per_join": "1M"  # 读取的数据量
          },
          "used_columns": [  # 执行查询中涉及到的列
            "id",
            "key1",
            "key2",
            "key3",
            "key_part1",
            "key_part2",
            "key_part3",
            "common_field"
          ]
        }
      }
    ]
  }
}
1 row in set, 2 warnings (0.00 sec)
```

我们使用#后边跟随注释的形式为大家解释了EXPLAIN FORMAT=JSON语句的输出内容，但是大家可能有疑问"cost_info"里边的成本看着怪怪的，它们是怎么计算出来的?先看s1表的" cost_info "部分:

```json
"cost_info": { 
    "read_cost": "1840.84", 
    "eval_cost": "193.76", 
    "prefix_cost": "2034.60", 
    "data_read_per_join": "1M" 
}
```

- read_cost是由下边这两部分组成的:

    - I0成本

    - 检测 rows x (1 - filter) 条记录的CPU成本

      > 小贴士: rows和filter都是我们前边介绍执行计划的输出列，在JSON格式的执行计划中，rows相当于rows_examined_per_scan,filtered名称不变。

- eval_cost是这样计算的:

  检测rows x filter 条记录的成本。

- prefix_cost就是单独查询s1表的成本，也就是:

  read_cost + eval_cost

- data_read_per-join表示在此次查询中需要读取的数据量。

  对于s2表的"cost_info”部分是这样的:

  ```json
  "cost_info": { 
      "read_cost": "968.80", 
      "eval_cost": "193.76", 
      "prefix_cost": "3197.16", 
      "data_read_per_join": "1M" 
  }
  ```

  由于s2表是被驱动表，所以可能被读取多次，这里的read_cost和eval_cost是访问多次s2表后累加起来的值，大家主要关注里边儿的prefix_cost的值代表的是整个连接查询预计的成本，也就是单次查询s1表和多次查询s2表后的成本的和，也就是:
  968.80 + 193.76 + 2034.60 = 3197.16

##### 3.Tree格式

TREE格式是8.0.16版本之后引入的新格式，主要根据查询的各个部勤之间的关系和各部分的执行顺序来描述如何查询。

```mysql
mysq1> EXPLAIN FORMAT=tree SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key2 WHERE s1.common_field = 'a' \G
*************************** 1. row ***************************
EXPLAIN: -> Nested loop inner join  (cost=1261.66 rows=917)
    -> Filter: ((s1.common_field = 'a') and (s1.key1 is not null))  (cost=940.85 rows=917)
        -> Table scan on s1  (cost=940.85 rows=9166)
    -> Single-row index lookup on s2 using idx_key2 (key2=s1.key1), with index condition: (cast(s1.key1 as double) = cast(s2.key2 as double))  (cost=0.25 rows=1)

1 row in set, 1 warning (0.00 sec)
```

##### 4.可视化输出

可视化输出，可以通过MysQL Workbench可视化查看MySQL的执行计划。通过点击Workbench的放大镜图标，即可生成可视化的查询计划。

![image-20220302154154512](https://gitee.com/kiteflyer/picture/raw/master/MySQL/explain%E5%8F%AF%E8%A7%86%E5%8C%96%E8%BE%93%E5%87%BA.png)

上图按从左到右的连接顺序显示表。红色框表示全表扫描，而绿色框表示使用索引查找。对于每个表，显示使用的索引。还要注意的是，每个表格的框上方是每个表访问所发现的行数的估计值以及访问该表的成本。

#### 7.2 SHOW WARNINGS的使用

在我们使用EXPLAIN语句查看了某个查询的执行计划后，紧接着还可以使用SHOW WARNINGS语句查看与这个查询的执行计划有关的一些扩展信息，比如这样:

```mysql
mysql> EXPLAIN SELECT s1.key1, s2.key1 FROM s1 LEFT JOIN s2 ON s1.key1 = s2.key1 WHERE s2.common_field IS NOT NULL;
```

![image-20220302150954164](https://gitee.com/kiteflyer/picture/raw/master/MySQL/explain29.png)

```mysql
mysql> SHOW WARNINGS \G
*************************** 1. row ***************************
  Level: Note
   Code: 1003
Message: /* select#1 */ select `baimi_simple`.`s1`.`key1` AS `key1`,`baimi_simple`.`s2`.`key1` AS `key1` from `baimi_simple`.`s1` join `baimi_simple`.`s2` where ((`baimi_simple`.`s1`.`key1` = `baimi_simple`.`s2`.`key1`) and (`baimi_simple`.`s2`.`common_field` is not null))
1 row in set (0.00 sec)
```

大家可以看到SHOW WARNINGS展示出来的信息有三个字段，分别是Level、Code、Messaye。我们最常见的就是Code为1003的信息，当Code值为1003时，Message字段展示的信息类似于查询优化器将我们的查询语句重写后的语句。比如我们上边的查询本来是一个左(外）连接查询，但是有一个s2.common_field IS NOT NULL的条件，这就会导致查询优化器把左(外)连接查询优化为内连接查询，从SHOW WARNINGS的Message字段也可以看出来，原本的LEFT JOIN已经变成了JOIN。

但是大家一定要注意，我们说Message字段展示的信息类似于查询优化器将我们的查询语句重写后的语句，并不是等价于，也就是说Message字段展示的信息并不是标准的查询语句，在很多情况下并不能直接拿到黑框框中运行，它只能作为帮助我们理解MySQL将如何执行查询语句的一个参考依据而已。

### 8.分析优化器执行计划：trace

OPTIMIZER_TRACE 是MySQL 5.6引入的一项跟踪功能，它可以跟踪优化器做出的各种决策（比如访问表的方法、各种开销计算、各种转换等），并将跟踪结果记录到 INFORMATION_SCHEMA.OPTIMIZER_TRACE 表中。

此功能默认关闭。开启trace，并设置格式为JSON，同时设置trace最大能够使用的内存大小，避免解析过程中因为默认内存过小而不能够完整展示。

```mysql
SET optimizer_trace="enabled=on",end_markers_in_json=on ;
set optimizer_trace_max_mem_size=1000000;
```

开启后，可分析如下语句:

- SELECT
- INSERT
- REPLACE
- UPDATE
- DELETE
- EXPLAIN
- SET

测试:执行如下SQL语句

```mysql
select * from student where id < 10;
```


最后，查询information_schema.optimizer_trace就可以知道MySQL是如何执行SQL的:

```mysql
select * from information_schema.optimizer_trace \G
```

![image-20220302154942399](https://gitee.com/kiteflyer/picture/raw/master/MySQL/trace_bigjson.png)

### 9.MySQL监控分析视图-sys schema

关于MysQL的性能监控和问题诊断，我们一般都从performance_schema中去获取想要的数据，在MySQL5.7.7版本中新增sys schema，它performance_schema和information_schema中的数据以更容易理解的方式总结归纳为"视图”，其目的就是为了降低查询performance_schema的复杂度，让DBA能够快速的定位问题。下面看看这些库中都有哪些监控表和视图，掌握了这些，在我们开发和运维的过程中就起到了事半功倍的效果。

#### 9.1Sys schema视图摘要

1. 主机相关:以host_summary开头，主要汇总了IO延迟的信息。
2. Innodb相关:以innodb开头，汇总了innodb buffer信息和事务等待innodb锁的信息。
3. I/o相关:以io开头，汇总了等待l/O、I/o使用量情况。
4. 内存使用情况:以memory开头，从主机、线程、事件等角度展示内存的使用情况
5. 连接与会话信息: processlist和session相关视图，总结了会话相关信息。
6. 表相关:以schema_table开头的视图，展示了表的统计信息。
7. 索引信息:统计了索引的使用情况，包含冗余索引和未使用的索引情况。
8. 语句相关:以statement开头，包含执行全表扫描、使用临时表、排序等的语句信息。
9. 用户相关:以user开头的视图，统计了用户使用的文件lI/o、执行语句统计信息。
10. 等待事件相关信息:以wait开头，展示等待事件的延迟情况。

#### 9.2Sys schema视图使用场景

**索引情况**

```mysql
#1. 查询冗余索引 
select * from sys.schema_redundant_indexes; 
#2. 查询未使用过的索引 
select * from sys.schema_unused_indexes; 
#3. 查询索引的使用情况 
select index_name,rows_selected,rows_inserted,rows_updated,rows_deleted FROM sys.schema_index_statistics WHERE table_schema = 'dbname';
```

**表相关**

```mysql
# 1. 查询表的访问量 
select table_schema,table_name,sum(io_read_requests+io_write_requests) as io from sys.schema_table_statistics group by table_schema,table_name order by io desc; 
# 2. 查询占用bufferpool较多的表 
select object_schema,object_name,allocated,data from sys.innodb_buffer_stats_by_table order by allocated limit 10; 
# 3. 查看表的全表扫描情况 
select * from sys.statements_with_full_table_scans where db='dbname';
```

**语句相关**

```mysql
#1. 监控SQL执行的频率 
select db,exec_count,query from sys.statement_analysis order by exec_count desc; 
#2. 监控使用了排序的SQL 
select db,exec_count,first_seen,last_seen,query from sys.statements_with_sorting limit 1; 
#3. 监控使用了临时表或者磁盘临时表的SQL 
select db,exec_count,tmp_tables,tmp_disk_tables,query from sys.statement_analysis where tmp_tables>0 or tmp_disk_tables >0 order by (tmp_tables+tmp_disk_tables) desc;
```

**IO相关**

```mysql
#1. 查看消耗磁盘IO的文件 
select file,avg_read,avg_write,avg_read+avg_write as avg_io from sys.io_global_by_file_by_bytes order by avg_read limit 10;
```

**Innodb相关**

```mysql
#1. 行锁阻塞情况 
select * from sys.innodb_lock_waits;
```

> 风险提示:
> 通过sys库去查询时，MySQL会消耗大量资源.去收集相关信息，严重的可能会导致业务请求被阻塞，从而引起故障。建议生产上不要频繁的去查询sys或者performance_schema、information_schema来完成监控巡检等工作。

### 10.小结

> 查询是数据库中最频繁的操作，提高查询速度可以有效地提高MysQL数据库的性能。通过对查询语句的分析可以了解查询语句的执行情况，找出查询语句执行的瓶颈，从而优化查询语句。

