---
title: 索引优化与查询优化
date: 2024-07-22 16:07:52
permalink: /pages/4a1908/
article: false
---

## 索引优化与查询优化

都有哪些维度可以进行数据库调优?简言之:·

- 索引失效、没有充分利用到索引—―索引建立
- 关联查询太多JOIN(设计缺陷或不得已的需求)——sQL优化
- 服务器调优及各个参数设置（缓冲、线程数等)——调整my.cnf
- 数据过多――分库分表

关于数据库调优的知识点非常分散。不同的DBMS，不同的公司，不同的职位，不同的项目遇到的问题都不尽相同。这里我们分为三个章节进行细致讲解。

虽然SQL查询优化的技术有很多，但是大方向上完全可以分成物理查询优化和逻辑查询优化两大块。

- 物理查询优化是通过索引和表连接方式等技术来进行优化，这里重点需要掌握索引的使用。
- 逻辑查询优化就是通过SQL等价变换提升查询效率，直白一点就是说，换一种查询写法执行效率可能更高。

### 1.数据准备

学员表插50万条，班级表插1万条。

**步骤1：建表**

```mysql
CREATE TABLE `class` (
	`id` INT ( 11 ) NOT NULL AUTO_INCREMENT,
	`className` VARCHAR ( 30 ) DEFAULT NULL,
	`address` VARCHAR ( 40 ) DEFAULT NULL,
	`monitor` INT NULL,
	PRIMARY KEY ( `id` ) 
) ENGINE = INNODB AUTO_INCREMENT = 1 DEFAULT CHARSET = utf8;
CREATE TABLE `student` (
	`id` INT ( 11 ) NOT NULL AUTO_INCREMENT,
	`stuno` INT NOT NULL,
	`name` VARCHAR ( 20 ) DEFAULT NULL,
	`age` INT ( 3 ) DEFAULT NULL,
	`classId` INT ( 11 ) DEFAULT NULL,
	PRIMARY KEY ( `id` ) #CONSTRAINT `fk_class_id` FOREIGN KEY (`classId`) REFERENCES `t_class` (`id`)

) ENGINE = INNODB AUTO_INCREMENT = 1 DEFAULT CHARSET = utf8;
```

**步骤2：设置参数**

- 命令开启：允许创建函数设置：

```mysql
set global log_bin_trust_function_creators=1; # 不加global只是当前窗口有效。
```

**步骤3：创建函数**

保证每条数据都不同。

```mysql
#随机产生字符串

DELIMITER //
CREATE FUNCTION rand_string ( n INT ) RETURNS VARCHAR ( 255 ) BEGIN
	DECLARE
		chars_str VARCHAR ( 100 ) DEFAULT 'abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ';
	DECLARE
		return_str VARCHAR ( 255 ) DEFAULT '';
	DECLARE
		i INT DEFAULT 0;
	WHILE
			i < n DO
			
			SET return_str = CONCAT(
				return_str,
			SUBSTRING( chars_str, FLOOR( 1+RAND ()* 52 ), 1 ));
		
		SET i = i + 1;
		
	END WHILE;
	RETURN return_str;

END // 
DELIMITER;

#假如要删除 
#drop function rand_string;
```

随机产生班级编号

```mysql
# 用于随机产生多少到多少的编号

DELIMITER //
CREATE FUNCTION rand_num ( from_num INT, to_num INT ) RETURNS INT ( 11 ) BEGIN
	DECLARE
		i INT DEFAULT 0;
	
	SET i = FLOOR(
		from_num + RAND()*(
			to_num - from_num + 1 
		));
	RETURN i;
	
END // 
DELIMITER;
# 假如要删除 
# drop function rand_num;
```

**步骤4：创建存储过程**

```mysql
#创建往stu表中插入数据的存储过程

DELIMITER //
CREATE PROCEDURE insert_stu ( START INT, max_num INT ) BEGIN
	DECLARE
		i INT DEFAULT 0;
	
	SET autocommit = 0;#设置手动提交事务
	REPEAT#循环
		
		SET i = i + 1;#赋值
		INSERT INTO student ( stuno, NAME, age, classId )
		VALUES
			((
					START + i 
					),
				rand_string ( 6 ),
				rand_num ( 1, 50 ),
			rand_num ( 1, 1000 ));
		UNTIL i = max_num 
	END REPEAT;
	COMMIT;#提交事务
	
END // 
DELIMITER;
#假如要删除 
#drop PROCEDURE insert_stu;
```

创建往class表中插入数据的存储过程

```mysql
#执行存储过程，往class表添加随机数据

DELIMITER //
CREATE PROCEDURE `insert_class` ( max_num INT ) BEGIN
	DECLARE
		i INT DEFAULT 0;
	
	SET autocommit = 0;
	REPEAT
			
			SET i = i + 1;
		INSERT INTO class ( classname, address, monitor )
		VALUES
			(
				rand_string ( 8 ),
				rand_string ( 10 ),
			rand_num ( 1, 100000 ));
		UNTIL i = max_num 
	END REPEAT;
	COMMIT;
	
END // 
DELIMITER;
#假如要删除 
#drop PROCEDURE insert_class;
```

**步骤5：调用存储过程**

class

```mysql
#执行存储过程，往class表添加1万条数据
CALL insert_class ( 10000 );
```

stu

```mysql
#执行存储过程，往stu表添加50万条数据
CALL insert_stu ( 100000, 500000 );
```

**步骤6：删除某表上的索引**

创建存储过程

```mysql
DELIMITER //
CREATE PROCEDURE `proc_drop_index` (
	dbname VARCHAR ( 200 ),
	tablename VARCHAR ( 200 )) BEGIN
	DECLARE
		done INT DEFAULT 0;
	DECLARE
		ct INT DEFAULT 0;
	DECLARE
		_index VARCHAR ( 200 ) DEFAULT '';
	DECLARE
		_cur CURSOR FOR SELECT
		index_name 
	FROM
		information_schema.STATISTICS 
	WHERE
		table_schema = dbname 
		AND table_name = tablename 
		AND seq_in_index = 1 
		AND index_name <> 'PRIMARY';#每个游标必须使用不同的DECLARECONTINUE HANDLER FOR NOT found SET done = 1来控制游标的结束
	DECLARE
		CONTINUE HANDLER FOR NOT FOUND 
		SET done = 2;#若没有数据返回,程序继续,并将变量done设为2
	OPEN _cur;
	FETCH _cur INTO _index;
	WHILE
			_index <> '' DO
			
			SET @str = CONCAT( "drop index ", _index, " on ", tablename );
		PREPARE sql_str 
		FROM
			@str;
		EXECUTE sql_str;
		DEALLOCATE PREPARE sql_str;
		
		SET _index = '';
		FETCH _cur INTO _index;
		
	END WHILE;
	CLOSE _cur;
	
END // 
DELIMITER;
```

执行存储过程

```mysql
CALL proc_drop_index ( "dbname", "tablename" );
```

### 2.索引失效案例

MysQL中提高性能的一个最有效的方式是对数据表设计合理的索引。索引提供了高效访问数据的方法，并且加快查询的速度，因此索引对查询的速度有着至关重要的影响。

- 使用索引可以快速地定位表中的某条记录，从而提高数据库查询的速度，提高数据库的性能.
- 如果查询时没有使用索引，查询语句就会扫描表中的所有记录。在数据量大的情况下，这样查询的速度会很慢。

大多数情况下都（默认）采用B+树来构建索引。[只是空间列类型的索引使用R-树，并且MEMORY表还支持hash索引。

其实，用不用索引，最终都是优化器说了算。优化器是基于什么的优化器?基于cost开销

(CostBaseOptimizer )，它不是基于规则(Rule-BasedOptimizer)，也不是基于语义。怎么样开销小就怎么来。另外，==SQL语句是否使用索引，跟数据库版本、数据量、数据选择度都有关系。==

#### 2.1全值匹配我最爱

系统中经常出现的sql语句如下:

```mysql
EXPLAIN SELECT SQL_NO_CACHE *FROM student WHERE age=30 ;
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age=30 and classId=4;
EXPLAIN SELECT SQL_NO_CACHE * FRON student WHERE age=30 and classId=4 AND name = 'abcd ';
```

建立索引前执行:(关注执行时间)

```mysql
mysql> SELECT SQL_NO_CACHE * FROM student WHERE age=30 and classId=4 AND name = 'abcd' ;
Empty set, 1 warning (0.28 sec)
```

建立索引

```mysql
CREATE INDEX idx_age ON student(age) ;
CREATE INDEX idx_age_classid ON student ( age,classId);
CREATE INDEX idx_age_classid_name ON student( age,classId,name) ;
```


建立索引后执行:

```mysql
mysql> SELECT SQL_NO_CACHE * FROM student WHERE age=30 and classId=4 AND name ='abcd';
Empty set，1 warning (0.01 sec)
```

可以看到，创建索引前的查询时间是0.28秒，创建索引后的查询时间是0.01秒，索引帮助我们极大的提高了查询效率。

#### 2.2最佳左前缀法则

在MysQL建立联合索引时会遵守最佳左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。
举例1:

```mysql
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.age=30 AND student.name = 'abcd' ;
```

举例2:

```mysql
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.classid=1 AND student .name = 'abcd' ;
```

举例3:索引idx_age_classid_name还能否正常使用?

```mysql
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE classid=4 AND student.age=3 AND student.name= 'abcd';
```

如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列

```mysql
mysql> EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.age=38 AND student.name ='abcd';
```

![image-20220303092239731](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%881.png)

虽然可以正常使用，但是只有部分被使用到了。

```mysql
mysq1> EXPLAIN SELECT SQL_NO_CACHE * FRON student WHERE student.classid=1 AND student.name ='abcd ' ;
```

![image-20220303092336821](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%882.png)

完全没有使用上索引。
结论:MySQL可以为多个字段创建索引，一个索引可以包括16个字段。对于多列索引，过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用。如果查询条件中没有使用这些字段中第1个字段时，多列(或联合）索引不会被使用。

> 拓展:Alibaba《Java开发手册》
> 索引文件具有B-Tree的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。

#### 2.3主键插入顺序

对于一个使用InnoDB存储引擎的表来说，在我们没有显式的创建索引时，表中的数据实际上都是存储在聚簇索引的叶子节点的。而记录又是存储在数据页中的，数据页和记录又是按照记录主键值从小到大的顺序进行排序，所以如果我们插入的记录的主键值是依次增大的话，那我们每插满一个数据页就换到下一个数据页继续插，而如果我们插入的主键值忽大忽小的话，就比较麻烦了，假设某个数据页存储的记录已经满了，它存储的主键值在1~100之间:

![image-20220303092558057](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%883.png)

如果此时再插入一条主键值为9的记录，那它插入的位置就如下图:

![image-20220303092637894](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%884.png)

可这个数据页已经满了，再插进来咋办呢?我们需要把当前页面分裂成两个页面，把本页中的一些记录移动到新创建的这个页中。页面分裂和记录移位意味着什么?意味着:性能损耗!所以如果我们想尽量避免这样无谓的性能损耗，最好让插入的记录的主键值依次递增，这样就不会发生这样的性能损耗了。所以我们建议:让主键具有AUTO_INCREMENT，让存储引擎自己为表生成主键，而不是我们手动插入，比如: person_info表:

```mysql
CREATE TABLE person_info (
	id INT UNSIGNED NOT NULL AUTO_INCREMENT,
	NAME VARCHAR ( 100 ) NOT NULL,
	birthday DATE NOT NULL,
	phone_number CHAR ( 11 ) NOT NULL,
	country VARCHAR ( 100 ) NOT NULL,
	PRIMARY KEY ( id ),
KEY idx_name_birthday_phone_number ( NAME ( 10 ), birthday, phone_number ) 
);
```

我们自定义的主键列id拥有AUTO_INCREMENT属性，在插入记录时存储引擎会自动为我们填入自增的主键值。这样的主键占用空间小，顺序写入，减少页分裂。

#### 2.4计算、函数、类型转换(自动或手动)导致索引失效

1．这两条sql哪种写法更好

```mysql
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE studelt.name LIKE 'abc%';
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE LEFT(student.name,3) = 'abc';
```

2.创建索引

```mysql
CREATE INDEX idx_name ON student (NAME);
```

3．第一种:索引优化生效

```mysql
mysql> EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.name LIKE 'abc%;
```

![image-20220303093059370](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%885.png)

```mysql
mysql> SELECT SQL_NO_CACHE * FROM student WHERE LEFT(student. name ,3 ) = 'abc ';
.
数据
.
401 rows in set, 1 warning ( 3.62 sec) I
```

再举例:

- student表的字段stuno上设置有索引

  ```mysql
  CREATE INDEX idx_sno ON student (stuno);
  ```

- 索引优化失效:(假设: student表的字段stuno上设置有索引)

  ```mysql
  EXPLAIN SELECT SQL_NO_CACHE id,stuno，NAME FROM student WHERE stuno+1 = 900001;
  ```

  运行结果:

  ![image-20220303093416939](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%886.png)

  你能看到如果对索引进行了表达式计算，索引就失效了。这是因为我们需要把索引字段的取值都取出来，然后依次进行表达式的计算来进行条件判断，因此采用的就是全表扫描的方式，运行时间也会慢很多，最终运行时间为2.538秒。

- 索引优化生效:

  ```mysql
  EXPLAIN SELECT SQL_NO_CACHE id, stuno，NAME FROM student WHERE stuno = 90088e;
  ```

  运行时间为0.039秒。

再举例:

- student表的字段name上设置有索引

  ```mysql
  CREATE INDEX idx_name ON student(NAME);
  ```

  我们想要对name的前三位为abc的内容进行条件筛选，这里我们来查看下执行计划:

- 索引优化失效:

  ```mysql
  EXPLAIN SELECT id, stuno,name FROM student WHERE SUBSTRING(name，1,3) = 'abc';
  ```

  ![image-20220303093812704](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%887.png)

- 索引优化生效:

  ```mysql
  EXPLAIN SELECT id,stuno,NAME FROM student WHERE NAME LIKE 'abc% ';
  ```

  ![image-20220303094149638](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%888.png)

你能看到经过查询重写后，可以使用索引进行范围检索，从而提升查询效率。

#### 2.5类型转换导致索引失效

下列哪个sql语句可以用到索引。(假设name字段上设置有索引)

```mysql
#未使用到索引
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE name=123;
```

![image-20220303094131016](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%889.png)

```mysql
#使用到索引
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE name=' 123';
```

![image-20220303094328178](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%8810.png)

- name=123发生类型转换，索引失效。

> 结论:设计实体类属性时，一定要与数据库字段类型相对应。否则，就会出现类型转换的情况。

#### 2.6范围条件右边的列索引失效

1. 如果系统经常出现的sql如下:

```mysql
ALTER TABLE student DROP INDEX idx_name ;
ALTER TABLE student DROP INDEX idx_age ;
ALTER TABLE student DROP INDEX idx_age_classid ;

EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.age=30 AND student.classId>20 AND student. name = 'abc' ;
```

![image-20220303094647878](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%8811.png)

2．那么索引 idx_age_classid_name这个索引还能正常使用么?

- 不能，范围右边的列不能使用。比如:(<)(=)(>)(>=）和between 等。

- 如果这种sql出现较多，应该建立:

  ```mysql
  create index idx_age_name_classid on student(age , name , classid);
  ```

- 将范围查询条件放置语句最后:

```mysql
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.age=30 AND student.name=' abc' AND student.classId>20 ;
```

> 应用开发中范围查询，例如:金额查询，日期查询往往都是范围查询。应将查询条件放置where语句最后。(创建的联合索引中，务必把范围涉及到的字段写在最后)。

3.效果

```mysql
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.age=30 AND student.classId>20 ANDstudent.name = 'abc ’;
```

![image-20220303095129629](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%8812.png)

#### 2.7不等于（!=或者<>）索引失效

- 为name字段创建索引

  ```mysql
  CREATE INDEX idx_name ON student (NAME);
  ```

- 查看索引是否失效

  ```mysql
  EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student. name <> 'abe';
  ```

  ![image-20220303095547500](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%8813.png)

或者

```mysql
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.name != 'abc';
```

![image-20220303095634740](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%8814.png)
场景举例:用户提出需求，将财务数据，产品利润金额不等于o的都统计出来。

#### 2.8 is null可以使用索引，is not null无法使用索引

- IS NULL:可以触发索引

  ```mysql
  EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age IS NULL;
  ```

  ![image-20220303095832761](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%8815.png)

- IS NOT NULL:无法触发索引

  ```mysql
  EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age IS NOT NULL;
  ```

  ![image-20220303100003572](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%8816.png)

> 结论:最好在设计数据表的时候就将字段设置为 NOT NULL约束，比如你可以将INT类型的字段默认值设置为0。将字符类型的默认值设置为空字符串('')。
>
> 拓展:同理，在查询中使用not like 也无法使用索引，导致全表扫描。

#### 2.9 like以通配符%开头索引失效

在使用LIKE关键字进行查询的查询语句中，如果匹配字符串的第一个字符为“%”，索引就不会起作用。只有“%"不在第一个位置，索引才会起作用。

- 使用到索引

  ```mysql
  EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE name LIKE 'ab%';
  ```

  ![image-20220303100309802](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%8817.png)

- 未使用到索引

  ```mysql
  EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE name LIKE '%ab%';
  ```

  ![image-20220303100401131](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%8818.png)

> 拓展:Alibaba《Java开发手册》
>
> 【强制】页面搜索严禁左横糊或者全模糊，如果需要请走搜索引擎来解决。

#### 2.10 OR前后存在非索引的列,索引失效

在WHERE子句中，如果在OR前的条件列进行了索引，而在OR后的条件列没有进行索引，那么索引会失效。也就是说，==OR前后的两个条件中的列都是索引时，查询中才使用索引。==
因为OR的含义就是两个只要满足一个即可，因此只有一个条件列进行了索引是没有意义的，只要有条件列没有进行索引，就会进行全表扫描，因此索引的条件列也会失效。
查询语句使用OR关键字的情况:

```mysql
#未使用到索引
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 10 OR classid = 100;
```

![image-20220303100629645](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%8819.png)

因为classid字段上没有索引，所以上述查询语句没有使用索引。

```mysql
#使用到索引
EXPLAIN SELECT SQL_NO_CACHE *FROM student WHERE age = 10 OR name = 'Abel' ;
```

![image-20220303100736559](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%8820.png)

#### 2.11数据库和表的字符集统一使用utf8mb4

统一使用utf8mb4(5.5.3版本以上支持)兼容性更好，统一字符集可以避免由于字符集转换产生的乱码。不同的字符集进行比较前需要进行转换会造成索引失效。

#### 2.12练习及一般性建议

**练习:**假设:index(a,b,c)

| Where语句                                          | 索引是否被使用                                               |
| -------------------------------------------------- | ------------------------------------------------------------ |
| where a = 3                                        | Y,使用到a                                                    |
| where a= 3 and b = 5                               | Y,使用到a, b                                                 |
| where a = 3 and b= 5 and c= 4                      | Y,使用到a,b,c                                                |
| where b= 3或者 where b= 3 and c = 4 或者where c= 4 | N                                                            |
| where a= 3 and c = 5                               | 使用到a，但是c不可以，b中间断了                              |
| where a = 3 and b>4 and c= 5                       | 使用到a和b，c不能用在范围之后，b断了                         |
| where a is null and b is not null                  | is null支持索引但是is not null不支持。所以a可以使用索引，但是b不可以使用 |
| where a <> 3                                       | 不能使用索引                                                 |
| where abs(a)=3                                     | 不能使用索引                                                 |
| where a = 3 and b like 'kk%’ and c =4              | Y,使用到a,b,c                                                |
| where a = 3 and b like '%kk' and c =4              | Y,只用到a                                                    |
| where a = 3 and b like '%kk%' and c=4              | Y,只用到a                                                    |
| where a = 3 and b like ‘k%kk%' and c = 4           | Y,使用到a,b,c                                                |

**一般性建议:**

- 对于单列索引，尽量选择针对当前query过滤性更好的索引
- 在选择组合索引的时候，当前query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。
- 在选择组合索引的时候，尽量选择能够包含当前query中的where子句中更多字段的索引。
- 在选择组合索引的时候，如果某个字段可能出现范围查询时，尽量把这个字段放在索引次序的最后面。

==总之，书写SQL语句时，尽量避免造成索引失效的情况。==

### 3.关联查询优化

#### 3.1.数据准备

```mysql
#分类
CREATE TABLE IF NOT EXISTS `type` (
`id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,
`card` INT(10) UNSIGNED NOT NULL,
PRIMARY KEY (`id`)
);
#图书
CREATE TABLE IF NOT EXISTS `book` (
`bookid` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,
`card` INT(10) UNSIGNED NOT NULL,
PRIMARY KEY (`bookid`)
);

#向分类表中添加20条记录
INSERT INTO TYPE(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO TYPE(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO TYPE(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO TYPE(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO TYPE(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO TYPE(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO TYPE(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO TYPE(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO TYPE(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO TYPE(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO TYPE(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO TYPE(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO TYPE(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO TYPE(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO TYPE(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO TYPE(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO TYPE(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO TYPE(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO TYPE(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO TYPE(card) VALUES(FLOOR(1 + (RAND() * 20)));

#向图书表中添加20条记录
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
```

#### 3.2.采用左外链接

下面开始EXPLAIN分析

```mysql
EXPLAIN SELECT SQL_NO_CACHE * FROM type LEFT JOIN book ON type.card = book.card;
```

![image-20220303105229966](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E5%B7%A6%E5%A4%96%E8%BF%9E%E6%8E%A51.png)

结论:

type有All

添加索引优化

```mysql
ALTER TABLE book ADD INDEX Y (card); #【被驱动表】，可以避免全表扫描
EXPLAIN SELECT SQL_NO_CACHE * FROM type LEFT JOIN book ON type.card = book.card;
```

![image-20220303105400690](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E5%B7%A6%E5%A4%96%E9%93%BE%E6%8E%A52.png)

#### 3.3采用内连接

```mysql
drop index X on type;
drop index Y on book;(如果已经删除了可以不用再执行该操作)
```

换成inner join(MySQL自动选择驱动表)

```mysql
EXPLAIN SELECT SQL_NO_CACHE * FROM type INNER JOIN book ON type.card=book.card;
```

![image-20220303105740884](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E5%86%85%E8%BF%9E%E6%8E%A51.png)
添加索引优化

```mysql
ALTER TABLE book ADD INDEX Y( card);
EXPLAIN SELECT SQL_NO_CACHE * FROM type INNER JOIN book ON type.card=book.card;
```

![image-20220303110029498](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E5%86%85%E8%BF%9E%E6%8E%A52.png)

```mysql
ALTER TABLE type ADD INDEX X (card) ;
EXPLAIN SELECT SQL_NO_CACHE * FROM type INNER JOIN book ON type.card=book.card ;
```

![image-20220303110123151](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E5%86%85%E8%BF%9E%E6%8E%A53.png)

接着:

```mysql
DROP INDEX X ON type;
EXPLAIN SELECT SQL_NO_CACHE * FROM TYPE INNER JOIN book ON type.card=book.card ;
```

![image-20220303110234303](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E5%86%85%E8%BF%9E%E6%8E%A54.png)

接着:

```mysql
ALTER TABLE type ADD INDEX X (card) ;
EXPLAIN SELECT SQL_NO_CACHE * FROM type INNER JOIN book ON type.card=book.card;
```

![image-20220303110459209](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E5%86%85%E8%BF%9E%E6%8E%A55.png)

接着：

```mysql
#向表中再添加数据（20条数据）
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));
INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));


ALTER TABLE book ADD INDEX Y ( card);
EXPLAIN SELECT SQL_NO_CACHE * FROM TYPE INNER JOIN book ON type.card=book.card;
```

![image-20220303110842027](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E5%86%85%E8%BF%9E%E6%8E%A56.png)

图中发现，由于type表数据大于book表数据，MySQL选择将type作为被驱动表。

#### 3.4join语句原理

join方式连接多个表，本质就是各个表之间数据的循环匹配。MySQL5.5版本之前，MySQL只支持一种表间关联方式，就是嵌套循环(Nested Loop Join)。如果关联表的数据量很大，则join关联的执行时间会非常长。在MySQL5.5以后的版本中，MySQL通过引入BNLJ算法来优化嵌套执行。

##### 1.驱动表和被驱动表

驱动表就是主表，被驱动表就是从表、非驱动表。

- 对于内连接来说

  ```mysql
  SELECT *FROM A JOIN B ON ...
  ```

  A一定是驱动表吗?不一定，优化器会根据你查询语句做优化，决定先查哪张表。先查询的那张表就是驱动表，反之就是被驱动表。通过explain关键字可以查看。

- 对于外连接来说:

  ```mysql
  SELECT * FROM A LEFT JOIN B ON ...
  #或
  SELECT * FROM B RIGHT JOIN A ON ...
  ```

  通常，大家会认为A就是驱动表，B就是被驱动表。但也未必。测试如下:

  ```mysql
  CREATE TABLE a(f1 INT,f2 INT,INDEX(f1))ENGINE=INNODB;
  CREATE TABLE b(f1 INT,f2 INT)ENGINE=INNODB;
  INSERT INTO a VALUES( 1,1),(2,2),(3,3),(4,4),(5,5),(6,6);
  INSERT INTO b VALUES(3,3),(4,4),(5,5),(6,6),(7,7),(8,8);
  SELECT * FROM b;
  #测试1
  EXPLAIN SELECT *FROM a LEFT JOIN b ON(a.f1=b.f1) WHERE (a.f2=b.f2);
  #测试2
  EXPLAIN SELECT * FROM a LEFT JOIN b ON(a.f1=b.f1) AND ( a .f2=b.f2);
  ```

##### 2. Simple Nested-Loop Join(简单嵌套循环连接)

算法相当简单，从表A中取出一条数据1，遍历表B，将匹配到的数据放到Hesult..l以此类推，驱动表A中的每一条记录与被驱动表B的记录进行判断:

![image-20220303112145477](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E7%AE%80%E5%8D%95%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%E8%BF%9E%E6%8E%A5.png)

可以看到这种方式效率是非常低的，以上述表A数据10o条，表B数据10oo条计算，则A*B= 10万次。开销统计如下:

| 开销统计          | SNLJ  |
| ----------------- | ----- |
| 外表扫描次数:     | 1     |
| 内表扫描次数:     | A     |
| 读取记录数:       | A+B*A |
| JOIN比较次数:     | B*A   |
| 回表读取记录次数: | 0     |

当然mysql肯定不会这么粗暴的去进行表的连接，所以就出现了后面的两种对Nested-Loop Join优化算法。

##### 3.Index Nested-Loop Join(索引嵌套循环连接)

Index Nested-Loop Join其优化的思路主要是为了减少内层表数据的匹配次数，所以要求被驱动表上必须有索引才行。通过外层表匹配条件直接与内层表索引进行匹配，避免和内层表的每条记录去进行比较，这样极大的减少了对内层表的匹配次数。

![image-20220303112643420](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E7%B4%A2%E5%BC%95%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%E8%BF%9E%E6%8E%A5.png)

驱动表中的每条记录通过被驱动表的索引进行访问，因为索引查询的成本是比较固定的，故mysql优化器都倾向于使用记录数少的表作为驱动表(外表)。

| 开销统计          | SNLJ  | INLJ                  |
| ----------------- | ----- | --------------------- |
| 外表扫描次数:     | 1     | 1                     |
| 内表扫描次数:     | A     | 0                     |
| 读取记录数:       | A+B*A | A+B(match)            |
| JOIN比较次数:     | B*A   | A*Index(Height)       |
| 回表读取记录次数: | 0     | B(match)(if possible) |

如果被驱动表加索引，效率是非常高的，但如果索引不是主键索引，所以还得进行一次回表查询相比，被驱动表的索引是主键索引，效率会更高。

##### 4.Block Nested-Loop Join(块嵌套循环连接)

如果存在索引，那么会使用index的方式进行join，如果join的列没有索引，被驱动表要扫描的次数太多了。每次访问被驱动表，其表中的记录都会被加载到内存中，然后再从驱动表中取一条与其匹配，匹配结束后清除内存，然后再从驱动表中加载一条记录，然后把被驱动表的记录在加载到内存匹配，这样周而复始，大大增加了I0的次数。为了减少被驱动表的Io次数，就出现了Block Nested-Loop Join的方式。

不再是逐条获取驱动表的数据，而是一块一块的获取，引入了join buffer缓冲区，将驱动表join相关的部分数据列(大小受join buffer的限制)缓存到join buffer中，然后全表扫描被驱动表，被驱动表的每一条记录一次性和joinbuffer中的所有驱动表记录进行匹配(内存中操作)，将简单嵌套循环中的多次比较合并成一次降低了被驱动表的访问频率。

> 注意:
> 这里缓存的不只是关联表的列,select后面的列也会缓存起来。
>
> 在一个有N个join关联的sql中会分配N-1个join buffer。所以查询的时候尽量减少不必要的字段，可以让joinbuffer中可以存放更多的列。

![image-20220303113258323](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E5%9D%97%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%E8%BF%9E%E6%8E%A5.png)

| 开销统计          | SNLJ  | INLJ                  | BNLJ                                          |
| ----------------- | ----- | --------------------- | --------------------------------------------- |
| 外表扫描次数:     | 1     | 1                     | 1                                             |
| 内表扫描次数:     | A     | 0                     | A*used_column_size / join_buffer_size+1       |
| 读取记录数:       | A+B*A | A+B(match)            | A+B* (A *used_column_size / join_buffer_size) |
| JOIN比较次数:     | B*A   | A*Index(Height)       | B*A                                           |
| 回表读取记录次数: | 0     | B(match)(if possible) | 0                                             |

参数设置:

- block_nested_loop
  通过`show variables like '%optimizer_switch%'`查看block_nested_loop状态。默认是开启的。

- join_buffer_size
  驱动表能不能一次加载完，要看join buffer能不能存储所有的数据，默认情况下join_buffer_size=256k。

  ![image-20220303114106620](https://gitee.com/kiteflyer/picture/raw/master/MySQL/join_buffer.png)

join_buffer_size的最大值在32位系统可以申请4G，而在64位操做系统下可以申请大于4G的Join Buffer空间(64位Windows除外，其大值会被截断为4GB并发出警告)。

##### 5.小结

1. 整体效率比较:INLJ >BNLJ > SNLJ

2. 永远用小结果集驱动大结果集(其本质就是减少外层循环的数据数量) (小的度量单位指的是表行数*每行大小)

   ```mysql
   select t1.b,t2.* from t1 straight_join t2 on (t1.b=t2.b) where t2.id<=100;#推荐
   select t1.b,t2.* from t2 straight_join t1 on (t1.b=t2.b) where t2.id<=100;#不推荐
   ```

3. 为被驱动表匹配的条件增加索引(减少内层表的循环匹配次数)

4. 增大join buffer size的大小(一次缓存的数据越多，那么内层包的扫表次数就越少)

5. 减少驱动表不必要的字段查询（字段越少，join buffer所缓存的数据就越多)

##### 6.Hash Join

从MySQL的8.0.20版本开始将废弃BNLJ，因为从MySQL8.0.18版本开始就加入了hash join默认都会使用hash join

- Nested Loop:

  对于被连接的数据子集较小的情况，Nested Loop是个较好的选择。

- Hash Join是做大数据集连接时的常用方式，优化器使用两个表中较小(相对较小)的表利用Join Key在内存中建立散列表，然后扫描较大的表并探测散列表，找出与Hash表匹配的行。

    - 这种方式适用于较小的表完全可以放于内存中的情况，这样总成本就是访问两个表的成本之和。
    - 在表很大的情况下并不能完全放入内存，这时优化器会将它分割成若干不同的分区，不能放入内存的部分就把该分区写入磁盘的临时段，此时要求有较大的临时段从而尽量提高I/o的性能。
    - 它能够很好的工作于没有索引的大表和并行查询的环境中，并提供最好的性能。大多数人都说它是Join的重型升降机。Hash Join只能应用于等值连接(如WHERE A.COL1=B.COL2)，这是由Hash的特点决定的。

| 类别     | Nested Loop                                                  | Hash Join                                                    |
| :------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 使用条件 | 任何条件                                                     | 等值连接(=)                                                  |
| 相关资源 | CPU、磁盘I/O                                                 | 内存、临时空间                                               |
| 特点     | 当有高选择性索引或进行限制性搜索时效率比较高，能够快速返回第一次的搜索结果。 | 当缺乏索引或者索引条件模糊时，Hash Join比NestedLoop有效。在数据仓库环境下，如果表的纪录数多，效率高。 |
| 缺点     | 缺当索引丢失或者查询条件限制不够时，效点率很低;当表的纪录数多时，效率低。 | 为建立哈希表，需要大量内存。第一次的结果返回较慢。           |

### 4.子查询优化

MysQL从4.1版本开始支持子查询，使用子查询可以进行SELECT语句的嵌套查询，即一个SELECT查询的结果作为另一个SELECT语句的条件。子查询可以一次性完成很多逻辑上需要多个步骤才能完成的SQL操作。
子查询是MySQL的一项重要的功能，可以帮助我们通过一个SQL语句实现比较复杂的查询。但是,子查询的执行效率不高。原因:

1. 执行子查询时，MySQL需要为内层查询语句的查询结果建立一个临时表，然后外层查询语句从临时表中查询记录。查询完毕后，再撤销这些临时表。这样会消耗过多的CPU和lo资源，产生大量的慢查询。
2. 子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响。
3. 对于返回结果集比较大的子查询，其对查询性能的影响也就越大。

在MySQL中，可以使用连接（JOIN)查询来替代子查询。连接查询不需要建立临时表，其速度比子查询要快，如果查询中使用索引的话，性能就会更好。

举例1:查询学生表中是班长的学生信息

- 使用子查询

  ```mysql
  #创建班级表中班长的索引
  CREATE INDEX idx_monitor ON class(monitor);
  
  #查询班长的信息
  EXPLAIN SELECT * FROM student stu1
  WHERE stu1.`stuno` IN (
  SELECT monitor
  FROM class c
  WHERE monitor IS NOT NULL
  );
  ```

- 推荐：使用多表查询

  ```mysql
  EXPLAIN SELECT stu1.* FROM student stu1 JOIN class c 
  ON stu1.`stuno` = c.`monitor`
  WHERE c.`monitor` IS NOT NULL;
  ```

举例2：取所有不为班长的同学

- 不推荐

  ```mysql
  EXPLAIN SELECT SQL_NO_CACHE a.* 
  FROM student a 
  WHERE  a.stuno  NOT  IN (
  			SELECT monitor FROM class b 
  			WHERE monitor IS NOT NULL) 
  ```

- 推荐

  ```mysql
  EXPLAIN SELECT SQL_NO_CACHE a.*
  FROM  student a LEFT OUTER JOIN class b 
  ON a.stuno =b.monitor
  WHERE b.monitor IS NULL;
  ```

  可以看到查询时间从1分26.74秒缩减为了22.83秒，极大的提升了效率。

> 结论:尽量不要使用NOT IN或者NOT EXISTS，用LEFT JOIN xxx ON xx WHERE xx IS NULL替代

### 5.排序优化

#### 5.1排序优化

**问题:**在WHERE条件字段上加索引，但是为什么在ORDER BY字段上还要加索引呢?

**回答:**
在MysQL中，支持两种排序方式，分别是FileSort和Index排序。

- Index排序中，索引可以保证数据的有序性，不需要再进行排序，效率更高。
- FileSort 排序则一般在内存中进行排序，占用CPU较多。如果待排结果较大，会产生临时文件I/o到磁盘进行排序的情况，效率较低。

**优化建议:**

1. SQL中，可以在WHERE子句和ORDER BY子句中使用索引，目的是在WHERE子句中避免全表扫描，在ORDERBY子句避免使用FileSort排序。当然，某些情况下全表扫描，或者FileSort 排序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。
2. 尽量使用Index完成 ORDER BY排序。如果WHERE和ORDER BY后面是相同的列就使用单索引列;如果不同就使用联合索引。
3. 无法使用Index时，需要对 FileSort方式进行调优。

#### 5.2测试

删除student表和class表中已创建的索引：

```mysql
#方式1:
DROP INDEX idx_monitor ON class;

DROP INDEX idx_cid ON student;
DROP INDEX idx_age ON student;
DROP INDEX idx_name oN student;
DROP INDEX idx_age_name_classid ON student;
DROP INDEX idx_age_classid_name oN student;

#方式2:
call proc_drop_index( 'atguigIdb2' , 'student');
```

以下是否能使用到索引，能否去掉using filesort：

**过程一：**

```mysql
EXPLAIN SELECT SQL_NO_CACHE * FROM student ORDER BY age,classid; 
```

![image-20220303134013899](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E6%8E%92%E5%BA%8F%E6%97%A0%E7%B4%A2%E5%BC%951.png)

```mysql
EXPLAIN SELECT SQL_NO_CACHE * FROM student ORDER BY age,classid LIMIT 10; 
```

![image-20220303134041152](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E6%8E%92%E5%BA%8F%E6%97%A0%E7%B4%A2%E5%BC%952.png)

**过程二: order by时不limit，索引失效**

```mysql
#创建索引  
CREATE  INDEX idx_age_classid_name ON student (age,classid,NAME);

#不限制,索引失效
EXPLAIN  SELECT SQL_NO_CACHE * FROM student ORDER BY age,classid; 
```

![image-20220303134235889](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E6%8E%92%E5%BA%8F%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E4%B8%8D%E5%88%86%E9%A1%B5.png)

```mysql
#增加limit过滤条件，使用上索引了。
EXPLAIN  SELECT SQL_NO_CACHE * FROM student ORDER BY age,classid LIMIT 10;  
```

![image-20220303134356618](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E6%8E%92%E5%BA%8F%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E5%88%86%E9%A1%B5.png)

**过程三:order by时顺序错误，索引失效**

```mysql
#创建索引age , classid , stuno
CREATE INDEX idx_age_classid_stuno ON student ( age , classid,stuno ) ;

#以下哪些索引失效?
EXPLAIN SELECT *FROM student ORDER BY classid LIMIT 10;
EXPLAIN SELECT * FROM student ORDER BY classid , NAME LIMIT 10;
EXPLAIN SELECT * FROM student ORDER BY age, classid , stuno LIMIT 10;
EXPLAIN SELECT * FROM student ORDER BY age , classid LIMIT 10;
EXPLAIN SELECT * FROM student ORDER BY age LIMIT 10;
```

**过程四: order by时规则不一致,索引失效（顺序错，不索引;方向反，不索引）**

```mysql
EXPLAIN SELECT * FROM student ORDER BY age DESc，classid ASC LIMIT 10;
EXPLAIN SELECT * FROM student ORDER BY classid DESC，NAME DESC LIMIT 10;
EXPLAIN SELECT * FROM student ORDER BY age ASC,classid DESC LIMIT 10;
EXPLAIN SELECT * FROM student ORDER BY age DESc, classid DESC LIMIT 10;
```

**过程五：无过滤，不索引**

```mysql
EXPLAIN  SELECT * FROM student WHERE age=45 ORDER BY classid;

EXPLAIN  SELECT * FROM student WHERE  age=45 ORDER BY classid,NAME; 

EXPLAIN  SELECT * FROM student WHERE  classid=45 ORDER BY age;

EXPLAIN  SELECT * FROM student WHERE  classid=45 ORDER BY age LIMIT 10;

CREATE INDEX idx_cid ON student(classid);
EXPLAIN  SELECT * FROM student WHERE  classid=45 ORDER BY age;
```

**小结：**

```mysql
INDEX a_b_c( a , b, c)

order by 能使用索引最左前缀
-ORDER BY a
-ORDER BY a , b
- ORDER BY a , b, c
-ORDER BY a DESC, b DESC , c DESC

如果WHERE使用索引的最左前缀定义为常量，则order by 能使用索引
- WHERE a = const ORDER BY b , c
- WHERE a = const AND b = const ORDER BY c
- WHERE a = const ORDER BY b, c
- WHERE a = const AND b > const ORDER BY b , c

不能使用索引进行排序
-ORDER BY a ASC, b DESC, c DESC/*排序不一致*/
- WHERE g = const ORDER BY b,c/*丢失a索引*/
- WHERE a = const ORDER BY c/*丢失b索引*/
- WHERE a = const ORDER BY a, d/*d不是索引的一部分*/
- WHERE a in (...) ORDER BY b, c/*对于排序来说，多个相等条件也是范围查询*/
```

#### 5.3案例实战

ORDER BY子句，尽量使用Index方式排序，避免使用FileSort方式排序。

执行案例前先清除student上的索引，只留主键:

```mysql
DROP INDEX idx_age ON student;
DROP INDEX idx_age_classid_stuno ON student;
DROP INDEX idx_age_classid_name ON student ;

#或者
call proc_drop_index ( 'atguigudb2 ' , 'student ' ) ;
```

**场景:查询年龄为30岁的，且学生编号小于101000的学生，按用户名称排序**

```mysql
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 30 AND stuno <101000 ORDER BY NAME ;
```

![image-20220303140421709](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E6%8E%92%E5%BA%8F%E6%9C%AA%E5%8A%A0%E7%B4%A2%E5%BC%95%E6%A1%88%E5%88%97.png)

> 结论: type是ALL，即最坏的情况。Extra里还出现了Using filesort,也是最坏的情况。优化是必须的

**优化思路:**
方案一:为了去掉filesort我们可以把索引建成

```mysql
#创建新索引
CREATE INDEX idx_age_name ON student( age , NAME) ;

EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 30 AND stuno <101000 ORDER BY NAME;
```

结果如下：

![image-20220303140711966](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E6%8E%92%E5%BA%8F%E5%8A%A0%E7%B4%A2%E5%BC%95%E6%A1%88%E5%88%97.png)

```mysql
mysql> SELECT SQL_NO_CACHE * FROM student WHERE age = 30 AND stuno <101000 ORDER BY NAME;
+-----+--------+--------+------+---------+
| id  | stuno  | name   | age  | classId |
+-----+--------+--------+------+---------+
|  10 | 100010 | BjpXVI |   30 |     933 |
| 629 | 100629 | bkUUOj |   30 |     402 |
| 212 | 100212 | DNddiJ |   30 |     137 |
| 383 | 100383 | ElqXNY |   30 |      58 |
| 117 | 100117 | EpNRYp |   30 |      16 |
| 611 | 100611 | eTeTdN |   30 |     680 |
| 345 | 100345 | fxXwoe |   30 |     745 |
| 193 | 100193 | IVEknJ |   30 |     929 |
| 826 | 100826 | jPxTZp |   30 |    1000 |
| 539 | 100539 | LPRQBm |   30 |     223 |
| 156 | 100156 | NszuBw |   30 |     660 |
| 579 | 100579 | oHrMLs |   30 |     915 |
| 869 | 100869 | swfiCm |   30 |     220 |
| 123 | 100123 | TsiMlS |   30 |     438 |
| 513 | 100513 | ztuRaA |   30 |     354 |
+-----+--------+--------+------+---------+
15 rows in set, 1 warning (0.04 sec)
```

这样我们就优化掉了，using filesort。

方案二:尽量让where的过滤条件和排序使用上索引建一个三个字段的组合索引:


```mysql
#方案二:
DROP INDEX idx_age_name ON student ;
CREATE INDEX idx_age_stuno_name ON student (age , stuno ,NAME);
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 30 AND stuno <101000 ORDER BY NANE ;
```

结果如下：

![image-20220303141318540](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E6%8E%92%E5%BA%8F%E5%8A%A0%E7%B4%A2%E5%BC%95%E6%A1%88%E5%88%972.png)

```mysql
mysql> SELECT SQL_NO_CACHE * FROM student WHERE age = 30 AND stuno <101000 ORDER BY name ;
+-----+--------+--------+------+---------+
| id  | stuno  | name   | age  | classId |
+-----+--------+--------+------+---------+
|  10 | 100010 | BjpXVI |   30 |     933 |
| 629 | 100629 | bkUUOj |   30 |     402 |
| 212 | 100212 | DNddiJ |   30 |     137 |
| 383 | 100383 | ElqXNY |   30 |      58 |
| 117 | 100117 | EpNRYp |   30 |      16 |
| 611 | 100611 | eTeTdN |   30 |     680 |
| 345 | 100345 | fxXwoe |   30 |     745 |
| 193 | 100193 | IVEknJ |   30 |     929 |
| 826 | 100826 | jPxTZp |   30 |    1000 |
| 539 | 100539 | LPRQBm |   30 |     223 |
| 156 | 100156 | NszuBw |   30 |     660 |
| 579 | 100579 | oHrMLs |   30 |     915 |
| 869 | 100869 | swfiCm |   30 |     220 |
| 123 | 100123 | TsiMlS |   30 |     438 |
| 513 | 100513 | ztuRaA |   30 |     354 |
+-----+--------+--------+------+---------+
15 rows in set, 1 warning (0.00 sec)
```

我们发现using filesort依然存在，所以name并没有用到索引．而且type还是range光看字面其实并不美好。原因是，因为stuno是一个范围过滤，所以索引后面的字段不会再使用索引了。

结果竟然有filesort的sql运行速度，超过了已经优化掉 filesort的 sql，而且快了很多，几乎一瞬间就出现了结果。
原因:

所有的排序都是在条件过滤之后才执行的。所以，如果条件过滤掉大部分数据的话，剩下几百几千条数据进行排序其实并不是很消耗性能，即使索引优化了排序，但实际提升性能很有限。相对的stuno<101000这个条件，如果没有用到索引的话，要对几万条的数据进行扫描，这是非常消耗性能的，所以索引放在这个字段上性价比最高，是最优选择。

> 结论:
> 1.两个索引同时存在，mysql自动选择最优的方案。(对于这个例子，mysql选择idx_age_stuno.但是，随着数据量的变化，选择的索引也会随之变化的。
> 2.当【范围条件】和【group by或者order by】的字段出现二选一时，优先观察条件字段的过滤数量，如果过滤的数据足够多，而需要排序的数据并不多时，优先把索引放在范围字段上。反之，亦然。

思考:这里我们使用如下索引，是否可行? 可以

```mysql
DROP INDEX idx_age_stuno_name ON student;
CREATE INDEX idx_age_stuno ON student(age , stuno) ;
```

#### 5.4filesort算法:双路排序和单路排序

排序的字段若如果不在索引列上，则filesort会有两种算法:双路排序和单路排序

**双路排序（慢)**

- MySQL4.1之前是使用双路排序，字面意思就是两次扫描磁盘，最终得到数据，读取行指针和order by列,对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出
- 从磁盘取排序字段，在buffer进行排序，再从磁盘取其他字段。

取一批数据，要对磁盘进行两次扫描，众所周知，l0是很耗时的，所以在mysql4.1之后，出现了第二种改进的算法，就是单路排序。
**单路排序（快)**

从磁盘读取查询需要的所有列，按照order by列在buffer对它们进行排序，然后扫描排序后的列表进行输出，它的效率更快一些，避免了第二次读取数据。并且把随机lO变成了顺序I0，但是它会使用更多的空间，因为它把每一行都保存在内存中了。

**结论及引申出的问题**

- 由于单路是后出的，总体而言好过双路

- 但是用单路有间题
    - 在sort_buffer中，单路比多路要多占用很多空间，因为单路是把所有字段都取出,所以有可能取出的数据的总大小超出了当sort_buffer的容量，导致每次只能取sort_buffer容量大小的数据，进行排序(创建tmp文件件，多路合并)，排完再取sort_buffer容置大小，再排.....从而多次I/o。
    - 单路本来想省一次I/O操作，反而导致了大量的工/0操作，反而得不偿失。

**优化策略**
1.尝试提高sort_buffer_size

- 不管用哪种算法，提高这个参数都会提高效率，要根据系统的能力去提高，因为这个参数是针对每个进程(connection)的1M-8M之间调整。MySQL5.7，InnoDB存储引擎默认值是1048576字节，1MB

  ```mysql
  SHow VARIABLES LIKE '%sort_buffer_size%';
  ```

  ![image-20220303142859439](https://gitee.com/kiteflyer/picture/raw/master/MySQL/sort_buffer_size.png)

2.尝试提高max_length_for_sort_data

- 提高这个参数，会增加用改进算法的概率。

  ```mysql
  SHOW VARIABLES LIKE '%max_length_for_sort_data%'; #默认1024字节
  ```

- 但是如果设的太高，数据总容量超出sort_buffer_size的概率就增大，明显症状是高的磁盘I/O活动和低的处理器使用率。如果需要返回的列的总长度大于max_length_for_sort_data，使用双路算法，否则使用单路算法。1024-8192字节之间调整

3.Order by时select*是一个大忌。最好只Query需要的字段。原因:

- 当Query的字段大小总和小于max_length_for_sort_data，而且排序字段不是TEXT|BLOB类型时，会用改进后的算法―—单路排序，否则用老算法――多路排序。
- 两种算法的数据都有可能超出sort_buffer_size的容量，超出之后，会创建tmp文件进行合并排序，导致多次l/o，但是用单路排序算法的风险会更大一些，所以要提高sort_buffer_size。

### 6.GROUP BY优化

- group by使用索引的原则几乎跟order by一致，group by即使没有过滤条件用到索引，也可以直接使用索引。
- group by先排序再分组，遵照索引建的最佳左前缀法则
- 当无法使用索引列，增大max_length_for_sort_data和sort_buffer_size参数的设置.
- where效率高于having，能写在where限定的条件就不要写在having中了
- 减少使用order by，和业务沟通能不排序就不排序，或将排序放到程序端去做。Order by、group by、distinct这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。
- 包含了order by、group by、distinct这些查询的语句，where条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢。

### 7.优化分页查询

一般分页查询时，通过创建覆盖索引能够比较好地提高性能。一个常见又非常头疼的问题就是limit 2000000,10，此时需要MysQL排序前200001记录，仅仅返回2000000 - 2000010的记录，其他记录丢弃，查询排序的代价非常大。

```mysql
EXPLAIN SELECT * FROM student LIMIT 2000000,10;
```

![image-20220303145111428](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E5%88%86%E9%A1%B5%E4%BC%98%E5%8C%961.png)

**优化思路一**
在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。

```mysql
EXPLAIN SELECT * FROM student t,(SELECT id FROM student ORDER BY id LIMIT 2000000,10) a WHERE t.id = a.id ;
```

![image-20220303145245648](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E5%88%86%E9%A1%B5%E4%BC%98%E5%8C%962.png)

**优化思路二**
该方案适用于主键自增的表，可以把Limit查询转换成某个位置的查询。

```mysql
EXPLAIN SELECT * FROM student WHERE id > 2000000 LIMIT 10;
```

![image-20220303145455788](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E5%88%86%E9%A1%B5%E4%BC%98%E5%8C%963.png)

### 8.优先考虑覆盖索引

#### 8.1什么是覆盖索引?

理解方式一︰索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据;当能通过读取索引就可以得到想要的数据，那就不需要读取行了。一个索引包含了满足查询结果的数据就叫做覆盖索引。

理解方式二︰非聚簇复合索引的一种形式，它包括在查询里的SELECT、JOIN和WHERE子句用到的所有列(即建索引的字段正好是覆盖查询条件中所涉及的字段)。

举例一：

简单说就是，索引列+主键包含SELECT到FROM之间查询的列。举例一:

```mysql
#删除之前的索引
DROP INDEX idx_age_stuno ON student ;
CREATE INDEX idx_age_name ON student ( age, NAME);
EXPLAIN SELECT *FROM student WHERE age <>20 ;
```

![image-20220303150105018](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%951.png)

```mysql
EXPLAIN SELECT id ,age , NAME FROM student WHERE age <20;
```

![image-20220303150336128](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%952.png)

**举例二:**

```mysql
EXPLAIN SELECT * FROM student WHERE NAME LIKE '%abe';
```

![image-20220303150959295](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%953.png)

```mysql
CREATE INDEX idx_age_name ON student (age , NAME);
EXPLAIN SELECT id , age , NAME FROM student WHERE NAME LIKE ' %abc';
```

![image-20220303151159155](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%954.png)

上述都使用到了声明的索引，下面的情况则不然，查询列依然多了classid，结果是未使用到索引:

```
EXPLAIN SELECT id, age ,NAME ,classid FROM student WHERE NAME LIKE '%abc' ;
```

![image-20220303151310104](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%955.png)

#### 8.2覆盖索引的利弊

**好处:**
1.避免Innodb表进行索引的二次查询(回表)

Innodb是以聚集索引的顺序来存储的，对于Innodb来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据，在查找到相应的键值后，还需通过主键进行二次查询才能获取我们真实所需要的数据。在覆盖索引中，二级索引的键值中可以获取所要的数据，避免了对主键的二次查询，减少了IO操作
，提升了查询效率。

2.可以把随机IO变成顺序IO加快查询效率

由于覆盖索引是按键值的顺序存储的，对于Io密集型的范围查找来说，对比随机从磁盘读取每一行的数据I0要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的IO转变成索引查找的顺序IO。

由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。

**弊端**

索引字段的维护总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。这是业务DBA，或者称为业务数据架构师的工作。

### 9.如何给字符串添加索引(`略`)

### 10.索引下推

#### 10.1 使用前后对比

Index Condition Pushdown(ICP)是MySQL 5.6中新特性，是一种在存储引擎层使用索引过滤数据的优化方式。

- 如果没有ICP，存储引擎会遍历索引以定位基表中的行，并将它们返回给MysQL服务器，由MySQL服务器评估WHERE后面的条件是否保留行。


- 启用ICP后，如果部分WHERE条件可以仅使用索引中的列进行筛选，则MysQL服务器会把这部分WHERE条件放到存储引擎筛选。然后，存储引擎通过使用索引条目来筛选数据，并且只有在满足这一条件时才从表中读取行。
    - 好处:ICP可以减少存储引擎必须访问基表的次数和MySQL服务器必须访问存储引擎的次数。
    - 但是，ICP的加速效果取决于在存储引擎内通过ICP筛选掉的数据的比例。

#### 10.2 ICP的开启/关闭

- 默认情况下启用索引条件下推。可以通过设置系统变量optimizer_switch 控制:index_condition_pushdown

```mysql
#打开索引下推
SET optimizer_switch = 'index_condition_pushdown=on ' ;
#关闭索引下推
SET optimizer_switch = 'index_condition_pushdown=off' ;
```

- 当使用索引条件下推时，EXPLAIN语句输出结果中Extra列内容显示为Using index condition 。

#### 10.3 ICP使用案列

建表

```mysql
CREATE TABLE people (
	id INT NOT NULL AUTO_INCREMENT,
	zipcode VARCHAR ( 20 ) COLLATE utf8_bin DEFAULT NULL,
	firstname VARCHAR ( 20 ) COLLATE utf8_bin DEFAULT NULL,
	lastname VARCHAR ( 20 ) COLLATE utf8_bin DEFAULT NULL,
	address VARCHAR ( 50 ) COLLATE utf8_bin DEFAULT NULL,
	PRIMARY KEY ( id ),
KEY zip_last_first ( zipcode, lastname, firstname ) 
) ENGINE = INNODB AUTO_INCREMENT = 5 DEFAULT CHARSET = utf8mb3 COLLATE = utf8_bin;
```

插入数据

```mysql
INSERT INTO people
VALUES
	( '1 ', '000001', '三', '张', '北京市' ),(
		' 2 ',
		' 000002 ',
		'四',
		'李',
		'南京市' 
		),(
		' 3 ',
		' 000003 ',
		'五',
		'王',
		'上海市' 
		),(
		' 4 ',
		'000001',
		'六',
		'赵',
	'天津市' 
	);
```

为该表定义联合索引zip_last_first (zipcode，lastname，firstname)。如果我们知道了一个人的邮编，但是不确定这个人的姓氏，我们可以进行如下检索:

```mysql
EXPLAIN SELECT * FROM people WHERE zipcode = '080801' AND lastname LIKE '%张%'	AND address LIKE '%北京市%';
```

执行查看sQL的查询计划，Extra中显示了Using index condition，这表示使用了索引下推另外，Usingwhere表示条件中包含需要过滤的非索引列的数据，即address LIKE 19%北京市%'这个条件并不是索引列，需要在服务端过滤掉。

![image-20220303154224712](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A81.png)

如果不想出现Using where，把address LlKE '%北京市%'去掉即可

![image-20220303154338192](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A82.png)

这个表中存在两个索引，分别是:

- 主键索引(简图)

  ![image-20220303154812279](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8_%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%EF%BC%88%E7%AE%80%E5%9B%BE%EF%BC%89.png)

- 二级索引zip_last_first(简图，这里省略了数据页等信息)

  ![image-20220303154909500](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8_%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%EF%BC%88%E7%AE%80%E5%9B%BE%EF%BC%89.png)

下面我们关闭ICP查看执行计划

```mysql
mysql> SET optimizer_switch = 'index_condition_pushdown=off' ;
Query OK, 0 rows affected (0.00 sec)
```

查看执行计划，已经没有了Using index condition，表示没有使用ICP

![image-20220303155157142](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E5%85%B3%E9%97%AD%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8.png)

#### 10.4开启和关闭ICP的性能对比

创建存储过程，主要目的就是插入很多000001的数据，这样查询的时候为了在存储引擎层做过滤,减少IO，也为了减少缓冲池（缓存数据页，没有IO）的作用。

```mysql
DELIMITER //
CREATE PROCEDURE insert_people ( max_num INT ) BEGIN
	DECLARE
		i INT DEFAULT 0;
	
	SET autocommit = 0;
	REPEAT
			
			SET i = i + 1;
		INSERT INTO people ( zipcode, firstname, lastname, address )
		VALUES
			( ' 008001', '六', '赵', '天津市' );
		UNTIL i = max_num 
	END REPEAT;
	COMMIT;

END // 
DELIMITER;
```

调用存储过程

```mysql
call insert_people(1000000);
```

首先打开profiling

```mysql
set profiling=1;
```

执行sQL语句，此时默认打开索引下推。

```mysql
SELECT * FROM people WHERE zipcode='000001' AND lastname LIKE '%张%';
```


再次执行SQL语句，不使用索引下推

```mysql
SELECT * FROM people WHERE zipcode='000001' AND lastname LIKE '%张%';
```

查看当前会话所产生的所有profiles

```mysql
show profiles \G;
```


结果如下。

![image-20220303160426068](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E6%98%AF%E5%90%A6%E5%BC%80%E5%90%AFICP%E5%AF%B9%E6%AF%94.png)

多次测试效率对比来看，使用ICP优化的查询效率会好一些。这里建议多存储一些数据效果更明显。

#### 10.5 ICP的使用条件

1. 如果表访问的类型为range、ref、eq_ref和ref_or_null可以使用ICP
2. ICP可以用于InnoDB和My工SAM表，包括分区表InnoDB和MyISAM表
3. 对于InnoDB表，ICP仅用于二级索引。ICP的目标是减少全行读取次数，从而减少I/O操作。
4. 当SQL使用覆盖索引时，不支持ICP。因为这种情况下使用ICP不会减少I/O。
5. 相关子查询的条件不能使用ICP

### 11.普通索引vs唯一索引(`略`)

### 12.其他查询优化策略

#### 12.1 EXISTS和IN的区分

**问题:**

不太理解哪种情况下应该使用EXISTS，哪种情况应该用IN。选择的标准是看能否使用表的索引吗

**回答:**
索引是个前提，其实选择与否还是要看表的大小。你可以将选择的标准理解为小表驱动大表。在这种方式下效率是最高的。

比如下面这样:

```mysql
SELECT * FROM A WHERE cc IN (SELECT cc FROM B)
SELECT * FROM A WHERE EXISTS ( SELECT cc FROM B WHERE B.cc=A.cc)
```

当A小于B时，用EXISTS。因为EXISTS的实现，相当于外表循环，实现的逻辑类似于:

```mysql
for i in A
	for j in B
		if j.cc == i.cc then ...
```

当B小于A时用IN，因为实现的逻辑类似于:

```mysql
for i in B
	for j in A
		if j.cc == i.cc then ...
```


哪个表小就用哪个表来驱动，A表小就用EXISTS，B表小就用IN。

#### 12.2 COUNT(*)与COUNT(具体字段)效率

**问:**在MySQL中统计数据表的行数，可以使用三种方式: SELECT COHNT(*)、SELECT COUNT(1)和SELECTcOUNT(具体字段)，使用这三者之间的查询效率是怎样的?

**答:**
前提:如果你要统计的是某个字段的非空数据行数，则另当别论，毕竟比较执行效率的前提是结果一样才可以。

`环节1`: COUNT(*)和COUNT(1)都是对所有结果进行COUNT,COUNT( *)和cOUNT(1)本质上并没有区别(二者执行时间可能略有差别，不过你还是可以把它俩的执行效率看成是相等的)。如果有WHERE子句，则是对所有符合筛选条件的数据行进行统计;如果没有WHERE子句，则是对数据表的数据行数进行统计。·

`环节2`:如果是MyISAM存储引擎，统计数据表的行数只需要0(1)的复杂度，这是因为每张MyISAM的数据表都有一个meta信息存储了row_count值，而一致性则由表级锁来保证。

如果是InnoDB存储引擎，因为InnoDB支持事务，采用行级锁和MVCC机制，所以无法像MyISAM一样，维护一个row_count变量，因此需要采用扫描全表，是0(n)的复杂度，进行循环＋计数的方式来完成统计。

`环节3`:在InnoDB引擎中，如果采用COUNT(具体字段)来统计数据行数，要尽量采用二级索引。因为主键采用的索引是聚簇索引，聚簇索引包含的信息多，明显会大于二级索引(非聚簇索引)。对于COUNT(*)和COUNT(1)来说，它们不需要查找具体的行，只是统计行数，系统会自动采用占用空间更小的二级索引来进行统计。

如果有多个二级索引，会使用 key_len 小的二级索引进行扫描。当没有二级索引的时候，才会采用主键索引来进行统计。

#### 12.3关于SELECT(*)

在表查询中，建议明确字段，不要使用作为查询的字段列表，推荐使用SELECT <字段列表>查询。原因:

1. MySQL在解析的过程中，会通过查询数据字典将"*"按序转换成所有列名，这会大大的耗费资源和时间。
2. 无法使用覆盖索引

#### 12.4 LIMIT 1对优化的影响

针对的是会扫描全表的SQL语句，如果你可以确定结果集只有一条，那么加上LIMIT 1的时候，当找到一条结果的时候就不会继续扫描了，这样会加快查询速度。

如果数据表已经对字段建立了唯一索引，那么可以通过索引进行查询，不会全表扫描的话，就不需要加上LIMIT 1了。

#### 12.5多使用COMMIT

只要有可能，在程序中尽量多使用COMMIT，这样程序的性能得到提高，需求也会因为COMMIT所释放的资源而减少。
COMMIT所释放的资源:

- 回滚段上用于恢复数据的信息。
- 被程序语句获得的锁
- redo / undo log buffer中的空间。
- 管理上述3种资源中的内部花费

### 13.淘宝数据库，主键如何设计的?

聊一个实际问题:淘宝的数据库，主键是如何设计的?

某些错的离谱的答案还在网上年复一年的流传着，甚至还成为了所谓的MySQL军规。其中，一个最明显的错误就是关于MySQL的主键设计。

大部分人的回答如此自信:用8字节的BIGINT做主键，而不要用INT。错!

这样的回答，只站在了数据库这一层，而没有从业务的角度思考主键。主键就是一个自增ID吗?站在2022年的新年档口，用自增做主键，架构设计上可能连及格都拿不到。

#### 13.1自增ID的问题

自增ID做主键，简单易懂，几乎所有数据库都支持自增类型，只是实现上各自有所不同而已。自增ID除了简单，其他都是缺点，总体来看存在以下几方面的问题:
**1.可靠性不高**
存在自增ID回溯的问题，这个问题直到最新版本的MySQL 8.0才修复。
**2.安全性不高**
对外暴露的接口可以非常容易猜测对应的信息。比如:/User/1/这样的接口，可以非常容易猜测用户ID的值为多少，总用户数量有多少，也可以非常容易地通过接口进行数据的爬取。
**3.性能差**
自增ID的性能较差，需要在数据库服务器端生成。
**4.交互多**
业务还需要额外执行一次类似last_insert_id()的函数才能知道刚才插入的自增值，这需要多一次的网络交互。在海量并发的系统中，多1条sQL，就多一次性能上的开销。
**5.局部唯一性**
最重要的一点，自增ID是局部唯一，只在当前数据库实例中唯一，而不是全局唯一，在任意服务器间都是唯一的。对于目前分布式系统来说，这简直就是噩梦。

#### 13.2业务字段做主键

为了能够唯一地标识一个会员的信息，需要为会员信息表设置一个主键。那么，怎么为这个表设置主键，才能达到我们理想的目标呢?这里我们考虑业务字段做主键。
表数据如下:

![image-20220303163627591](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E4%B8%9A%E5%8A%A1%E8%A1%A8%E9%80%89%E4%B8%BB%E9%94%AE.png)

在这个表里，哪个字段比较合适呢?

- **选择卡号(cardno)**
  会员卡号(cardno）看起来比较合适，因为会员卡号不能为空，而且有唯一性，可以用来标识一条会员记录。

  ```mysql
  CREATE TABLE membermaster ( 
  	cardno CHAR ( 8 ) PRIMARY KEY, # 会员卡号为主键
  	membername TEXT, 
  	memberphone TEXT, 
  	memberpid TEXT, 
  	memberaddress TEXT, 
  	sex TEXT, 
  	birthday DATETIME );
  ```

  不同的会员卡号对应不同的会员，字段“cardno“唯一地标识某一个会员。如果都是这样，会员卡号与会员一一对应，系统是可以正常运行的。

  但实际情况是，会员卡号可能存在重复使用的情况。比如，张三因为工作变动搬离了原来的地址不再到商家的门店消费了(退还了会员卡)，于是张三就不再是这个商家门店的会员了。但是，商家不想让这个会员卡空着，就把卡号是“10000001”的会员卡发给了王五。

  从系统设计的角度看，这个变化只是修改了会员信息表中的卡号是"“10000001”这个会员信息，并不会影响到数据一致性。也就是说，修改会员卡号是“10000001"的会员信息，系统的各个模块，都会获取到修改后的会员信息，不会出现“有的模块获取到修改之前的会员信息，有的模块获取到修改后的会员信息，而导致系统内部数据不一致”的情况。因此，从信息系统层面上看是没问题的。

  但是从使用系统的业务层面来看，就有很大的问题了，会对商家造成影响。比如，我们有一个销售流水表（trans），记录了所有的销售流水明细。2020 年 12 月 01 日，张三在门店购买了一本书，消费了 89 元。那么，系统中就有了张三买书的流水记录，如下所示：

  ![image-20220303164632348](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E5%8D%A1%E5%8F%B7%E5%81%9A%E4%B8%BB%E9%94%AE%E6%B5%81%E6%B0%B4%E8%A1%A8.png)

接着，我们查询一下 2020 年 12 月 01 日的会员销售记录：

![image-20220303164725367](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E9%94%80%E5%94%AE%E8%AE%B0%E5%BD%951.png)

如果会员卡“10000001”又发给了王五，我们会更改会员信息表。导致查询时：

![image-20220303164748090](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E9%94%80%E5%94%AE%E8%AE%B0%E5%BD%952.png)

这次得到的结果是：王五在 2020 年 12 月 01 日，买了一本书，消费 89 元。显然是错误的！结论：千万不能把会员卡号当做主键。

- **选择会员电话 或 身份证号**

  会员电话可以做主键吗？不行的。在实际操作中，手机号也存在 被运营商收回 ，重新发给别人用的情况。那身份证号行不行呢？好像可以。因为身份证决不会重复，身份证号与一个人存在一一对 应的关系。可问题是，身份证号属于 个人隐私 ，顾客不一定愿意给你。要是强制要求会员必须登记身份证号，会把很多客人赶跑的。其实，客户电话也有这个问题，这也是我们在设计会员信息表的时候，允许身份证号和电话都为空的原因。

  ==所以，建议尽量不要用跟业务有关的字段做主键。毕竟，作为项目设计的技术人员，我们谁也无法预测在项目的整个生命周期中，哪个业务字段会因为项目的业务需求而有重复，或者重用之类的情况出现。==

  > 经验：
  >
  > 刚开始使用 MySQL 时，很多人都很容易犯的错误是喜欢用业务字段做主键，想当然地认为了解业务需求，但实际情况往往出乎意料，而更改主键设置的成本非常高。

#### **13.3** 淘宝的主键设计

在淘宝的电商业务中，订单服务是一个核心业务。请问， 订单表的主键 淘宝是如何设计的呢？是自增ID吗？

打开淘宝，看一下订单信息：

![image-20220303165228996](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E6%B7%98%E5%AE%9D%E8%AE%A2%E5%8D%95%E4%BF%A1%E6%81%AF.png)

从上图可以发现，订单号不是自增ID！我们详细看下上述4个订单号：

```
1550672064762308113 
1481195847180308113 
1431156171142308113 
1431146631521308113
```

订单号是19位的长度，且订单的最后5位都是一样的，都是08113。且订单号的前面14位部分是单调递增的。

大胆猜测，淘宝的订单ID设计应该是：订单ID = 时间 + 去重字段 + 用户ID后6位尾号

这样的设计能做到全局唯一，且对分布式系统查询及其友好。

#### **13.4** **推荐的主键设计**

`非核心业务` ：对应表的主键自增ID，如告警、日志、监控等信息。

`核心业务` ：**主键设计至少应该是全局唯一且是单调递增**。全局唯一保证在各系统之间都是唯一的，单调递增是希望插入时不影响数据库性能。

这里推荐最简单的一种主键设计：UUID。

**1.UUID的特点：**

全局唯一，占用36字节，数据无序，插入性能差。

**2.认识UUID：**

- 为什么UUID是全局唯一的？
- 为什么UUID占用36个字节？
- 为什么UUID是无序的？

MySQL数据库的UUID组成如下所示：

```
UUID = 时间+UUID版本（16字节）- 时钟序列（4字节） - MAC地址（12字节）
```

我们以UUID值e0ea12d4-6473-11eb-943c-00155dbaa39d举例：

![image-20220303165703231](https://gitee.com/kiteflyer/picture/raw/master/MySQL/mysql_uuid.png)

`为什么UUID是全局唯一的？`

在UUID中时间部分占用60位，存储的类似TIMESTAMP的时间戳，但表示的是从1582-10-15 00：00：00.00到现在的100ns的计数。可以看到UUID存储的时间精度比TIMESTAMPE更高，时间维度发生重复的概率降低到1/100ns。时钟序列是为了避免时钟被回拨导致产生时间重复的可能性。MAC地址用于全局唯一。

`为什么UUID占用36个字节？`

UUID根据字符串进行存储，设计时还带有无用"-"字符串，因此总共需要36个字节。

`为什么UUID是随机无序的呢？`

因为UUID的设计中，将时间低位放在最前面，而这部分的数据是一直在变化的，并且是无序。

**3.改造UUID**

若将时间高低位互换，则时间就是单调递增的了，也就变得单调递增了。MySQL 8.0可以更换时间低位和时间高位的存储方式，这样UUID就是有序的UUID了。MySQL 8.0还解决了UUID存在的空间占用的问题，除去了UUID字符串中无意义的"-"字符串，并且将字符串用二进制类型保存，这样存储空间降低为了16字节。可以通过MySQL8.0提供的uuid_to_bin函数实现上述功能，同样的，MySQL也提供了bin_to_uuid函数进行转化：

```mysql
SET @uuid = UUID(); 
SELECT @uuid,uuid_to_bin(@uuid),uuid_to_bin(@uuid,TRUE);
```

![image-20220303170202988](https://gitee.com/kiteflyer/picture/raw/master/MySQL/%E6%9F%A5%E8%AF%A2uuid.png)

**通过函数uuid_to_bin(@uuid,true)将UUID转化为有序UUID了**。全局唯一 + 单调递增，这不就是我们想要的主键！

**4.有序UUID性能测试**

16字节的有序UUID，相比之前8字节的自增ID，性能和存储空间对比究竟如何呢？

我们来做一个测试，插入1亿条数据，每条数据占用500字节，含有3个二级索引，最终的结果如下所示：

![image-20220303170459470](https://gitee.com/kiteflyer/picture/raw/master/MySQL/uuid%E5%81%9A%E4%B8%BB%E9%94%AE%E5%AF%B9%E6%AF%94.png)

从上图可以看到插入1亿条数据有序UUID是最快的，而且在实际业务使用中有序UUID在 业务端就可以生成 。还可以进一步减少SQL的交互次数。另外，虽然有序UUID相比自增ID多了8个字节，但实际只增大了3G的存储空间，还可以接受。

> 在当今的互联网环境中，非常不推荐自增ID作为主键的数据库设计。更推荐类似有序UUID的全局唯一的实现。
>
> 另外在真实的业务系统中，主键还可以加入业务和系统属性，如用户的尾号，机房的信息等。这样的主键设计就更为考验架构师的水平了。

**如果不是MySQL8.0肿么办？**

手动赋值字段做主键！

比如，设计各个分店的会员表的主键，因为如果每台机器各自产生的数据需要合并，就可能会出现主键重复的问题。

可以在总部 MySQL 数据库中，有一个管理信息表，在这个表中添加一个字段，专门用来记录当前会员编号的最大值。

门店在添加会员的时候，先到总部 MySQL 数据库中获取这个最大值，在这个基础上加 1，然后用这个值作为新会员的“id”，同时，更新总部 MySQL 数据库管理信息表中的当 前会员编号的最大值。

这样一来，各个门店添加会员的时候，都对同一个总部 MySQL 数据库中的数据表字段进 行操作，就解决了各门店添加会员时会员编号冲突的问题。
