---
title: Bitmap HyperLogLog Geo
date: 2024-08-05 15:18:30
permalink: /pages/173feb/
---
# Bitmap/HyperLogLog/Geo

亿级系统中，常见的四种统计

- 聚合统计

  统计多个集合元素的聚合结果

  <img src="https://gitee.com/kiteflyer/picture/raw/master/Redis/image-20230406101132344.png" alt="image-20230406101132344" style="zoom:67%;" />

  交并差集和聚合函数的应用

- 排序统计

  抖音短视频最新评论留言的场景，请你设计一个展现列表。考察你的数据结构和设计思路

  设计案例和回答思路

  **以抖音vcr最新的留言评价为案例，所有评论需要两个功能，按照时间排序(正序、反序)+分页显示**

   **能够排序+分页显示的redis数据结构是什么合适？**

  <img src="https://gitee.com/kiteflyer/picture/raw/master/Redis/image-20230406101328029.png" alt="image-20230406101328029" style="zoom:50%;" />

  在⾯对需要展示最新列表、排行榜等场景时，如果数据更新频繁或者需要分页显示，建议使⽤ZSet

- 二值统计

  集合元素的取值就只有0和1两种。在钉钉上班签到打卡的场景中，我们只用记录有签到(1)或没签到(0)

  见Bitmap

- 基数统计

  指统计⼀个集合中不重复的元素个数

  见hyperloglog

## Bitmap

### 介绍

**是什么**

由0和1状态表现的二进制位的bit数组

![image-20230406102502239](https://gitee.com/kiteflyer/picture/raw/master/Redis/image-20230406102502239.png)

说明：**用String类型作为底层数据结构实现的一种统计二值状态的数据类型**

**位图本质是数组**，它是基于String数据类型的按位的操作。该数组由多个二进制位组成，每个二进制位都对应一个偏移量(我们称之为一个索引)。

Bitmap支持的最大位数是2^32位，它可以极大的节约存储空间，使用512M内存就可以存储多达42.9亿的字节信息(2^32 = 4294967296)

**能干嘛**

用于状态统计，Y、N，类似AtomicBoolean

### 基本命令

| 命令                                      | 作用                                                      | 时间复杂度 |
| ----------------------------------------- | --------------------------------------------------------- | ---------- |
| setbit key offset val                     | 给指定key的值的第offset赋值val                            | O(1)       |
| getbit key offset                         | 获取指定key的第offset位                                   | O(1)       |
| bitcount key start end                    | 返回指定key中[start,end]中为去的数量                      | O(n)       |
| bitop operation destkey key               | 对不同的二进制存储数据进行位运算(AND、OR、NOT、XOR)       | O(n)       |
| strlen key                                | 占据多少个字节                                            |            |
| bitfield key u2(u:查询,2两个原始) 0(下标) | 操作(查询,修改,自增)BitMap中bit数组中的指定位置offset的值 |            |
| bitpos                                    | 查找bit数组中指定范围内第一个0或者1出现的位置             |            |

- setbit

  setbit key offset value

  <img src="https://gitee.com/kiteflyer/picture/raw/master/Redis/image-20230406103219019.png" alt="image-20230406103219019" style="zoom:67%;" />

  首先我先setbit k1 1 1
  那么保存到redis后的数据就是下边这个样子

  <img src="https://gitee.com/kiteflyer/picture/raw/master/Redis/image-20230406103241832.png" alt="image-20230406103241832" style="zoom:67%;" />

  setbit 键  偏移位 只能零或者1

  Bitmap的偏移量是从零开始算的

- getbit

  getbit key offset

- strlen

  统计字节数占用多少

  <img src="https://gitee.com/kiteflyer/picture/raw/master/Redis/image-20230406103347201.png" alt="image-20230406103347201" style="zoom:67%;" />

  不是字符串长度而是占据几个字节，超过8位后自己按照8位一组一byte再扩容

- bitcount

  全部键里面含有1的有多少个？

  <img src="https://gitee.com/kiteflyer/picture/raw/master/Redis/image-20230406103509288.png" alt="image-20230406103509288" style="zoom:67%;" />

- bitop

  连续2天都签到的用户

  加入某个网站或者系统，它的用户有1000W，做个用户id和位置的映射

  比如0号位对应用户id：uid-092iok-lkj

  比如1号位对应用户id：uid-7388c-xxx

  <img src="https://gitee.com/kiteflyer/picture/raw/master/Redis/image-20230406103556507.png" alt="image-20230406103556507" style="zoom:67%;" />

- setbit和getbit案例说明

  按照天

  <img src="https://gitee.com/kiteflyer/picture/raw/master/Redis/image-20230406103635455.png" alt="image-20230406103635455" style="zoom:67%;" />

bitmap的底层编码说明，get命令操作如何

实质是二进制的ascii编码对应

redis里用type命令看看bitmap实质是什么类型？？？String类型

man ascii

![image-20230406104325903](https://gitee.com/kiteflyer/picture/raw/master/Redis/image-20230406104325903.png)

设置命令

![image-20230406104419495](https://gitee.com/kiteflyer/picture/raw/master/Redis/image-20230406104419495.png)

两个setbit命令对k1进行设置后，对应的二进制串就是0100 0001

二进制串就是0100 0001对应的10进制就是65，所以见下图：

![image-20230406104526802](https://gitee.com/kiteflyer/picture/raw/master/Redis/image-20230406104526802.png)

### 应用场景

- 一年365天，全年天天登陆占用多少字节

  <img src="https://gitee.com/kiteflyer/picture/raw/master/Redis/image-20230406103820657.png" alt="image-20230406103820657" style="zoom:67%;" />

- 按照年

  按年去存储一个用户的签到情况，365 天只需要 365 / 8 ≈ 46 Byte，1000W 用户量一年也只需要 44 MB 就足够了。

  假如是亿级的系统，

  每天使用1个1亿位的Bitmap约占12MB的内存（10^8/8/1024/1024），10天的Bitmap的内存开销约为120MB，内存压力不算太高。

  此外，在实际使用时，最好对Bitmap设置过期时间，让Redis自动删除不再需要的签到记录以节省内存开销。

### 京东签到领取京豆

签到日历仅展示当月签到数据

签到日历需展示最近连续签到天数

假设当前日期是20210618，且20210616未签到

若20210617已签到且0618未签到，则连续签到天数为1

若20210617已签到且0618已签到，则连续签到天数为2

连续签到天数越多，奖励越大

所有用户均可签到

截至2020年3月31日的12个月，京东年度活跃用户数3.87亿，同比增长24.8%，环比增长超2500万，此外，2020年3月移动端日均活跃用户数同比增长46%假设10%左右的用户参与签到，签到用户也高达3千万。。。。。。o(╥﹏╥)o

- 传统MySQL方式

  表sql

  ```mysql
  CREATE TABLE user_sign
  (
    keyid BIGINT NOT NULL PRIMARY KEY AUTO_INCREMENT,
    user_key VARCHAR(200),#京东用户ID
    sign_date DATETIME,#签到日期(20210618)
    sign_count INT #连续签到天数
  )
   
  INSERT INTO user_sign(user_key,sign_date,sign_count)
  VALUES ('20210618-xxxx-xxxx-xxxx-xxxxxxxxxxxx','2020-06-18 15:11:12',1);
   
  SELECT
      sign_count
  FROM
      user_sign
  WHERE
      user_key = '20210618-xxxx-xxxx-xxxx-xxxxxxxxxxxx'
      AND sign_date BETWEEN '2020-06-17 00:00:00' AND '2020-06-18 23:59:59'
  ORDER BY
      sign_date DESC
      LIMIT 1;
  ```

  困难和解决思路

  方法正确但是难以落地实现，o(╥﹏╥)o。 

  签到用户量较小时这么设计能行，但京东这个体量的用户（估算3000W签到用户，一天一条数据，一个月就是9亿数据）

  对于京东这样的体量，如果一条签到记录对应着当日用记录，那会很恐怖......

  如何解决这个痛点？

  1. 一条签到记录对应一条记录，会占据越来越大的空间。
  2. 一个月最多31天，刚好我们的int类型是32位，那这样一个int类型就可以搞定一个月，32位大于31天，当天来了位是1没来就是0。
  3. 一条数据直接存储一个月的签到记录，不再是存储一天的签到记录。

- Redis中Bitmap方式

  在签到统计时，每个用户一天的签到用1个bit位就能表示，

  一个月（假设是31天）的签到情况用31个bit位就可以，一年的签到也只需要用365个bit位，根本不用太复杂的集合类型

## HyperLogLog

### 介绍

**是什么**

去重复统计功能的基数估计算法

![image-20230406110029825](https://gitee.com/kiteflyer/picture/raw/master/Redis/image-20230406110029825.png)

> 基数：是一种数据集，去除重复后的真实个数
>
> 基数统计：用于统计一个集合中不重复的元素个数，就是对集合去重复后剩余元素的计算

![image-20230406110105344](https://gitee.com/kiteflyer/picture/raw/master/Redis/image-20230406110105344.png)

### 基本命令

| 命令                      | 作用                    |
| ------------------------- | ----------------------- |
| pfadd key element         | 将所有元素添加到key中   |
| pfcount key               | 统计key的估算值(不准确) |
| pgmerge new_key key1 key2 | 合并key至新key          |

![image-20230406110255842](https://gitee.com/kiteflyer/picture/raw/master/Redis/image-20230406110255842.png)

### 一些行话

- UV

  Unique Visitor，独立访客，一般理解为客户端IP

  需要考虑去重

- PV

  Page View，页面浏览量

  不用去重

- DAU

  Daily Active User 日活跃用户量

  登录或者使用了某个产品的用户数(去重复登录的用户)

  常用于反映网站、互联网应用或者网络游戏的运营情况

- MAU

  MonthIy Active User 月活跃用户量

很多计数类场景，比如 每日注册 IP 数、每日访问 IP 数、页面实时访问数 PV、访问用户数 UV等。

因为主要的目标高效、巨量地进行计数，所以对存储的数据的内容并不太关心。

也就是说它只能用于统计巨量数量，不太涉及具体的统计对象的内容和精准性。

统计单日一个页面的访问量(PV)，单次访问就算一次。

统计单日一个页面的用户访问量(UV)，即按照用户为维度计算，单个用户一天内多次访问也只算一次。

多个key的合并统计，某个门户网站的所有模块的PV聚合统计就是整个网站的总PV。

### HyperLogLog是如何做的？

去重统计你会想到什么方法？

- HashSet

- Bitmap

  如果数据显较大亿级统计,使用bitmaps同样会有这个问题。

  bitmap是通过用位bit数组来表示各元素是否出现，每个元素对应一位，所需的总内存为N个bit。

  基数计数则将每一个元素对应到bit数组中的其中一位，比如bit数组010010101(按照从零开始下标，有的就是1、4、6、8)。

  新进入的元素只需要将已经有的bit数组和新加入的元素进行按位或计算就行。这个方式能大大减少内存占用且位操作迅速。

  But，假设一个样本案例就是一亿个基数位值数据，一个样本就是一亿

  如果要统计1亿个数据的基数位值,大约需要内存100000000/8/1024/1024约等于12M,内存减少占用的效果显著。

  这样得到统计一个对象样本的基数值需要12M。

  如果统计10000个对象样本(1w个亿级),就需要117.1875G将近120G，可见使用bitmaps还是不适用大数据量下(亿级)的基数计数场景，

  但是bitmaps方法是精确计算的。

量变引起质变：样本元素越多内存消耗急剧增大，难以管控+各种慢，对于亿级统计不太合适。

> 概率算法
>
> **通过牺牲准确率来换取空间**，对于不要求`绝对准确率`的场景下可以使用，因为**概率算法不直接存储数据本身**，
>
> 通过一定的概率统计方法预估基数值，同时保证误差在一定范围内，由于又不储存数据故此可以大大节约内存。
>
> HyperLogLog就是一种概率算法的实现。

**原理说明**

只是进行不重复的基数统计，不是集合也不保存数据，只记录数量而不是具体内容。

Hyperloglog提供不精确的去重计数方案，有误差。牺牲准确率来换取空间，误差仅仅只是**0.81%**左右

误差论文地址：http://antirez.com/news/75

<img src="https://gitee.com/kiteflyer/picture/raw/master/Redis/image-20230406132649847.png" alt="image-20230406132649847" style="zoom:50%;" />

<img src="https://gitee.com/kiteflyer/picture/raw/master/Redis/image-20230406132705014.png" alt="image-20230406132705014" style="zoom:50%;" />

### 网站首页亿级UV的Redis统计

为什么不用hash结构存储？ \- redis——hash = <keyDay,<ip,1>>

按照ipv4的结构来说明，每个ipv4的地址最多是15个字节(ip = "192.168.111.1"，最多xxx.xxx.xxx.xxx)

某一天的1.5亿 * 15个字节= 2G，一个月60G，redis死定了。o(╥﹏╥)o

![image-20230406133050292](https://gitee.com/kiteflyer/picture/raw/master/Redis/image-20230406133050292.png)

为什么只需要花费12kb？

![image-20230406133116384](https://gitee.com/kiteflyer/picture/raw/master/Redis/image-20230406133116384.png)

![image-20230406133128362](https://gitee.com/kiteflyer/picture/raw/master/Redis/image-20230406133128362.png)

> 因为一个byte（字节）占用8个比特（bit），而Redis中使用的单位是字节（byte），因此需要将比特转换为字节。所以，如果一个HLL数据结构有16384个桶，每个桶用6个比特表示，总共需要使用的比特数为16384*6=98304bit。将98304bit转换成字节，需要除以8，即98304/8=12288byte，约等于12KB。

HyperLogLogService

```java
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;

import javax.annotation.PostConstruct;
import javax.annotation.Resource;
import java.util.Random;
import java.util.concurrent.TimeUnit;

@Service
@Slf4j
public class HyperLogLogService
{
    @Resource
    private RedisTemplate redisTemplate;

    /**
     * 模拟后台有用户点击首页，每个用户来自不同ip地址
     */
    @PostConstruct
    public void init()
    {
        log.info("------模拟后台有用户点击首页，每个用户来自不同ip地址");
        new Thread(() -> {
            String ip = null;
            for (int i = 1; i <=200; i++) {
                Random r = new Random();
                ip = r.nextInt(256) + "." + r.nextInt(256) + "." + r.nextInt(256) + "." + r.nextInt(256);

                Long hll = redisTemplate.opsForHyperLogLog().add("hll", ip);
                log.info("ip={},该ip地址访问首页的次数={}",ip,hll);
                //暂停几秒钟线程
                try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); }
            }
        },"t1").start();
    }

}
```

HyperLogLogController

```java
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;
import javax.annotation.Resource;

@Api(description = "淘宝亿级UV的Redis统计方案")
@RestController
@Slf4j
public class HyperLogLogController
{
    @Resource
    private RedisTemplate redisTemplate;

    @ApiOperation("获得IP去重后的首页访问量")
    @RequestMapping(value = "/uv",method = RequestMethod.GET)
    public long uv()
    {
        //pfcount
        return redisTemplate.opsForHyperLogLog().size("hll");
    }

}
```

## Geo

### 介绍

**简介**

移动互联网时代LBS应用越来越多，交友软件中附近的小姐姐、外卖软件中附近的美食店铺、高德地图附近的核酸检查点等等，那这种附近各种形形色色的XXX地址位置选择是如何实现的？

地球上的地理位置是使用二维的经纬度表示，经度范围 (-180, 180]，纬度范围 (-90, 90]，只要我们确定一个点的经纬度就可以名取得他在地球的位置。

例如滴滴打车，最直观的操作就是实时记录更新各个车的位置，

然后当我们要找车时，在数据库中查找距离我们(坐标x0,y0)附近r公里范围内部的车辆

使用如下SQL即可：

```mysql
select taxi from position where x0-r < x < x0 + r and y0-r < y < y0+r
```

但是这样会有什么问题呢？

1. 查询性能问题，如果并发高，数据量大这种查询是要搞垮数据库的
2. 这个查询的是一个矩形访问，而不是以我为中心r公里为半径的圆形访问。
3. 精准度的问题，我们知道地球不是平面坐标系，而是一个圆球，这种矩形计算在长距离计算时会有很大误差

核心思想就是将球体转换为平面，区块转换为一点

<img src="https://gitee.com/kiteflyer/picture/raw/master/Redis/image-20230406140135758.png" alt="image-20230406140135758" style="zoom:50%;" />

主要分为三步

1. 将三维的地球变为二维的坐标
2. 在将二维的坐标转换为一维的点块
3. 最后将一维的点块转换为二进制再通过base32编码

地理知识：https://baike.baidu.com/item/%E7%BB%8F%E7%BA%AC%E7%BA%BF/5596978?fr=aladdin

如何获得某个地址的经纬度：http://api.map.baidu.com/lbsapi/getpoint/

Redis在3.2版本以后增加了地理位置的处理

### 常用命令

#### 添加元素 - GEOADD

1. 添加:GEOADD key [NX|XX] [CH] longitude latitude member [longitude latitude member …]

2. 该命令的参数格式是固定的,即(longitude latitude member),经度要在纬度之前

3. GEOADD 坐标是有限的: 非常接近两极的区域是无法被索引的。坐标被 EPSG:900913 / EPSG:3785 / OSGEO:41001规范限制, 合法值如下:

   有效的经度介于-180度至180度之间

   有效的纬度介于-85.05112878度至85.05112878度之间

   ```bash
   # 当给定的经纬度超出上述合法范围时,会返回error
   127.0.0.1:6379> geoadd city 89.0 99 nanji
   (error) ERR invalid longitude,latitude pair 89.000000,99.000000
   ```

4. Redis GEO没有删除命令 GEODEL,因为底层使用的是Sorted Set,所以完全可以使用ZREM 命令删除

   ```bash
   127.0.0.1:6379> geoadd city 116.41667 39.91667 beijing  121.43333 34.50000 shanghai 117.20000 39.13333 tianjin
   (integer) 3
   ```

#### 返回经纬度 - GEOPOS

1. 命令格式:GEOPOS key member [member …]

2. 返回给定元素对应的经纬度

3. 使用GEOADD添加的元素,会被GeoHash转化为52位比特值,因此使用GEOPOS取出值并转为经纬度时,可能与添加的经纬度值有少许差异

4. 命令接收多个可变参数,返回值始终是数组形式
   数组:存在的元素返回经纬度,不存在的元素返回nil

   ```bash
   127.0.0.1:6379> geoadd city 116.41667 39.91667 beijing  121.43333 34.50000 shanghai 117.20000 39.13333 tianjin
   (integer) 3
   
   127.0.0.1:6379> geopos city beijing nanjing
   1) 1) "116.41667157411575317"
      2) "39.91667095273589183"
   2) (nil)
   ```

#### 返回距离 - GEODIST

1. 命令格式:GEODIST key member1 member2 [m|km|ft|mi]

2. 返回两个给定元素之间的距离

3. 距离度量支持如下参数

   - m: 米(默认值)
   - km: 千米
   - ft: 英尺
   - mi:英里

4. 在计算距离时会假设地球为完美的球形,在极限情况下最大会造成 0.5%的误差

5. 如果给定的元素中,有元素不存在,返回nil

   ```bash
   127.0.0.1:6379> geoadd city 116.41667 39.91667 beijing  121.43333 34.50000 shanghai 117.20000 39.13333 tianjin
   (integer) 3
   
   127.0.0.1:6379> geodist city beijing shanghai
   "748346.9287"
   127.0.0.1:6379> geodist city beijing shanghai km
   "748.3469"
   ```

#### 返回哈希 - GEOHASH

1. 命令格式:GEOHASH key member [member …]
2. 返回给定元素,GeoHash编码值对应的字符串表示

```bash
127.0.0.1:6379> geohash city beijing 
1) "wx4g14s53n0"
```

#### 半径 - GEORADIUS

1. georadius:以给定的经纬度为中心, 返回键包含的位置元素当中, 与中心的距离不超过给定最大距离的所有位置元素

2. 命令:GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count [ANY]] [ASC|DESC] [STORE key] [STOREDIST key]

   - WITHDIST: 在返回位置元素的同时,将位置元素与中心之间的距离也一并返回。距离的单位和用户给定的范围单位保持一致
   - WITHCOORD: 将位置元素的经度和维度也一并返回
   - WITHHASH: 以52位有符号整数的形式,返回位置元素经过原始geohash编码的有序集合分值这个选项主要用于底层应用或者调试,实际中的作用并不大
   - COUNT限定返回的记录数

   ```bash
   GEORADIUS city 116.418017 39.914402 10 km withdist withcoord count 10 withhash desc
   127.0.0.1:6379> GEORADIUS city 116.418017 39.914402 10 km withdist withcoord count 10 withhash desc
   1) 1) "beijing"
      2) "0.2772"
      3) (integer) 4069885649163649
      4) 1) "116.41667157411575317"
         2) "39.91667095273589183"
   ```

3. 简单来说就是查询指定位置一定距离内的元素,例如查询当前位置5公里内的银行

#### GEORADIUSBYMEMBER

1. 命令格式:GEORADIUSBYMEMBER key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count [ANY]] [ASC|DESC] [STORE key] [STOREDIST key]

2. 该命令与GEORADIUS命令基本一样,唯一不同的是:GEORADIUSBYMEMBER给定的是Sorted Set中的一个元素,而GEORADIUS给定的是具体经纬度。通过给定元素,其实就可以得到存储的经纬度,进而进行查询

   ```java
   127.0.0.1:6379> geoadd city 116.408 39.904 beijing 116.298 39.959 haidian 116.443 39.922 chaoyang 121.445 31.213 shanghai 121.23 31.07 minhang 117.246 39.117 tianjin
   (integer) 6
   
   127.0.0.1:6379> GEORADIUSBYMEMBER city beijing 500 km withdist asc
   1) 1) "beijing"
      2) "0.0000"
   2) 1) "chaoyang"
      2) "3.5948"
   3) 1) "haidian"
      2) "11.2004"
   4) 1) "tianjin"
      2) "113.2837"
   ```

### 地图位置附近的酒店推送

实现起来会有什么问题呢？

1. 查询性能问题，如果并发高，数据量大这种查询是要搞垮mysql数据库的
2. 一般mysql查询的是一个平面矩形访问，而叫车服务要以我为中心N公里为半径的圆形覆盖。
3. 精准度的问题，我们知道地球不是平面坐标系，而是一个圆球，这种矩形计算在长距离计算时会有很大误差，mysql不合适

> 地理知识说明
>
> 经纬度
>
> 经度与纬度的合称组成一个坐标系统。又称为地理坐标系统，它是一种利用三度空间的球面来定义地球上的空间的球面坐标系统，能够标示地球上的任何一个位置。
>
> 经线和纬线
>
> 是人们为了在地球上确定位置和方向的，在地球仪和地图上画出来的，地面上并线。
>
> 和经线相垂直的线叫做纬线(纬线指示东西方向)。纬线是一条条长度不等的圆圈。最长的纬线就是赤道。 
>
> 因为经线指示南北方向，所以经线又叫子午线。 国际上规定，把通过英国格林尼治天文台原址的经线叫做0°所以经线也叫本初子午线。在地球上经线指示南北方向，纬线指示东西方向。
>
> 东西半球分界线：东经160° 西经20°
>
> 
>
> 经度和纬度
>
> 经度(longitude)：东经为正数，西经为负数。东西经
>
> 纬度(latitude)：北纬为正数，南纬为负数。南北纬

关键点：以给定的经纬度为中心，找出某一半径内的元素

GeoController

```java
import com.atguigu.redis7.service.GeoService;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.geo.*;
import org.springframework.data.redis.connection.RedisGeoCommands;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;
import javax.annotation.Resource;
import java.util.HashMap;
import java.util.List;
import java.util.Map;


@Api(tags = "美团地图位置附近的酒店推送GEO")
@RestController
@Slf4j
public class GeoController
{
    @Resource
    private GeoService geoService;

    @ApiOperation("添加坐标geoadd")
    @RequestMapping(value = "/geoadd",method = RequestMethod.GET)
    public String geoAdd()
    {
        return geoService.geoAdd();
    }

    @ApiOperation("获取经纬度坐标geopos")
    @RequestMapping(value = "/geopos",method = RequestMethod.GET)
    public Point position(String member)
    {
        return geoService.position(member);
    }

    @ApiOperation("获取经纬度生成的base32编码值geohash")
    @RequestMapping(value = "/geohash",method = RequestMethod.GET)
    public String hash(String member)
    {
        return geoService.hash(member);
    }

    @ApiOperation("获取两个给定位置之间的距离")
    @RequestMapping(value = "/geodist",method = RequestMethod.GET)
    public Distance distance(String member1, String member2)
    {
        return geoService.distance(member1,member2);
    }

    @ApiOperation("通过经度纬度查找北京王府井附近的")
    @RequestMapping(value = "/georadius",method = RequestMethod.GET)
    public GeoResults radiusByxy()
    {
        return geoService.radiusByxy();
    }

    @ApiOperation("通过地方查找附近,本例写死天安门作为地址")
    @RequestMapping(value = "/georadiusByMember",method = RequestMethod.GET)
    public GeoResults radiusByMember()
    {
        return geoService.radiusByMember();
    }

}
```

GeoService

```java
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.geo.Distance;
import org.springframework.data.geo.GeoResults;
import org.springframework.data.geo.Metrics;
import org.springframework.data.geo.Point;
import org.springframework.data.geo.Circle;
import org.springframework.data.redis.connection.RedisGeoCommands;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import java.util.HashMap;
import java.util.List;
import java.util.Map;


@Service
@Slf4j
public class GeoService
{
    public static final String CITY ="city";

    @Autowired
    private RedisTemplate redisTemplate;

    public String geoAdd()
    {
        Map<String, Point> map= new HashMap<>();
        map.put("天安门",new Point(116.403963,39.915119));
        map.put("故宫",new Point(116.403414 ,39.924091));
        map.put("长城" ,new Point(116.024067,40.362639));

        redisTemplate.opsForGeo().add(CITY,map);

        return map.toString();
    }

    public Point position(String member) {
        //获取经纬度坐标
        List<Point> list= this.redisTemplate.opsForGeo().position(CITY,member);
        return list.get(0);
    }


    public String hash(String member) {
        //geohash算法生成的base32编码值
        List<String> list= this.redisTemplate.opsForGeo().hash(CITY,member);
        return list.get(0);
    }


    public Distance distance(String member1, String member2) {
        //获取两个给定位置之间的距离
        Distance distance= this.redisTemplate.opsForGeo().distance(CITY,member1,member2, RedisGeoCommands.DistanceUnit.KILOMETERS);
        return distance;
    }

    public GeoResults radiusByxy() {
        //通过经度，纬度查找附近的,北京王府井位置116.418017,39.914402
        Circle circle = new Circle(116.418017, 39.914402, Metrics.KILOMETERS.getMultiplier());
        //返回50条
        RedisGeoCommands.GeoRadiusCommandArgs args = RedisGeoCommands.GeoRadiusCommandArgs.newGeoRadiusArgs().includeDistance().includeCoordinates().sortAscending().limit(50);
        GeoResults<RedisGeoCommands.GeoLocation<String>> geoResults= this.redisTemplate.opsForGeo().radius(CITY,circle, args);
        return geoResults;
    }

    public GeoResults radiusByMember() {
        //通过地方查找附近
        String member="天安门";
        //返回50条
        RedisGeoCommands.GeoRadiusCommandArgs args = RedisGeoCommands.GeoRadiusCommandArgs.newGeoRadiusArgs().includeDistance().includeCoordinates().sortAscending().limit(50);
        //半径10公里内
        Distance distance=new Distance(10, Metrics.KILOMETERS);
        GeoResults<RedisGeoCommands.GeoLocation<String>> geoResults= this.redisTemplate.opsForGeo().radius(CITY,member, distance,args);
        return geoResults;
    }
}

```



