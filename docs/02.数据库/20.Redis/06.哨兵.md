---
title: 哨兵
date: 2024-08-05 15:18:30
permalink: /pages/87db71/
categories: 
  - 《Redis》笔记
tags: 
  - 
author: 
  name: xugaoyi
  link: https://github.com/xugaoyi
---
# 哨兵

官网：https://redis.io/docs/manual/sentinel/

## 介绍

吹哨人巡查监控后台master主机是否故障，如果故障了根据`投票数`自动将某一个从库转换为新主库，继续对外服务

哨兵的作用：(俗称，无人值守运维)

1. 监控redis运行状态，包括master和slave
2. 当master down机，能自动将slave切换成新master

![image-20230325141153099](https://gitee.com/kiteflyer/picture/raw/master/Redis/image-20230325141153099.png)

**能干嘛**

![image-20230325141242901](https://gitee.com/kiteflyer/picture/raw/master/Redis/image-20230325141242901.png)

- 主从监控

  监控主从redis库运行是否正常

- 消息通知

  哨兵可以将故障转移的结果发送给客户端

- 故障转移

  如果Master异常，则会进行主从切换，将其中一个Slave作为新Master

- 配置中心

  客户端通过连接哨兵来获得当前Redis服务的主节点地址

## 案例演示

![image-20230327094455555](https://gitee.com/kiteflyer/picture/raw/master/Redis/image-20230327094455555.png)

- 3个哨兵

  自动监控和维护集群，不存放数据，只是吹哨人

- 1主2从

  用于数据读取和存放

### sentinel.conf参数

| 参数                                                         | 说明                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| bind                                                         | 服务监听地址，用于客户端连接，默认本机地址                   |
| daemonize                                                    | 是否以后台daemon方式运行                                     |
| protected-mode                                               | 安全保护模式                                                 |
| port                                                         | 端口                                                         |
| logfile                                                      | 日志文件路径                                                 |
| pidfile                                                      | pid文件路径                                                  |
| dir                                                          | 工作目录                                                     |
| **sentinel monitor `<master-name> <ip> <redis-port> <quorum>`** | 设置要监控的master服务器，quorum表示票数                     |
| **sentinel auth-pass `<master-name> <password>`**            | master设置了密码，连接master服务的密码                       |
| sentinel down-after-milliseconds `<master-name> <milliseconds>` | 指定多少毫秒之后，主节点没有应答哨兵，此时哨兵主观上认为主节点下线 |
| sentinel parallel-syncs `<master-name> <nums>`               | 表示允许并行同步的slave个数，当Master挂了后，哨兵会选出新的Master，此时，剩余的slave会向新的master发起同步数据 |
| sentinel failover-timeout `<master-name> <milliseconds>`     | 故障转移的超时时间，进行故障转移时，如果超过设置的毫秒，表示故障转移失败 |
| sentinel notification-script `<master-name> <script-path>` ： | 配置当某一事件发生时所需要执行的脚本                         |
| sentinel client-reconfig-script `<master-name> <script-path>` | 客户端重新配置主节点参数脚本                                 |

### 步骤

1. /myredis目录下新建或者拷贝sentinel.conf文件

2. 由于机器硬件关系，我们的3个哨兵都同时配置进192.168.111.169同一台机器

   - sentinel26379.conf

     ```
     bind 0.0.0.0
     daemonize yes
     protected-mode no
     port 26379
     logfile "/myredis/sentinel26379.log"
     pidfile /var/run/redis-sentinel26379.pid
     dir /myredis
     sentinel monitor mymaster 192.168.111.169 6379 2
     sentinel auth-pass mymaster 111111
     ```

   - sentinel26380.conf

     ```
     bind 0.0.0.0
     daemonize yes
     protected-mode no
     port 26380
     logfile "/myredis/sentinel26380.log"
     pidfile /var/run/redis-sentinel26380.pid
     dir "/myredis"
     sentinel monitor mymaster 192.168.111.169 6379 2
     sentinel auth-pass mymaster 111111
     ```

   - sentinel26381.conf

     ```
     bind 0.0.0.0
     daemonize yes
     protected-mode no
     port 26381
     logfile "/myredis/sentinel26381.log"
     pidfile /var/run/redis-sentinel26381.pid
     dir "/myredis"
     sentinel monitor mymaster 192.168.111.169 6379 2
     sentinel auth-pass mymaster 111111
     ```

3. 启动一主二从三台实例

   > 注意：
   >
   > 6379后续可能会变成从机，需要设置访问新主机的密码， 请设置masterauth项访问密码为111111，不然后续可能报错master_link_status:down

   ![image-20230327101035397](https://gitee.com/kiteflyer/picture/raw/master/Redis/image-20230327101035397.png)

4. 启动三个哨兵，完成监控

   ```
   redis-sentinel sentinel26379.conf --sentinel
   redis-sentinel sentinel26380.conf --sentinel
   redis-sentinel sentinel26381.conf --sentinel
   ```

5. 测试一次主从复制看是否正常

### 模拟master挂了

kill掉6379主机后，两台从机数据依旧OK，但是在kill掉之后，Redis有短暂时间不能提供服务

![image-20230327101917778](https://gitee.com/kiteflyer/picture/raw/master/Redis/image-20230327101917778.png)

![image-20230327101928298](https://gitee.com/kiteflyer/picture/raw/master/Redis/image-20230327101928298.png)

- 6380

  <img src="https://gitee.com/kiteflyer/picture/raw/master/Redis/image-20230327102023069.png" alt="image-20230327102023069" style="zoom:67%;" />

- 6381

  <img src="https://gitee.com/kiteflyer/picture/raw/master/Redis/image-20230327102039006.png" alt="image-20230327102039006" style="zoom:67%;" />

**了解 Broken Pipe**

| 认识broken pipe  | pipe是管道的意思，管道里面是数据流，通常是从文件或网络套接字读取的数据。当该管道从另一端突然关闭时，会发生数据突然中断，即是broken，对于socket来说，可能是网络被拔出或另一端的进程崩溃 |
| ---------------- | ------------------------------------------------------------ |
| 解决问题         | 其实当该异常产生的时候，对于服务端来说，并没有多少影响。因为可能是某个客户端突然中止了进程导致了该错误 |
| 总结 Broken Pipe | 这个异常是客户端读取超时关闭了连接,这时候服务器端再向客户端已经断开的连接写数据时就发生了broken pipe异常！ |

> broken pipe的意思是**对端的管道已经断开**，往往发生在**远端把这个读/写管道关闭了,你无法在对这个管道进行读写操作**。从tcp的四次挥手来讲，远端已经发送了FIN序号，告诉你我这个管道已经关闭，这时如果你继续往管
> 道里写数据，第一次，你会收到一个远端发送的RST信号，如果你继续在管道里write数据，操作系统就会给你发送SIGPIPE的信号并且将errno置为Broken pipe (32)，如果你的程序默认没有对SIGPIPE进行处理，那么程序会中断退出。一般情况下，可以用
> **signal(SIGPIPE,SIGIGN)**忽略这个信号，这样的话程序不会退出，但是write会返回-1并且将errno置为Broken pipe (32)。brokenpipe只会出现在往**对端已经关闭的管道里写数据的情况下**（在收到对端的RST序号后第一次写不会出现broke pipe，而是wite返回-1,这时候正确的做法应该是本端也close这个管道，如果继续write，那么就会出现这个错误)。

**查看日志，投票新选**

- sentinel26379.log

  ![image-20230327102604150](https://gitee.com/kiteflyer/picture/raw/master/Redis/image-20230327102604150.png)

- sentinel26380.log

  ![image-20230327102622211](https://gitee.com/kiteflyer/picture/raw/master/Redis/image-20230327102622211.png)

- sentinel26381.log

  ![image-20230327102641574](https://gitee.com/kiteflyer/picture/raw/master/Redis/image-20230327102641574.png)

**此次案例中，谁是新的master**

- 6381被选为新master，上位成功

  ![image-20230327102839282](https://gitee.com/kiteflyer/picture/raw/master/Redis/image-20230327102839282.png)

- 以前的6379从master降级变成了slave

  ![image-20230327102855235](https://gitee.com/kiteflyer/picture/raw/master/Redis/image-20230327102855235.png)

- 6380还是slave，只不过换了个新老大6381(6379变6381)，6380还是slave

**查看现在的配置文件，与原来是否有不同的地方**

> 文件的内容，在运行期间会被sentinel动态进行更改
>
> Master-Slave切换后，master_redis.conf、slave_redis.conf和sentinel.conf的内容都会发生改变，即master_redis.conf中会多一行slaveof的配置，sentinel.conf的监控目标会随之调换

**注意：**

- 生产都是不同机房不同服务器，很少出现3个哨兵全挂掉的情况

- 可以同时监控多个master，一行一个

## 哨兵运行流程和选举原理

当一个主从配置中的master失效之后，sentinel可以选举出一个新的master，用于自动接替原master的工作，主从配置中的其他redis服务器自动指向新的master同步数据。一般建议sentinel采取奇数台，防止某一台sentinel无法连接到master导致误切换

### SDown主观下线(Subjectively Down)

SDOWN(主观不可用)是**单个sentinel自己主观上**检测到的关于master的状态，从sentinel的角度来看，如果发送了PING心跳后，在一定时间内没有收到合法的回复，就达到了SDOWN的条件。

sentinel配置文件中的down-after-milliseconds设置了判断主观下线的时间长度

所谓主观下线（Subjectively Down， 简称 SDOWN）指的是**单个Sentinel实例**对服务器做出的下线判断，即单个sentinel认为某个服务下线（有可能是接收不到订阅，之间的网络不通等等原因）。主观下线就是说如果服务器在[sentinel down-after-milliseconds]给定的毫秒数之内没有回应PING命令或者返回一个错误消息， 那么这个Sentinel会主观的(**单方面的**)认为这个master不可以用了，o(╥﹏╥)o

![image-20230327104203550](https://gitee.com/kiteflyer/picture/raw/master/Redis/image-20230327104203550.png)

sentinel down-after-milliseconds `<masterName> <timeout>`

表示master被当前sentinel实例认定为失效的间隔时间，这个配置其实就是进行主观下线的一个依据

master在多长时间内一直没有给Sentine返回有效信息，则认定该master主观下线。也就是说如果多久没联系上redis-servevr，认为这个redis-server进入到失效（SDOWN）状态。

### ODown客观下线(Objectively Down)

ODOWN需要一定数量的sentinel，多个哨兵达成一致意见才能认为一个master客观上已经宕掉

四个参数含义：

masterName是对某个master+slave组合的一个区分标识(一套sentinel可以监听多组master+slave这样的组合)

<img src="https://gitee.com/kiteflyer/picture/raw/master/Redis/image-20230327105010509.png" alt="image-20230327105010509" style="zoom:67%;" />

**quorum这个参数是进行客观下线的一个依据**，法定人数/法定票数

意思是至少有quorum个sentinel认为这个master有故障才会对这个master进行下线以及故障转移。因为有的时候，某个sentinel节点可能因为自身网络原因导致无法连接master，而此时master并没有出现故障，所以这就需要多个sentinel都一致认为该master有问题，才可以进行下一步操作，这就保证了公平性和高可用。

### 选举哨兵领导者

<img src="https://gitee.com/kiteflyer/picture/raw/master/Redis/image-20230327105226725.png" alt="image-20230327105226725" style="zoom:80%;" />

当主节点被判断客观下线以后，各个哨兵节点会进行协商，先选举出一个并由该领导者节点，也即被选举出的兵王进行failover（故障迁移）

三哨兵日志文件2次解读分析

- sentinel26379.log

  <img src="https://gitee.com/kiteflyer/picture/raw/master/Redis/image-20230327105425182.png" alt="image-20230327105425182" style="zoom:80%;" />

- sentinel26380.log

  <img src="https://gitee.com/kiteflyer/picture/raw/master/Redis/image-20230327105449172.png" alt="image-20230327105449172" style="zoom:80%;" />

- sentinel26381.log

  <img src="https://gitee.com/kiteflyer/picture/raw/master/Redis/image-20230327105507154.png" alt="image-20230327105507154" style="zoom:80%;" />

哨兵领导者，兵王如何选出来的？

Raft算法

![image-20230327105646321](https://gitee.com/kiteflyer/picture/raw/master/Redis/image-20230327105646321.png)

监视该主节点的所有哨兵都有可能被选为领导者，选举使用的算法是Raft算法；Raft算法的基本思路**是先到先得**：

即在一轮选举中，哨兵A向B发送成为领导者的申请，如果B没有同意过其他哨兵，则会同意A成为领导者

### 哨兵领导者推动故障切换流程并选举一个新的master

1. 新主登基

   某个Slave被选中成为新Master

   选出新master的规则，剩余slave节点健康前提下

   <img src="https://gitee.com/kiteflyer/picture/raw/master/Redis/image-20230327110015990.png" alt="image-20230327110015990" style="zoom:67%;" />

   - redis.conf文件中，优先级slave-priority或者replica-priority最高的从节点(数字越小优先级越高 )

     <img src="https://gitee.com/kiteflyer/picture/raw/master/Redis/image-20230327110050107.png" alt="image-20230327110050107" style="zoom:67%;" />

   - 复制偏移位置offset最大的从节点
   - 最小Run ID的从节点（字典书序，ASCII编码）

2. 群臣俯首

   一朝天子一朝臣，换个码头重新拜

   执行slaveof no one命令让选出来的从节点成为新的主节点，并通过slaveof命令让其他节点成为其从节点

   Sentinel leader会对选举出的新master执行slaveof no one操作，将其提升为master节点

   Sentinel leader向其它slave发送命令，让剩余的slave成为新的master节点的slave

3. 旧住拜服

   老master回来也认怂

   将之前已下线的老master设置为新选出的新master的从节点，当老master重新上线后，它会成为新master的从节点

   Sentinel leader会让原来的master降级为slave并恢复正常工作。

> 从下线的主服务的所有从服务里面挑选一个从服务，将其转成主服务
> 选择条件依次为:
>
> - 1、选择优先级靠前的（优先级在redis.conf中slave-priority 100）
> - 2、选择偏移量最大的（偏移量是指获得原主数据最多的）
> - 3、选择runid最小的从服务（每个redis实例启动后都会随机生成一个40位的runid）
>
> 挑选出新的主服务之后，sentinel向原主服务的从服务发送slaveof 新主服务的命令，复制新master
>
> 当已下线的服务重新上线时，sentinel会向其发送slaveof命令,让其成为新主的从机

上述的failover（故障切换）操作均由sentinel自己独自完成，完全无需人工干预。

## 哨兵使用注意事项

哨兵节点的数量应为多个，哨兵本身应该集群，保证高可用

哨兵节点的数量应该是奇数

各个哨兵节点的硬件配置应一致

如果哨兵节点部署在Docker等容器里面，尤其要注意端口的正确映射

哨兵集群+主从复制，并不能保证数据零丢失



 