---
title: 管道
date: 2024-08-05 15:18:30
permalink: /pages/0e1911/
categories: 
  - 《Redis》笔记
tags: 
  - 
author: 
  name: xugaoyi
  link: https://github.com/xugaoyi
---
# 管道

官网：https://redis.io/docs/manual/pipelining/

## 由来

问题：如何优化频繁命令往返造成的性能瓶颈？

Redis是一种基于客户端-服务端模型以及请求/响应协议的TCP服务。一个请求会遵循以下步骤：

1 客户端向服务端发送命令分四步(发送命令→命令排队→命令执行→返回结果)，并监听Socket返回，通常以阻塞模式等待服务端响应。

2 服务端处理命令，并将结果返回给客户端。

**上述两步称为：Round Trip Time(简称RTT,数据包往返于两端的时间)，问题笔记最下方**

<img src="https://gitee.com/kiteflyer/picture/raw/master/Redis/image-20230324163913998.png" alt="image-20230324163913998" style="zoom:67%;" />

如果同时需要执行大量的命令，那么就要等待上一条命令应答后再执行，这中间不仅仅多了RTT（Round Time Trip），而且还频繁调用系统IO，发送网络请求，同时需要redis调用多次read()和write()系统方法，系统方法会将数据从用户态转移到内核态，这样就会对进程上下文有比较大的影响了，性能不太好，o(╥﹏╥)o

解决思路

管道(pipeline)可以一次性发送多条命令给服务端，服务端依次处理完完毕后，通过一条响应一次性将结果返回，通过减少客户端与redis的通信次数来实现降低往返延时时间。pipeline实现的原理是队列，先进先出特性就保证数据的顺序性。

<img src="https://gitee.com/kiteflyer/picture/raw/master/Redis/image-20230324164547241.png" alt="image-20230324164547241" style="zoom:67%;" />

## 是什么

Pipeline是为了解决RTT往返回时，仅仅是将命令打包一次性发送，对整个Redis的执行不造成其它任何影响

一句话：批处理命令变种优化措施，类似Redis的原生批命令(mget和mset)

## 演示

<img src="https://gitee.com/kiteflyer/picture/raw/master/Redis/image-20230324164253962.png" alt="image-20230324164253962" style="zoom:80%;" />

## 总结

Pipeline与原生批量命令对比

- 原生批量命令是原子性(例如:mset, mget)，pipeline是非原子性
- 原生批量命令一次只能执行一种命令，pipeline支持批量执行不同命令
- 原生批命令是服务端实现，而pipeline需要服务端与客户端共同完成

Pipeline与事务对比

- 事务具有原子性，管道不具有原子性
- 管道一次性将多条命令发送到服务器，事务是一条一条的发，事务只有在接收到exec命令后才会执行，管道不会
- 执行事务时会阻塞其他命令的执行，而执行管道中的命令时不会

使用Pipeline注意事项

- pipeline缓冲的指令只是会依次执行，不保证原子性，如果执行中指令发生异常，将会继续执行后续的指令
- 使用pipeline组装的命令个数不能太多，不然数据量过大客户端阻塞的时间可能过久，同时服务端此时也被迫回复一个队列答复，占用很多内存