---
title: 进程管理
date: 2020-05-11 13:54:03
permalink: /pages/a2f161
article: false
---

# 第 2 章 进程管理

## 2.1 进程与线程

### 2.1.1 进程的定义、特征、组成、组织

![image-20221109161545877](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109161545877.png)

#### 程序是如何运行的？

![image-20221109161352342](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109161352342.png)

![image-20221109161407667](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109161407667.png)

![image-20221109165211193](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109165211193.png)

#### 1.进程的定义

##### (1）程序的概念

程序：是静态的，就是个存放在磁盘里的可执行文件，就是一系列的指令集合。

![image-20221109155743410](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109155743410.png)

##### (2）进程的概念

进程（Process）：是动态的，是程序的一次执行过程(同一个程序多次执行会对应多个进程)

![image-20221109155857980](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109155857980.png)

**进程和程序的区别和联系：**

> 区别：
> 1)进程是动态的;程序是静态的。
> (2)进程有独立性，能并发执行;程序不能并发执行。
> (3)二者无一一对应关系。
> (4)进程异步运行，会相互制约;程序不具备此特征。
> 但是，进程与程序又有密切的联系： 进程不能脱离具体程序而虚设， 程序规定了相应进程所要完成的动作。
> (5)组成不同。进程包含PCB、程序段、数据段。程序包含数据和指令代码。
> (6)程序是一个包含了所有指令和数据的静态实体。本身除占用磁盘的存储空间外，并不占用系统如CPU、内存等运行资源。
> (7)进程由程序段、数据段和PCB构成,会占用系统如CPU、内存等运行资源。
> (8)一个程序可以启动多个进程来共同完成。
> 联系：进程不能脱离具体程序而虚设， 程序规定了相应进程所要完成的动作。

##### (3）进程的定义

`程序段`、`数据段`、`PCB`三部分组成了`进程实体（进程映像）`。**一般情况下，我们把进程实体就简称为进程**，例如，所谓**创建**进程，实质上是创建进程实体中的PCB;而**撤销**进程，实质上是撤销进程实体中的PCB。注意:`PCB是进程存在的唯一标志!`

从不同的角度，进程可以有不同的定义，比较传统典型的定义有:

1．进程是程序的一次**执行过程**。
2．进程是一个程序及其数据在处理机上顺序执行时所**发生的活动**。
3．进程是具有独立功能的程序在数据集合上**运行的过程(强调“动态性”)**，它是系统进行资源分配和调度的一个独立单位

引入进程实体的概念后，可把进程定义为:
`进程`是进程实体的`运行过程`，是系统进行`资源分配`和`调度`的一个独立单位。

注:严格来说，进程实体和进程并不一样，进程实体是`静态的`，进程则是`动态的`。不过，除非题目专门考察二者区别，否则可以认为进程实体就是进程。因此我们也可以说“进程由程序段、数据段、PCB三部分组成”

#### 2.进程的特征

程序是静态的，进程是动态的，相比于程序，进程拥有以下特征：

![image-20221109160440800](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109160440800.png)

#### 3.进程的组成

进程（进程实体）由`程序段`、`数据段`、`PCB`三部分组成。

![image-20221109161134343](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109161134343.png)

PCB 是给操作系统用的。

程序段、数据段是给进程自己用的。

![image-20221109160645112](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109160645112.png)

![image-20221109161052815](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109161052815.png)

- 而其中最重要的就是**进程控制块PCB**（Process Control Block）
- PCB简介：
  PCB中记录了操作系统所需的，用于描述进程的当前情况以及控制进程运行的全部信息。
  PCB的作用是使一个在多道程序环境下不能独立运行的程序（含数据），成为一个能独立运行的基本单位，一个能与其他进程并发执行的进程。
  或者说，**OS是根据PCB来对并发执行的进程进行控制和管理的。**
  例如，当OS要`调度`某进程执行时，要从该进程的PCB中查处其现行状态及优先级；在调度到某进程后，要根据其PCB中所保存的处理机状态信息，设置该进程恢复运行的现场，并根据其PCB中的程序和数据的内存始址，找到其程序和数据；
  进程在`执行`过程中，当需要和与之合作的进程实现同步，通信或者访问文件时，也都需要访问PCB；
  当进程由于某种原因而`暂停`执行时，又须将器断点的处理机环境保存在PCB中。
  可见，在进程的整个生命期中，系统总是通过PCB对进程进行控制的，即系统是根据进程的PCB而不是任何别的什么而感知到该进程的存在的。
  所以说，PCB是进程存在的唯一标志。

PCB通常包含的内容：

![image-20221109161000135](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109161000135.png)

![image-20221109160947528](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109160947528.png)

![image-20221109161229934](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109161229934.png)

#### 4.进程的组织

在一个系统中，通常有数十、数百乃至数千个PCB。为了能对他们加以有效的管理，应该用适当的方式把这些PCB组织起来。

注：进程的`组成`讨论的是一个`进程内部`由哪些部分构成的问题，而进程的`组织`讨论的是`多个进程之间`的组织方式问题

![image-20221109161644343](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109161644343.png)

##### (1)链接方式

![image-20221109161655933](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109161655933.png)

##### (2)索引方式

![image-20221109161706165](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109161706165.png)

### 2.1.2 进程的状态（运行、就绪、阻塞、创建、终止）及转换（就绪->运行、运行->就绪、运行->阻塞、阻塞->就绪）

#### 1.思维导图总览

![image-20221109162242792](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109162242792.png)

#### ⒉进程的状态

##### (1）三种基本状态(就绪、运行、阻塞)

![image-20221109162421132](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109162421132.png)

##### (2)创建态和结束态

![image-20221109162452382](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109162452382.png)

- 创建态

  ![image-20221109162558753](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109162558753.png)

- 结束态

  ![image-20221109162634364](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109162634364.png)

#### 3.进程状态之间的转换

进程一共有如下5种状态，那么他们之间如何实现切换呢？

![image-20221109162705711](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109162705711.png)

咱们从一个进程的从无到有看起，来了解进程5种状态之间的转换

![image-20221109162750784](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109162750784.png)

来一张形象生动的图片感受一下5种状态之间的切换

![image-20221109162827720](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109162827720.png)

### 2.1.3 原语实现对进程的控制

![image-20221109163139440](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109163139440.png)

#### 1.什么是进程控制?

进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现

进程状态转换等功能。

简化理解：反正进程控制就是要实现进程状态转换

![image-20221109163419893](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109163419893.png)

#### ⒉原语实现对进程的控制

![image-20221109163610171](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109163610171.png)

![image-20221109163631167](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109163631167.png)

如何实现原语的“原子性”？

原语的执行具有原子性，即执行过程只能一气呵成，期间不允许被中断。

可以用 “关中断指令”和“开中断指令”这两个特权指令实现原子性

![image-20221109163928888](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109163928888.png)

![image-20221109163939688](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109163939688.png)

![image-20221109163721537](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109163721537.png)

#### 3.回忆进程的组织

进程在操作系统中的组织使各个进程能够有序的进行切换和运行

![image-20221109164054784](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109164054784.png)

#### 4.进程控制大致图解

![image-20221109165321458](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109165321458.png)

> 这里说明一下调度和切换的区别：
> `调度`是指决定资源分配给哪个进程的行为，是一种决策行为
> `切换`是指实际分配的行为，是执行行为
> 一般来说现有资源调度，后有进程切换

#### 5.进程控制原语的相同点

学习技巧:进程控制会导致进程状态的转换。无论哪个原语，要做的无非三类事情:

1. 更新PCB中的信息（如修改进程状态标志、将运行环境保存到PCB、从PCB恢复运行环境)

   a.所有的进程控制原语一定都会修改进程状态标志

   b.剥夺当前运行进程的CPU使用权必然需要保存其运行环境

   c.某进程开始运行前必然要恢复期运行环境

2. 将PCB插入合适的队列

3. 分配/回收资源

接下来我们就具体学习一下关于进程控制的五种原语，`进程的创建、终止、唤醒、阻塞、切换；`

#### 6.进程控制的五种原语

##### (1)进程的创建原语

![image-20221109164706380](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109164706380.png)

##### (2）进程的终止原语

![image-20221109164812929](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109164812929.png)

##### (3）进程的唤醒和阻塞原语

- 进程的阻塞和唤醒原语是`成对存在`的，必须`成对使用`。
- `阻塞原语`是由被阻塞进程自我调用实现的
- `唤醒原语`是由一个被唤醒进程合作或被其他相关的进程调用实现的

![image-20221109164935367](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109164935367.png)

##### (4）进程的切换原语

![image-20221109165013878](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109165013878.png)

### 2.1.4 进程之间的通信（共享通信、消息传递、管道通信）

![image-20221109165935933](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109165935933.png)

#### 1.什么是进程通信?

- 图中我们可以知道什么是进程通信，以及进程通信的低级和高级方式；
- 我们还可以知道为什么要引入进程通信方式，以及它的意义

顾名思义，进程通信就是指进程之间的信息交换。

进程是分配系统资源的单位（包括内存地址空间），因此`各进程`拥有的`内存地址空间相互独立`。

![image-20221109170028392](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109170028392.png)

#### 2.共享存储

共享一块大家都可以访问的空间，一次只能有一个进程进行读或写操作

![image-20221109170102698](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109170102698.png)

#### 3.管道通信

![image-20221109170204666](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109170204666.png)

1. 管道只能采用`半双工通信`，某一时间段内只能实现单向的传输。如果要`实现双向同时通信`，则`需要设置两个管道`。

2. 各进程要`互斥`地访问管道。

3. 数据以字符流的形式写入管道，当`管道写满`时，`写进程`的write()系统调用将被`阻塞`，等待读进程将数据取走。当读进程将数据全部取走后，`管道变空`，此时`读进程`的read()系统调用将被`阻塞`。

4. 如果`没写满，就不允许读`。如果`没读空，就不允许写`。

5. 数据一旦被读出，就从管道中被抛弃，这就意味着`读进程最多只能有一个`，否则可能会有读错数据的情

况。

#### 4.消息传递

发送信息的进程将消息头写好，接受信息进程根据消息头读取信息或寻找信封是哪一个

进程间的数据交换以`格式化的消息`（Message）为单位。进程通过操作系统提供的“发送消息/接收

消息”两个`原语`进行数据交换。

![image-20221109170327091](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109170327091.png)

### 2.1.5 线程概念与多线程模型

![image-20221109170809406](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109170809406.png)

#### 1.为什么要引入线程?

![image-20221109170924323](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109170924323.png)

![image-20221109171010208](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109171010208.png)

![image-20221109171049385](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109171049385.png)

![image-20221109171128179](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109171128179.png)

![image-20221109171156175](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109171156175.png)

为了方便于理解，我打开了我的任务管理器，可以看出chrome一个进程，下面有很多分支，可以把这些分支当做线程看待，PID即进程和线程都有的标识符。

![image-20221109171301036](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109171301036.png)

#### 2.什么是线程?

可以把线程理解为“轻量级进程”。`线程`是一个`基本的CPU执行单元`，也是`程序执行流的最小单位`。引入线程之后，不仅是进程之间可以并发，进程内的`各线程之间`也可以`并发`，从而进一步`提升了系统的并发度`，使得一个进程内也可以并发处理各种任务（如QQ视频、文字聊天、传文件）引入线程后，`进程`只作为`除CPU之外的系统资源的分配单元`（如打印机、内存地址空间等都是分配给进程的）。`线程`则作为`处理机的分配单元`。

![image-20221109173059312](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109173059312.png)

#### 3.引入线程带来的变化及进程与线程的比较

![image-20221109173225151](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109173225151.png)

**线程的特性和优点**

![image-20221109173323423](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109173323423.png)

![image-20221109173401345](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109173401345.png)

![image-20221109173421786](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109173421786.png)

**其他一些需要注意的地方**

![image-20221109173605295](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109173605295.png)

#### 4.线程的属性

![image-20221109173516949](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109173516949.png)

#### 5.线程的实现方式

- 前面我们了解了引入线程的好处和引入线程的变化，以及线程的属性，那么线程如何实现呢？
- 线程的实现分为两类：`用户级线程`(User-Level Thread,UTL)和`内核级线程`(Kernel-Level Thread, KTL)l。内核级线程又称`内核支持的线程`。

##### (1)用户级线程

用户级线程（User-Level Thread, ULT）

![image-20221109173748696](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109173748696.png)

##### (2)内核级线程

内核级线程（Kernel-Level Thread, KLT, 又称“内核支持的线程”）

![image-20221109173809815](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109173809815.png)

##### (3)特殊的组合方式及重点注意

在同时支持用户级线程和内核级线程的系统中，可采用二者组合的方式：将n个用户级线程映射到m个内核级线程上（ n >= m）

![image-20221109173933038](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109173933038.png)

#### 6.多线程模型

前面我们提到了线程的实现方式，有用户级和内核级。那么这两种模式的交叉组合就会产生几种不一样的组织结构，即不一样的模型。

##### (1)多对一模型

在同时支持用户级线程和内核级线程的系统中，由几个用户级线程映射到几个内核级线程的问题引出了“多线程模型”问题。

![image-20221109174057614](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109174057614.png)

##### (2)一对一模型

在同时支持用户级线程和内核级线程的系统中，由几个用户级线程映射到几个内核级线程的问题引出了“多线程模型”问题。

![image-20221109174120032](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109174120032.png)

##### (3）多对多模型

在同时支持用户级线程和内核级线程的系统中，由几个用户级线程映射到几个内核级线程的问题引出了“多线程模型”问题。

![image-20221109174138382](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221109174138382.png)

## 2.2 处理机的调度

### 2.2.1 处理机调度的概念及层次

![image-20221110105252089](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110105252089.png)

#### 1.调度的基本概念

当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定`某种规则`来`决定`处理

这些任务的`顺序`，这就是“调度”研究的问题。

在多道程序系统中，进程的数量往往是多于处理机的个数的，这样不可能同时并行地处理各个进程。

处理机调度，就是从就绪队列中`按照一定的算法选择一个进程`并`将处理机分配给它`运行，以实现进程

的并发执行。

![image-20221110105540327](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110105540327.png)

#### ⒉.调度的三个层次

##### (1)高级调度（作业调度)

由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要确定某种规则来决定将作业调入内存的顺序。

`高级调度（作业调度）`。按一定的原则从外存上处于后备队列的作业中挑选一个（或多个）作业，给他们分配内存等必要资源，并`建立相应的进程（建立PCB）`，以使它（们）`获得竞争处理机的权利`。

高级调度是辅存（外存）与内存之间的调度。每个作业只调入一次，调出一次。`作业调入时会建立相应的PCB，作业调出时才撤销PCB`。高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。

![image-20221110105622388](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110105622388.png)

##### (2)中级调度(内存调度)

引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。

这么做的目的是为了`提高内存利用率`和`系统吞吐量`。

暂时调到外存等待的进程状态为`挂起状态`。值得注意的是，`PCB`并不会一起调到外存，而是`会常驻内存`。PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。被挂起的进程PCB会被放到的`挂起队列`中。

`中级调度（内存调度）`，就是要决定将哪个处于挂起状态的进程重新调入内存。一个进程可能会被多次调出、调入内存，因此`中级调度`发生的`频率`要比高级调度`更高`。

![image-20221110105806694](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110105806694.png)

##### (3）进程的挂起状态与七状态模型

暂时调到外存等待的进程状态为`挂起状态（挂起态，suspend)`

挂起态又可以进一步细分为`就绪挂起`、`阻塞挂起`

两种状态五状态模型->七状态模型

![image-20221110110108697](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110110108697.png)

注意“挂起”和“阻塞”的区别，两种状态都是暂时不能获得CPU的服务，但挂起态是将进程映像调到外存去了，而阻塞态下进程映像还在内存中。有的操作系统会把就绪挂起、阻塞挂起分为两个挂起队列，甚至会根据阻塞原因不同再把阻塞挂起进程进一步细分为多个队列。

##### (4）低级调度(进程调度)

`低级调度（进程调度）`，其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。

进程调度是操作系统中`最基本的一种调度`，在一般的操作系统中都必须配置进程调度。

进程调度的`频率很高`，一般几十毫秒一次。

![image-20221110110230064](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110110230064.png)

##### (5）三层调度的联系和对比

![image-20221110110303285](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110110303285.png)

### 2.2.2 进程调度的时机（主动放弃与被动放弃）、切换与过程（广义与狭义）、方式（非剥夺与剥夺）

![image-20221110133238351](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110133238351.png)

#### 1.时机

##### (1)什么时候进行进程调度?

`进程调度（低级调度）`，就是按照某种算法从就绪队列中选择一个进程为其分配处理机。

![image-20221110133810211](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110133810211.png)

##### (2)什么时候不能进行进程调度?

![image-20221110134025053](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110134025053.png)

##### (3)OS内核程序临界区与普通临界区的进程调度情况

![image-20221110133537803](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110133537803.png)

![image-20221110133605519](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110133605519.png)

#### 2.进程调度的方式

所谓进程调度方式，是指当某个进程正在处理机上执行时，若有某个更为重要或紧迫的进程需要处理，即有优先权更高的进程进入就绪队列，此时应如何分配处理机。

![image-20221110134102649](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110134102649.png)

#### 3.进程的切换和过程

“狭义的进程调度”与“进程切换”的区别：

`狭义的进程调度`指的是从就绪队列中`选中一个要运行的进程`。（这个进程可以是刚刚被暂停执行的进程，也可能是`另一个进程`，后一种情况就需要`进程切换`）

`进程切换`是指一个进程让出处理机，由另一个进程占用处理机的过程。

`广义的进程调度`包含了选择一个进程和进程切换两个步骤。

进程切换的过程主要完成了：

1. 对原来运行进程各种数据的保存

2. 对新的进程各种数据的恢复（如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块）

注意：`进程切换是有代价的`，因此如果`过于频繁的`进行进程`调度`、`切换`，必然会使整个`系统的效率降低`，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。

### 2.2.3 度算法的评价指标（cpu利用率、系统吞吐量、周转时间、等待时间、响应时间）

![image-20221110134537069](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110134537069.png)

#### 1.CPU利用率

![image-20221110134658815](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110134658815.png)

#### ⒉.系统吞吐量

![image-20221110134724254](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110134724254.png)

#### 3.周转时间

![image-20221110134918744](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110134918744.png)

![image-20221110134934016](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110134934016.png)

#### 4.等待时间

计算机的用户希望自己的作业尽可能少的等待处理机

`等待时间`，指进程/作业`处于等待处理机状态时间之和`，等待时间越长，用户满意度越低

![image-20221110134840343](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110134840343.png)

对于`进程`来说，等待时间就是指进程建立后`等待被服务的时间之和`，在等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间。

对于`作业`来说，不仅要考虑`建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间`。

一个作业总共需要被CPU服务多久，被I/O设备服务多久一般是确定不变的，因此调度算法其实只会影响作业/进程的等待时间。当然，与前面指标类似，也有“`平均等待时间`”来评价整体性能。

#### 5.响应时间

对于计算机用户来说，会希望自己的提交的请求（比如通过键盘输入了一个调试命令）尽早地开始被系统服务、回应。

`响应时间`，指从用户`提交请求`到`首次产生响应`所用的时间。

### 2.2.4 作业/进程调度算法（FCFS先来先服务、SJF短作业优先、HRRN高响应比优先）

![image-20221110135407539](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110135407539.png)

#### 1.先来先服务---FCFS

First come first sever

![image-20221110135532461](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110135532461.png)

![image-20221110135616460](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110135616460.png)

#### 2.短作业优先---SJF

Shortest Job First

![image-20221110135712848](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110135712848.png)

非抢占式—SJF

![image-20221110135837737](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110135837737.png)

抢占式—SJF(SRTN)

![image-20221110135919383](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110135919383.png)

![image-20221110135946998](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110135946998.png)

**注意几个小细节：**

1. 如果题目中`未特别说明`，所提到的“短作业/进程优先算法”`默认`是`非抢占式`的

2. 很多书上都会说“SJF 调度算法的平均等待时间、平均周转时间最少”

   严格来说，这个表述是错误的，不严谨的。之前的例子表明，最短剩余时间优先算法得到的平均等待时间、平均周转时间还要更少

   应该加上一个条件“在所有进程同时可运行时，采用SJF调度算法的平均等待时间、平均周转时间最少”；

   或者说“在`所有进程都几乎同时到达时`，采用SJF调度算法的平均等待时间、平均周转时间最少”；

   如果不加上述前提条件，则应该说“`抢占式的`短作业/进程优先调度算法（`最短剩余时间优先, SRNT`算法）的平均等待时间、平均周转时间最少”

3. 虽然严格来说，SJF的平均等待时间、平均周转时间并不一定最少，但相比于其他算法（如 FCFS），SJF依然可以获得较少的平均等待时间、平均周转时间

4. 如果选择题中遇到“SJF 算法的平均等待时间、平均周转时间最少”的选项，那最好判断其他选项是不是有很明显的错误，如果没有更合适的选项，那也应该选择该选项

#### 3.高响应比优先---HRRN

Highest Response Ratio Next

![image-20221110140326984](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110140326984.png)

![image-20221110140343338](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110140343338.png)

![image-20221110140411063](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110140411063.png)

#### 4.三种算法的对比和总结

![image-20221110140429171](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110140429171.png)

注：这几种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，但是不关心“响应时间”，也并不区分任务的紧急程度，因此对于用户来说，交互性很糟糕。因此这三种算法一般适合用于`早期的批处理系统`，当然，FCFS算法也常结合其他的算法使用，在现在也扮演着很重要的角色。而适合用于`交互式系统`的调度算法将在下个小节介绍…

`提示：一定要动手做课后习题！`这些算法特性容易考小题，算法的使用常结合调度算法的评价指标在大题中考察。

### 2.2.5 作业/进程调度算法（时间片轮转调度算法、优先级调度算法、多级反馈队列调度算法）

![image-20221110140836846](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110140836846.png)

#### 1.时间片轮转---RR

Round-Robin

![image-20221110140959704](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110140959704.png)

时间片为2举例

![image-20221110141120809](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110141120809.png)

![image-20221110141146223](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110141146223.png)

以时间片为5举例

![image-20221110141219705](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110141219705.png)

可能出现的问题，比如与FCFS对比

![image-20221110141251846](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110141251846.png)

![image-20221110141322311](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110141322311.png)

#### 2.优先级调度算法

![image-20221110141423574](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110141423574.png)

非抢占式例子

![image-20221110141536736](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110141536736.png)

抢占式例子

![image-20221110141608025](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110141608025.png)

补充

![image-20221110141632528](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110141632528.png)

#### 3.多级反馈队列调度算法

![image-20221110141700095](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110141700095.png)

![image-20221110141730717](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110141730717.png)

举个例子

![image-20221110141802420](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110141802420.png)

![image-20221110141836586](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110141836586.png)

![image-20221110141909530](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110141909530.png)

![image-20221110141949768](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110141949768.png)

![image-20221110142016054](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110142016054.png)

![image-20221110142045599](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110142045599.png)

#### 4.三种算法的对比总结

![image-20221110142129483](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110142129483.png)

注:比起早期的批处理操作系统来说，由于计算机造价大幅降低，因此之后出现的交互式操作系统（包括分时操作系统、实时操作系统等）更注重系统的响应时间、公平性、平衡性等指标。而这几种算法恰好也能较好地满足交互式系统的需求。因此这三种算法适合用于`交互式系统`。(比如UNIx使用的就是多级反馈队列调度算法)

## 2.3 进程的同步与互斥

### 2.3.1 进程的同步与互斥

![image-20221110142850426](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110142850426.png)

#### 1.进程同步

- `同步也称为直接制约关系。`
- 在多道程序环境下，进程是并发执行的，不同进程之间存在着不同的相互制约关系。为了协调进程之间的相互制约关系,如等待、传递信息等，引入了进程同步的概念。进程同步是为了解决进程的异步问题。
- 一个简单的例子来理解这个概念。
- 例如，让系统计算1 + 2x3，假设系统产生两个进程: 一个是加法进程，一个是乘法进程。要让计算结果是正确的，一定要让加法进程发生在乘法进程之后,但实际上操作系统具有异步性,若不加以制约，加法进程发生在乘法进程之前是绝对有可能的，因此要制定一定的机制去约束加法进程，让它在乘法进程完成之后才发生。

> 异步性：进程具有异步性的特征。异步性是指，各并发执行的进程以各自独立的、不可预知的速度向前推进。

#### 2.进程互斥

- `互斥，亦称间接制约关系`。`进程互斥`指当一个进程访问某临界资源时，另一个想要访问该`临界资源`的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。
- 在这里需复习一下`临界资源`的概念。
- 我们把一个时间段内只允许一个进程使用的资源称为临界资源。许多物理设备(比如摄像头、打印机)都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。
- 对临界资源的访问，必须互斥地进行。

![image-20221110143148300](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110143148300.png)

为了禁止两个进程同时进入`临界区`，需遵循以下准则

![image-20221110143221640](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110143221640.png)

### 2.3.2 实现临界区进程互斥的软件实现方法

![image-20221110143419802](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110143419802.png)

软件实现方法的思想：在进入区设置并检查一些标志 来标明是否有进程在临界区中,若已有进程在临界区，则在进入区通过循环检查进行等待，进程离开临界区后则在退出区修改标志。`入区通过循环检查进行等待，进程离开临界区后则在退出区修改标志。`

#### 1.单标志法

![image-20221110143546823](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110143546823.png)

#### ⒉.双标志先检查法

![image-20221110143616511](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110143616511.png)

#### 3.双标志后检查法

![image-20221110143647537](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110143647537.png)

#### 4.Peterson算法

![image-20221110143721231](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110143721231.png)

![image-20221110143752199](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110143752199.png)

### 2.3.3 实现临界区进程互斥的硬件实现方法

![image-20221110143902033](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110143902033.png)

#### 1.中断隐藏方法

利用“开/关中断指令”实现（与原语的实现思想相同，即在某进程开始访问临界区到结束访问为

止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况）

![image-20221110144110059](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110144110059.png)

优点：简单、高效

缺点：不适用于多处理机；只适用于操作系统内核进程，不适用于用户进程（因为开/关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险）

#### 2.TestAndSet指令

- 执行TSL指令时，它的内部运转逻辑：
- 假设lock现在为false，代表临界资源A空闲，那么我就可以访问这个资源，同时将lock=true，提醒别的进程，这个临界资源A我正在使用，让他们等等
- 假设lock为true，代表临界资源正在有人使用，所以我必须等待，并且将lock=true，并不影响什么，所以没关系，只是为了让lock为false时可以上锁，将上锁与检查在一个TSL指令完成。

简称 TS 指令，也有地方称为 TestAndSetLock 指令，或 TSL 指令

TSL 指令`是用硬件实现的`，执行的过程不允许被中断，只能一气呵成。以下是用C语言描述的逻辑

![image-20221110144149413](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110144149413.png)

若刚开始 lock 是 false，则 TSL 返回的 old 值为 false，while 循环条件不满足，直接跳过循环，进入临界区。若刚开始 lock 是 true，则执行 TLS 后 old 返回的值为 true，while 循环条件满足，会一直循环，直到当前访问临界区的进程在退出区进行“解锁”。

相比软件实现方法，TSL 指令把“上锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作。

优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境

缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”。

#### 3.Swap指令

- old是每个进程都要进行的一步，都必须将old=true
- 分析一下这样做的原因：
- 因为lock是某一特定临界资源的共享变量，当每一个进程准备访问这个特定的临界资源时，初始化old=true，然后进入while循环进行交换，如果当前lock是false,则交换后old=false,则当前进程可以跳出循环进入临界区代码段，同时因为交换，lock=old=true上锁，不让别的进程来打扰，别的进程会因为lock变为true,一直在while循环等待,当我使用完临界资源，则将lock=false,此时别的进程再交换old和lock就能判断old=false,可以跳出循环，使用临界资源。

有的地方也叫 Exchange 指令，或简称 XCHG 指令。

Swap 指令是`用硬件实现的`，执行的过程不允许被中断，只能一气呵成。以下是用C语言描述的逻辑

![image-20221110144606726](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110144606726.png)

逻辑上来看 Swap 和 TSL 并无太大区别，都是先记录下此时临界区是否已经被上锁（记录在 old 变量上），再将上锁标记 lock 设置为 true，最后检查 old，如果 old 为 false 则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区。

优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境

缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”。

### 2.3.4 信号量机制（整型信号量、记录型信号量P、V）

![image-20221110152413924](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110152413924.png)

#### 1.为什么引入信号量机制?

为了更好的解决进程互斥与同步的问题

![image-20221110154336686](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110154336686.png)

#### 2.什么是信号量机制?

用户进程可以通过使用操作系统提供的`一对原语`来对`信号量`进行操作，从而很方便的实现了进程互斥、进程同步。

`信号量`其实就是一个变量 ，可以用一个信号量来`表示系统中某种资源的数量`，比如：系统中只有一台打印机，就可以设置一个初值为 1 的信号量。

`原语`是一种特殊的程序段，其`执行只能一气呵成，不可被中断`。原语是由`关中断/开中断指令`实现的。软件解决方案的主要问题是由“进入区的各种操作无法一气呵成”，因此如果能把进入区、退出区的操作都用“原语”实现，使这些操作能“一气呵成”就能避免问题。

`一对原语`：`wait(S)` 原语和 `signal(S)` 原语，可以把原语理解为我们自己写的函数，函数名分别为 wait和 signal，括号里的`信号量 S` 其实就是函数调用时传入的一个参数。

wait、signal 原语常`简称为 P、V操作`（来自荷兰语 proberen 和 verhogen）。因此，做题的时候常把

wait(S)、signal(S) 两个操作分别写为 `P(S)`、`V(S)`

#### 3.整型信号量

![image-20221110154606304](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110154606304.png)

#### 4.记录型信号量

整型信号量的缺陷是存在“忙等”问题，因此人们又提出了“记录型信号量”，即用记录型数据结构表示的信号量。

![image-20221110154703873](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110154703873.png)

##### (1)举一个生动形象的例子了解记录型信号量

一张图咱们回忆一下进程的状态

![image-20221110154738716](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110154738716.png)

一个例子

![image-20221110154904277](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110154904277.png)

![image-20221110154931380](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110154931380.png)

![image-20221110154948201](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110154948201.png)

![image-20221110155013804](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110155013804.png)

![image-20221110155107561](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110155107561.png)

##### (2）梳理一下记录型信号量的知识点(P、V)

![image-20221110155252635](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110155252635.png)

![image-20221110155207529](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221110155207529.png)

### 2.3.5 信号量机制实现进程的互斥、同步与前驱关系

![image-20221111095021223](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221111095021223.png)

#### 1.信号量机制实现进程互斥

不要一头钻到代码里，要注意理解信号量背后的含义，`一个信号量对应一种资源`

信号量的值 = 这种资源的剩余数量（信号量的值如果小于0，说明此时有进程在等待这种资源）

P( S ) —— 申请一个资源S，如果`资源不够就阻塞等待`

V( S ) —— 释放一个资源S，如果有进程在等待该资源，则`唤醒一个进程`

![image-20221111095325821](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221111095325821.png)

#### 2.信号量机制实现进程同步

进程同步：要让各并发进程按要求有序地推进。

想象一下四则运算的顺序，加减乘除；

![image-20221111095419452](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221111095419452.png)

要想理解这一部分知识，必须知道P、V操作的内部实现原理

![image-20221111095453638](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221111095453638.png)

#### 3.信号量机制实现前驱关系

进程 P1 中有句代码 S1，P2 中有句代码 S2 ，P3中有句代码S3 …… P6 中有句代码 S6。这些代码要求按如下前驱图所示的顺序来执行：

其实每一对前驱关系都是一个进程同步问题（需要保证一前一后的操作）

因此，

1. 要`为每一对前驱关系各设置一个同步信号量`

2. `在“前操作”之后对相应的同步信号量执行 V 操作`

3. `在“后操作”之前对相应的同步信号量执行 P 操作`

![image-20221111095639530](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221111095639530.png)

### 2.3.6 进程同步与互斥经典问题（生产者-消费者问题、多生产者-多消费者问题、吸烟者问题、读者-写者问题、哲学家进餐问题）

同步时，前V后P。

![image-20221111133917332](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221111133917332.png)

#### 1.生产者-消费者问题

##### (1）问题描述

- 系统中有`一组生产者进程`和`一组消费者进程`，生产者进程每次`生产一个`产品放入缓冲区，消费者进程每次从缓冲区中`取出一个`产品并使用。(注: 这里的“产品”理解为某种数据)
- 生产者、消费者`共享`一个初始为空、大小为n的`缓冲区`。
- 只有缓冲区`没满`时，`生产者`才能把产品`放入`缓冲区，否则必须等待。（缓冲区没满->生产者生产）
- 只有缓冲区`不空`时，`消费者`才能从中`取出`产品，否则必须等待。（缓冲区没空->消费者消费）
- 缓冲区是临界资源，各进程必须`互斥`地访问。（互斥关系）

![image-20221111135823693](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221111135823693.png)

##### (2）问题分析

- 1)关系分析。生产者和消费者对缓冲区互斥访问是`互斥关系`，同时生产者和消费者又是一个相互协作的关系，只有生产者生产之后,消费者才能消费，它们也是`同步关系`。
- 2)整理思路。根据各进程的操作流程确定P、V操作的大致顺序。
  生产者每次要消耗(P）一个空闲缓冲区，并生产(V)一个产品。
  消费者每次要消耗(P）一个产品，并释放一个空闲缓冲区(V)。
  往缓冲区放入/取走产品需要互斥。
- 3)信号量设置。设置信号量。设置需要的信号量，并根据题目条件确定信号量初值。( 互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少)

![image-20221111135928562](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221111135928562.png)

semaphore mutex = 1;  //互斥信号量，实现对缓冲区的互斥访问

semaphore empty = n;  //同步信号量，表示空闲缓冲区的数量

semaphore full = 0;  //同步信号量，表示产品的数量，也即非空缓冲区的数量

##### (3）如何实现?

![image-20221111140045302](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221111140045302.png)

##### (4）实现互斥的P操作一定要在实现同步的P操作之后

![image-20221111140322961](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221111140322961.png)

若此时缓冲区内已经放满产品，则 empty=0，full=n。

则生产者进程执行① 使mutex变为0，再执行②，由于已没有空闲缓冲区，因此生产者被阻塞。

由于生产者阻塞，因此切换回消费者进程。消费者进程执行③，由于mutex为0，即生产者还没

释放对临界资源的“锁”，因此消费者也被阻塞。

这就造成了生产者等待消费者释放空闲缓冲区，而消费者又等待生产者释放临界区的情况，生

产者和消费者循环等待被对方唤醒，出现“死锁”。

同样的，若缓冲区中没有产品，即full=0，empty=n。按③④① 的顺序执行就会发生死锁。

因此，`实现互斥的P操作一定要在实现同步的P操作之后`。

V操作不会导致进程阻塞，因此`两个V操作顺序可以交换`。

##### (5）知识回顾与重要考点

PV 操作题目的解题思路：

1. 关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。

2. 整理思路。根据各进程的操作流程确定P、V操作的大致顺序。

3. 设置信号量。设置需要的信号量，并根据题目条件确定信号量初值。（互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少）

生产者消费者问题是一个互斥、同步的综合问题。

对于初学者来说最难的是发现题目中隐含的两对同步关系。

有时候是消费者需要等待生产者生产，有时候是生产者要等待消费者消费，这是两个不同的“一

前一后问题”，因此也需要设置两个同步信号量。

![image-20221111140502879](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221111140502879.png)

**易错点：实现互斥和实现同步的两个P操作的先后顺序（死锁问题）**

#### 2.多生产者-多消费者问题

##### (1）问题描述

桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。用PV操作实现上述过程。

![image-20221111140614568](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221111140614568.png)

##### (2）问题分析

![image-20221111140658093](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221111140658093.png)

##### (3）实现方法

###### 有mutex

![image-20221111140844910](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221111140844910.png)

###### 无mutex

![image-20221111141153271](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221111141153271.png)

###### 为什么有mutex和没有mutex—样呢?

结论：即使不设置专门的互斥变量mutex，也不会出现多个进程同时访问盘子的现象。

原因在于：本题中的缓冲区大小为1，在任何时刻，apple、orange、plate 三个同步信号量中最多只有一个是1。因此在任何时刻，最多只有一个进程的P操作不会被阻塞，并顺利地进入临界区…

###### 如果有两个盘子plate

![image-20221111141508159](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221111141508159.png)

##### (4）知识总结与重要考点

- `总结`:在生产者_消费者问题中，如果缓冲区大小为1，那么有可能不需要设置互斥信号量就可以实现互斥访问缓冲区的功能。当然，`这不是绝对的`，要具体问题具体分析。
- `建议`:在考试中如果来不及仔细分析，可以加上互斥信号量，保证各进程一定会互斥地访问缓冲区。但需要注意的是，·`实现互斥的P操作一定要在实现同步的P操作之后`·，否则可能引起·`“死锁”`·。

解决“多生产者-多消费者问题”的关键在于理清复杂的同步关系。

在分析同步问题（一前一后问题）的时候不能从单个进程行为的角度来分析，要把“一前一后”发生

的事看做是两种“事件”的前后关系。

比如，如果从`单个进程行为的角度来考虑`的话，我们会有以下结论：

`如果盘子里装有苹果，那么一定要女儿取走苹果后父亲或母亲才能再放入水果`

`如果盘子里装有橘子，那么一定要儿子取走橘子后父亲或母亲才能再放入水果`

这么看是否就意味着要设置四个同步信号量分别实现这四个“一前一后”的关系了？

正确的分析方法应该`从“事件”的角度来考虑`，我们可以把上述四对“进程行为的前后关系”抽象为

一对“事件的前后关系”

盘子变空事件->放入水果事件。“盘子变空事件”既可由儿子引发，也可由女儿引发；“放水果事件”

既可能是父亲执行，也可能是母亲执行。这样的话，就可以用一个同步信号量解决问题了

![image-20221111141557781](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221111141557781.png)

#### 3.读者-写者问题

##### (1）问题描述

有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求：①`允许多个读者可以同时对文件执行读操作`；②`只允许一个写者往文件中写信息`；③`任一写者在完成写操作之前不允许其他读者或写者工作`；④`写者执行写操作前，应让已有的读者和写者全部退出`。

![image-20221111141914824](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221111141914824.png)

##### (2）问题分析

有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求：①`允许多个读者可以同时对文件执行读操作`；②`只允许一个写者往文件中写信息`；③`任一写者在完成写操作之前不允许其他读者或写者工作`；④`写者执行写操作前，应让已有的读者和写者全部退出`。

1. 关系分析。找出题目中᧿ 述的各个进程，分析它们之间的同步、互斥关系。

2. 整理思路。根据各进程的操作流程确定P、V操作的大致顺序

3. 设置信号量。设置需要的信号量，并根据题目条件确定信号量初值。（互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少）

两类进程：写进程、读进程

互斥关系：写进程—写进程、写进程—读进程。读进程与读进程不存在互斥问题。

##### (3）实现方法

###### 给count加mutex互斥访问

![image-20221111142054675](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221111142054675.png)

###### 加一个w实现“读写公平法”

- 在上面的算法中，读进程是优先的，即当存在读进程时，写操作将被延迟，且只要有 一个读进程活跃，随后而来的读进程都将被允许访问文件。这样的方式会导致写进程可能长时间等待，且存在写进程`“饿死”`的情况。
- 若希望写进程优先，`即当有读进程正在读共享文件时，有写进程请求访问，这时应禁止后续读进程的请求，等到已在共享文件的读进程执行完毕，立即让写进程执行，只有在无写进程执行的情况下才允许读进程再次运行`。为此，增加一个信号量并在上面程序的writer()和 reader()函数中各增加一对PV操作，就可以得到写进程优先的解决程序。

![image-20221111142149783](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221111142149783.png)

##### (4）知识回顾与重要考点

读者-写者问题为我们解决复杂的互斥问题ᨀ 供了一个参考思路。

其`核心思想`在于设置了一个`计数器 count` 用来记录当前正在访问共享文件的读进程数。我们可以用count 的值来判断当前进入的进程是否是第一个/最后一个读进程，从而做出不同的处理。

另外，对 count 变量的检查和赋值不能一气呵成导致了一些错误，如果`需要实现“一气呵成”，自然应该想到用互斥信号量`。

最后，还要认真体会我们是如何解决“写进程饥饿”问题的。

绝大多数的考研PV操作大题都可以用之前介绍的几种生产者-消费者问题的思想来解决，如果遇到更复杂的问题，可以想想能否用读者写者问题的这几个思想来解决。

#### 4.吸烟者问题

##### (1）问题描述

假设一个系统有`三个抽烟者进程`和`一个供应者进程`。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料：`烟草、纸和胶水`。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者进程无限地ᨀ 供三种材料，`供应者每次将两种材料放桌子上`，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料再桌上，这个过程一直重复（让三个抽烟者轮流地抽烟）

![image-20221111142655466](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221111142655466.png)

##### (2）问题分析

本质上这题也属于“生产者-消费者”问题，更详细的说应该是“可生产多种产品的单生产者-多消费者”。

1. 关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。

2. 整理思路。根据各进程的操作流程确定P、V操作的大致顺序

3. 设置信号量。设置需要的信号量，并根据题目条件确定信号量初值。（互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少）

![image-20221111142932396](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221111142932396.png)

![image-20221111143017889](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221111143017889.png)

##### (3）实现方法

![image-20221111143037221](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221111143037221.png)

##### (4）知识回顾与重要考点

吸烟者问题可以为我们解决“可以生产多个产品的单生产者”问题ᨀ 供一个思路。

值得吸取的精华是：“轮流让各个吸烟者吸烟”必然需要“轮流的在桌上放上组合一、二、三”，注

意体会我们是如何用一个整型变量 i 实现这个“轮流”过程的。

如果题目改为“每次随机地让一个吸烟者吸烟”，我们有应该如何用代码写出这个逻辑呢？

若一个生产者要生产多种产品（或者说会引发多种前驱事件），那么各个V操作应该放在各自对应的

“事件”发生之后的位置。

#### 5.哲学家进餐问题

##### (1）问题描述

一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。

![image-20221111143418038](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221111143418038.png)

##### (2）问题分析

![image-20221111143342316](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221111143342316.png)

##### (3）如何实现

![image-20221111143551016](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221111143551016.png)

![image-20221111143620030](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221111143620030.png)

![image-20221111143641995](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221111143641995.png)

![image-20221111143701062](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221111143701062.png)

![image-20221111143728269](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221111143728269.png)



##### (4）知识回顾与重要考点

哲学家进餐问题的关键在于解决进程死锁。

这些进程之间只存在互斥关系，但是与之前接触到的互斥关系不同的是，每个进程都需要同时持有两个临界资源，因此就有“死锁”问题的隐患。

如果在考试中遇到了一个进程需要同时持有多个临界资源的情况，应该参考哲学家问题的思想，分析题中给出的进程之间是否会发生循环等待，是否会发生死锁。

可以参考哲学家就餐问题解决死锁的三种思路。

### 2.3.7 管程和java中实现管程的机制

![image-20221111104800078](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221111104800078.png)

#### 1.为什么引入管程?

![image-20221111104904221](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221111104904221.png)

#### ⒉管程的组成及基本特征

管程是一种特殊的软件模块，有这些部分组成：

1. 局部于管程的`共享数据结构`说明；

2. 对该数据结构进行操作的`一组过程`；

3. 对局部于管程的共享数据设置初始值的语句；

4. 管程有一个名字。

跨考Tips: “过程”其实就是“函数”

管程的基本特征：

1. 局部于管程的数据只能被局部于管程的过程所访问；

2. 一个进程只有通过调用管程内的过程才能进入管程访问共享数据；

3. `每次仅允许一个进程在管程内执行某个内部过程`。

#### 3.管程实现生产者消费者问题

![image-20221111105056178](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221111105056178.png)

![image-20221111105131023](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221111105131023.png)

![image-20221111105159326](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221111105159326.png)

引入管程的目的无非就是要更方便地实现进程互斥和同步。

1. 需要在管程中定义共享数据（如生产者消费者问题的缓冲区）

2. 需要在管程中定义用于访问这些共享数据的“入口”——其实就是一些函数（如生产者消费者问题中，可以定义一个函数用于将产品放入缓冲区，再定义一个函数用于从缓冲区取出产品）

3. 只有通过这些特定的“入口”才能访问共享数据

4. 管程中有很多“入口”，但是每次只能开放其中一个“入口”，并且只能让一个进程或线程进入（如生产者消费者问题中，各进程需要互斥地访问共享缓冲区。管程的这种特性即可保证一个时间段内最多只会有一个进程在访问缓冲区。注意：这种**互斥特性是由编译器负责实现**的，程序员不用关心）

5. 可在管程中设置条件变量及等待/唤醒操作以解决同步问题。可以让一个进程或线程在条件变量上等待（此时，该进程应先释放管程的使用权，也就是让出“入口”（"封装"思想））；可以通过唤醒操作将等待在条件变量上的进程或线程唤醒。

程序员可以用某种特殊的语法定义一个管程（比如: monitor ProducerConsumer …… end monitor;），之后其他程序员就可以使用这个管程提供的特定“入口”很方便地使用实现进程同步/互斥了。

#### 4.java中类似于管程的机制

Java 中，如果用关键字 synchronized 来描述一个函数，那么这个函数同一时间段内只能被一个线程调用

![image-20221111105442518](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221111105442518.png)

## 2.4 死锁

### 2.4.1 死锁详解(预防、避免、检测、解除)

xmind

#### 1.什么是死锁?

有一首歌的歌词:我爱你，你爱他，他爱她，她爱我.....这世界每个人都爱别人...

我们从资源占有的角度来分析，这段关系为什么看起来那么纠结..

![image-20221114104436162](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114104436162.png)

![image-20221114104509819](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114104509819.png)

#### 2.死锁、饥饿、死循环的区别

死锁:各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象

饥饿:由于长期得不到想要的资源，某进程无法向前推进的现象。比如:在短进程优先（SPF）算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程“饥饿”。

死循环:某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug导致的，有时是程序员故意设计的。

<table>
  	<tr>
		<td></td>
		<td>共同点</td>
        <td>区别</td>
    </tr>
	<tr>
		<td>死锁</td>
		<td rowspan="3">都是进程无法顺利向前推进的现象(故意设计的死循环除外)</td>
        <td>死锁一定是“循环等待对方手里的资源”导致的，因此如果有死锁现象，那<b>至少有两个或两个以上的进程同时发生死锁</b>。另外，发生死锁的进程一定处于阻塞态。</td>
    </tr>
	<tr>
		<td>饥饿</td>
        <td><b>可能只有一个进程发生饥饿</b>。发生饥饿的进程既可能是阻塞态(如长期得不到需要的I/O设备)，也可能是就绪态(长期得不到处理机)
</td>
	</tr>
	<tr>
		<td>死循环</td>
        <td>可能只有一个进程发生死循环。死循环的进程可以上处理机运行（可以是运行态），只不过无法像期待的那样顺利推进。死锁和饥饿问题是由于操作系统分配资源的策略不合理导致的，而死循环是由代码逻辑的错误导致的。<b>死锁和饥饿是管理者（操作系统）的问题，死循环是被管理者的问题</b>。</td>
	</tr>
</table>



![image-20221114110140158](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114110140158.png)

#### 3.死锁产生的四个必要条件

产生死锁必须同时满足一下四个条件，`只要其中任一条件不成立，死锁就不会发生`。

**互斥条件**:只有对必须互斥使用的资源的争抢才会导致死锁（如哲学家的筷子、打印机设备）。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的（因为进程不用阻塞等待这种资源）。

**不剥夺条件**:进程所获得的资源在未使用完之前，**不能由其他进程强行夺走**，只能主动释放。

**请求和保持条件**:进程**已经保持了至少一个资源**，但又提出了新的资源**请求**，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源**保持**不放。

**循环等待条件**:存在一种进程**资源的循环等待链**，链中的每一个进程己获得的资源同时被下一个进程所请求。

![image-20221114110540522](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114110540522.png)

#### 4.什么时候会发生死锁?

1. 对系统资源的竞争。`各进程对不可剥夺的资源（如打印机）的竞争可能引起死锁`对可剥夺的资源（CPU)的竞争是不会引起死锁的。
2. 进程推进顺序非法。`请求和释放资源的顺序不当，也同样会导致死锁`。例如，并发执行的进程P1、P2分别申请并占有了资源R1、R2，之后进程P1又紧接着申请资源R2，而进程P2又申请资源R1，两者会因为申请的资源被对方占有而阻塞，从而发生死锁。
3. 信号量的使用不当也会造成死锁。如生产者-消费者问题中，如果`实现互斥的P操作在实现同步的P操作之前，就有可能导致死锁`。(可以把互斥信号量、同步信号量也看做是一种抽象的系统资源)

总之，`对不可剥夺资源的不合理分配`，可能导致死锁。

#### 5.死锁的处理策略

1. 预防死锁。破坏死锁产生的四个必要条件中的一个或几个。
2. 避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法)
3. 死锁的检测和解除。允许死锁的发生，不过操作系统会负责检测出死锁的发生,然后采取某种措施解除死锁。

##### (1）预防死锁

![image-20221114111909538](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114111909538.png)

###### ①破坏互斥条件

**互斥条件**：只有对必须互斥使用的资源的争抢才会导致死锁。

如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。比如: **SPOOLing技术**。

操作系统可以采用 SPOOLing 技术把独占设备在逻辑上改造成共享设备。比如，用SPOOLing技术将打

印机改造为共享设备…

![image-20221114111437553](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114111437553.png)

该策略的`缺点`：并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方还必须保护这种互斥性。因此，**很多时候都无法破坏互斥条件**。

###### ②破坏不可剥夺条件

**不剥夺条件**：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。

破坏不剥夺条件：

方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时

再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。

方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强

行剥夺。这种方式一般需要考虑各进程的优先级（比如：剥夺调度方式，就是将处理机资源强行剥

夺给优先级更高的进程使用）

该策略的`缺点`：

1. 实现起来比较复杂。

2. 释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般只适用于易保存和恢复状态

的资源，如CPU。

3. 反复地申请和释放资源会增加系统开销，降低系统吞吐量。

4. 若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重

新申请。如果一直发生这样的情况，就会导致进程饥饿。

###### ③破坏请求和保持条件

**请求和保持条件**：进程**已经保持了至少一个资源**，但又提出了新的资源**请求**，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源**保持**不放。

可以**采用静态分配方法**，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了。

该策略实现起来简单，但也有明显的`缺点`：

有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，资源利用率极低。另外，该策略也有可能导致某些进程饥饿。

![image-20221114111711112](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114111711112.png)

###### ④破坏循环等待条件

**循环等待条件**：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。

可采用**顺序资源分配法**。首先给系统中的资源编号，规定每个进程**必须按编号递增的顺序请求资源**，同类资源（即编号相同的资源）一次申请完。

原理分析：一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象。

![image-20221114111755787](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114111755787.png)

该策略的缺点：

1. 不方便增加新的设备，因为可能需要重新分配所有的编号；

2. 进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费；

3. 必须按规定次序申请资源，用户编程麻烦。

##### (2）避免死锁

###### ①什么是安全序列?

![image-20221114140524731](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114140524731.png)

![image-20221114140559013](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114140559013.png)

![image-20221114140629407](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114140629407.png)

![image-20221114140645984](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114140645984.png)

![image-20221114140713685](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114140713685.png)

###### ②安全序列、安全状态、不安全状态、死锁之间的联系

![image-20221114141149153](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114141149153.png)

所谓`安全序列`，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是`安全状态`。当然，`安全序列可能有多个`。

如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了`不安全状态`。这就意味着之后`可能`所有进程都无法顺利的执行下去。当然，如果有进程提前归还了一些资源，那`系统也有可能重新回到安全状态`，不过我们在分配资源之前总是要考虑到最坏的情况。(比如A 先归还了10亿，那么就有安全序列T->B->A)

如果系统处于`安全状态`，就`一定不会`发生`死锁`。如果系统进入`不安全状态`，就`可能`发生`死锁`（`处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态`）

因此可以`在资源分配之前预先判断这次分配是否会导致系统进入不安全状态`，以此决定是否答应资源分配请求。这也是`“银行家算法”`的核心思想

###### ③避免系统进入不安全状态------银行家算法

银行家算法是荷兰学者 Dijkstra 为银行系统设计的，以确保银行在发放现金贷款时，不会发生不能满足所有客户需要的情况。后来该算法被用在操作系统中，用于`避免死锁`。

`核心思想`：在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待。

![image-20221114141525287](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114141525287.png)

![image-20221114141604693](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114141604693.png)

此时系统是否处于安全状态?

思路:尝试找出一个安全序列...

依次检查剩余可用资源(3,3,2)是否能满足各进程的需求

可满足P1需求，将P1加入安全序列，并更新剩余可用资源值为(5,3,2)

![image-20221114141703715](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114141703715.png)

此时系统是否处于安全状态?
思路:尝试找出一个安全序列... {P1}
依次检查剩余可用资源(3,3,2)是否能满足各进程的需求

可满足P1需求，将P1加入安全序列，并更新剩余可用资源值为(5,3,2)
依次检查剩余可用资源(5,3,2)是否能满足剩余进程（不包括已加入安全序列的进程）的需求可满足P3需求，将P3加入安全序列，并更新剩余可用资源值为(7,4,3)

![image-20221114141800147](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114141800147.png)

此时系统是否处于安全状态？

思路：尝试找出一个安全序列…`{P1，P3，P0，P2，P4}`

依次检查剩余可用资源 (3, 3, 2) 是否能满足各进程的需求

可满足P1需求，将 P1 加入安全序列，并更新剩余可用资源值为 (5, 3, 2)

依次检查剩余可用资源 (5, 3, 2) 是否能满足剩余进程（`不包括已加入安全序列的进程`）的需求

可满足P3需求，将 P3 加入安全序列，并更新剩余可用资源值为 (7, 4, 3)

依次检查剩余可用资源 (7, 4, 3) 是否能满足剩余进程（`不包括已加入安全序列的进程`）的需求……

……

以此类推，共五次循环检查即可将5个进程都加入安全序列中，最终可得一个安全序列。该算法称为`安全性算法`。可以很方便地用代码实现以上流程，每一轮检查都从编号较小的进程开始检查。

实际做题时可以更快速的得到安全序列。

![image-20221114141947429](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114141947429.png)

经对比发现，(3,3,2）可满足P1、P3，说明无论如何，这两个进程的资源需求一定是可以依次被满足的，因此p1、P3一定可以顺利的执行完，并归还资源。可把P1、P3先加入安全序列。
(2,0,0)+(2,1,1)+(3,3,2)= (7,4,3)

![image-20221114142331711](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114142331711.png)

经对比发现，（3, 3, 2）可满足 P1、P3，说明无论如何，这两个进程的资源需求一定是可以依次被

满足的，因此P1、P3 一定可以顺利的执行完，并归还资源。 可把 P1、P3 先加入安全序列。

(2, 0, 0) + (2, 1, 1) + (3, 3, 2) = (7, 4, 3)

剩下的 P0、P2、P4 都可被满足。同理，这些进程都可以加入安全序列。

于是，5个进程全部加入安全序列，说明此时系统`处于安全状态`，暂`不可能发生死锁`。

![image-20221114142432508](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114142432508.png)

再看一个找不到安全序列的例子:
经对比发现，(3,3,2）可满足P1、P3，说明无论如何，这两个进程的资源需求一定是可以依次被满足的，因此P1、P3一定可以顺利的执行完，并归还资源。可把P1、P3先加入安全序列。

![image-20221114142523728](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114142523728.png)
经对比发现，(3,3,2）可满足P1、P3，说明无论如何，这两个进程的资源需求一定是可以依次被满足的，因此P1、P3一定可以顺利的执行完，并归还资源。可把P1、P3先加入安全序列。
(2,0,0)+(2,1,1)+(3,3,2)= (7,4,3)
剩下的P0需要(8,4,3)，P2需要(6,5,0)，P4需要(4,3,4)

任何一个进程都不能被完全满足
于是，无法找到任何一个安全序列，说明此时系统处于`不安全状态，有可能发生死锁`。

使用代码实现

![image-20221114142802636](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114142802636.png)

![image-20221114142842343](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114142842343.png)

数据结构：

长度为 m 的一维数组 Available 表示还有多少可用资源

n*m 矩阵 Max 表示各进程对资源的最大需求数

n*m 矩阵 Allocation 表示已经给各进程分配了多少资源

Max – Allocation = Need 矩阵表示各进程最多还需要多少资源

用长度为 m 的一位数组 Request 表示进程此次申请的各种资源数

银行家算法步骤：

①检查此次申请是否超过了之前声明的最大需求数

②检查此时系统剩余的可用资源是否还能满足这次请求

③试探着分配，更改各数据结构

④用安全性算法检查此次分配是否会导致系统进入不安全状态

安全性算法步骤：

检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列，

并把该进程持有的资源全部回收。

不断重复上述过程，看最终是否能让所有进程都加入安全序列。

**系统处于不安全状态未必死锁，但死锁时一定处于不安全状态。系统处于安全状态一定不会死锁.**

##### (3)死锁的检测和解除

![image-20221114144750760](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114144750760.png)

如果系统中既`不采取预防死锁的措施`，也`不采取避免死锁的措施`，系统就很`可能发生死锁`。在这种情况下，系统应当提供两个算法：

①死锁检测算法：用于检测系统状态，以确定系统中是否发生了死锁。

②死锁解除算法：当认定系统中已经发生了死锁，利用该算法可将系统从死锁状态中解脱出来。

###### ①死锁的检测

为了能对系统是否已发生了死锁进行检测，必须：

①用`某种数据结构`来保存资源的请求和分配信息；

②提供`一种算法`，利用上述信息来检测系统是否已进入死锁状态。

![image-20221114143444656](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114143444656.png)

如果系统中剩余的可用资源数足够满足进程的需求，那么这个进程暂时是不会阻塞的，可以顺利地执行下去。

如果这个进程执行结束了把资源归还系统，就可能使某些正在等待资源的进程被激活，并顺利地执行下去。相应的，这些被激活的进程执行完了之后又会归还一些资源，这样可能又会激活另外一些阻塞的进程…

如果按上述过程分析，最终能`消除所有边`，就称这个图是**可完全简化的**。此时一定`没有发生死锁`（相当于能找到一个安全序列）

如果最终`不能消除所有边`，那么此时就是`发生了死锁`

- 举个例子，可以消除所有边，即无死锁发生

![image-20221114144118542](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114144118542.png)



- 举个例子，不可消除所有边，即产生死锁

![image-20221114144352214](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114144352214.png)

检测死锁的算法：

1）在资源分配图中，找出既不阻塞又不是孤点的进程 Pi（即找出一条有向边与它相连，且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量。如下图中，R1没有空闲资源，R2有一个空闲资源。若所有的连接该进程的边均满足上述条件，则这个进程能继续运行直至完成，然后释放它所占有的所有资源）。消去它所有的请求边和分配变，使之称为孤立的结点。在下图中，P1 是满足这一条件的进程结点，于是将P1的所有边消去。

2）进程 Pi 所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。在下图中，P2 就满足这样的条件。根据 1）中的方法进行一系列简化后，若能消去途中所有的边，则称该图是`可完全简化的`。

![image-20221114144508178](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114144508178.png)

`死锁定理`：如果某时刻系统的资源分配图是`不可完全简化的`，那么此时系统`死锁`

###### ②死锁的解除

一旦检测出死锁的发生，就应该立即解除死锁。

补充：并不是系统中所有的进程都是死锁状态，用死锁检测算法`化简资源分配图后，还连着边的那些进程就是死锁进程`

解除死锁的主要方法有：

1. 资源剥夺法。挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。

2. 撤销进程法（或称终止进程法）。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行

了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。

3. 进程回退法。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点。

![image-20221114144637821](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114144637821.png)