---
title: 文件管理
date: 2020-05-11 13:54:56
permalink: /pages/2f674a
article: false
---

# 第 4 章 文件管理

## 4.1 文件系统

### 4.1.1 初识文件管理概念和功能

![image-20221117134329793](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221117134329793.png)

![image-20221117134343604](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221117134343604.png)

#### 1.文件的属性

![image-20221117134629849](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221117134629849.png)

一个文件有哪些属性？

`文件名`：由创建文件的用户决定文件名，主要是为了方便用户找到文件，`同一目录下不允许有重名文件`。

`标识符`：一个系统内的各文件标识符唯一，对用户来说毫无可读性，因此标识符只是操作系统用于区分

各个文件的一种内部名称。

`类型`：指明文件的类型

`位置`：文件存放的路径（让用户使用）、在外存中的地址（操作系统使用，对用户不可见）大小：指明文件大小

`创建时间`、`上次修改时间`

`文件所有者信息`

`保护信息`：对文件进行保护的访问

控制信息

#### 2.文件内部的数据如何组织起来?

![image-20221117134843104](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221117134843104.png)

![image-20221117134854636](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221117134854636.png)

#### 3.文件之间应该如何组织起来?

![image-20221117134920399](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221117134920399.png)

#### 4.操作系统应该向上提供哪些功能?

![image-20221117134944954](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221117134944954.png)

![image-20221117135020453](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221117135020453.png)

#### 5.从上往下看，文件应该如何存放在外存?

![image-20221117135054737](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221117135054737.png)

![image-20221117135140125](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221117135140125.png)

#### 6.其他需要由操作系统实现的文件管理功能

![image-20221117135201262](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221117135201262.png)

### 4.1.2 文件逻辑结构（顺序文件、索引文件、索引顺序文件、多级索引顺序文件）关于数据库的索引如聚簇索引可以看一下索引文件例题的解析，感觉还是可以收获到东西的

![image-20221117135315017](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221117135315017.png)

类似于数据结构的“逻辑结构”和“物理结构”。

如“线性表”就是一种逻辑结构，在用户角度看来，线性表就是一组有先后关系的元素序列，如：a,b, c, d, e ……

“线性表”这种逻辑结构可以用不同的物理结构实现，如：顺序表/链表。顺序表的各个元素在逻辑上相邻，在物理上也相邻；而链表的各个元素在物理上可以是不相邻的。因此，顺序表可以实现“随机访问”，而“链表”无法实现随机访问。

可见，算法的具体实现与逻辑结构、物理结构都有关（文件也一样，文件操作的具体实现与文件的逻

辑结构、物理结构都有关）

![image-20221117135412702](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221117135412702.png)

#### 1.无结构文件

按文件是否有结构分类，可以分为无结构文件、有结构文件两种。

`无结构文件`：文件内部的数据就是一系列二进制流或字符流组成。又称“`流式文件`”。如：

Windows 操作系统中的 .txt 文件。

![image-20221117135607609](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221117135607609.png)

#### 2有结构文件

按文件是否有结构分类，可以分为无结构文件、有结构文件两种。

`无结构文件`：文件内部的数据就是一系列二进制流或字符流组成。又称“`流式文件`”。如：

Windows 操作系统中的 .txt 文件。

`有结构文件`：由一组相似的记录组成，又称“`记录式文件`”。每条记录又若干个数据项组成。如：

数据库表文件。一般来说，每条记录有一个数据项可作为`关键字`（作为识别不同记录的ID）

![image-20221117135653440](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221117135653440.png)

`有结构文件`：由一组相似的记录组成，又称“`记录式文件`”。每条记录又若干个数据项组成。如：数据库表文件。一般来说，每条记录有一个数据项可作为`关键字`。根据各条记录的长度（占用的存储空间）是否相等，又可分为`定长记录`和`可变长记录`两种。

**定长记录：**

![image-20221117140028118](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221117140028118.png)

**可变长记录：**

![image-20221117140042004](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221117140042004.png)

##### 有结构文件的逻辑结构

![image-20221117140122338](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221117140122338.png)

##### 顺序文件

`顺序文件`：文件中的记录一个接一个地顺序排列（逻辑上），记录可以是`定长`的或`可变长`的。各个记录在物理上可以`顺序存储`或`链式存储`。

![image-20221117140226705](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221117140226705.png)

![image-20221117140252571](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221117140252571.png)

##### 索引文件

不经意间让我想起了数据库的索引，聚簇索引和唯一索引等，有了更进一步的理解，而且知道了它的时间空间效率。

![image-20221117140426661](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221117140426661.png)

##### 索引顺序文件

![image-20221117140627413](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221117140627413.png)

![image-20221117140647430](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221117140647430.png)

若一个`顺序文件`有10000个记录，则根据关键字检索文件，只能从头开始顺序查找（这里指的并不是定长记录、顺序结构 的顺序文件），`平均须查找 5000 个记录`。

若采用`索引顺序文件`结构，可把 10000 个记录分为 √10000 = 100 组，每组 100 个记录。则需要先顺序查找索引表找到分组（共100个分组，因此索引表长度为 100，平均需要查 50 次），找到分组后，再在分组中顺序查找记录（每个分组100 个记录，因此平均需要查 50 次）。可见，采用索引顺序文件结构后，`平均查找次数减少为 50+50 = 100 次`。

同理，若文件共有 106个记录，则可分为 1000 个分组，每个分组 1000 个记录。根据关键字检索一个记录平均需要查找 500+500 = 1000 次。这个`查找次数依然很多`，如何解决呢？

##### 多级索引顺序文件

为了进一步提高检索效率，可以为顺序文件`建立多级索引表`。例如，对于一个含 106个记录的文件，可先为该文件建立一张低级索引表，每 100 个记录为一组，故低级索引表中共有 10000 个表项（即10000个定长记录），再把这 10000 个定长记录分组，每组100个，为其建立顶级索引表，故顶级索引表中共有 100 个表项。

![image-20221117140925215](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221117140925215.png)

Tips: 要为 N 个记录的文件建立 K 级索引，则最优的分组是每组 N1/(K+1)个记录。

检索一个记录的平均查找次数是 ((N1/(K+1) )/2) *	(K+1)

如：本例中，建立 2级索引，则最优分组为每组1000001/3 = 100 个记录，平均查找次数是 (100/2) *3 = 150 次

### 4.1.3 文件目录结构（单级-两级-多级-无环图）、索引节点FCB瘦身

![image-20221121134937734](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121134937734.png)

![image-20221121135003028](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121135003028.png)

#### 1.文件控制块

![image-20221121135219754](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121135219754.png)

当我们双击“照片”后，操作系统会在这个目录表中找到关键字“照片”对应的目录项（也就是记录），然后从外存中将“照片”目录的信息读入内存，于是，“照片”目录中的内容就可以显示出来了。

![image-20221121135307347](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121135307347.png)

##### 对目录的操作

![image-20221121135341945](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121135341945.png)

需要对目录进行哪些操作？

`搜索`：当用户要使用一个文件时，系统要根据文件名搜索目录，找到该文件对应的目录项

`创建文件`：创建一个新文件时，需要在其所属的目录中增加一个目录项

`删除文件`：当删除一个文件时，需要在目录中删除相应的目录项

`显示目录`：用户可以请求显示目录的内容，如显示该目录中的所有文件及相应属性

`修改目录`：某些文件属性保存在目录中，因此这些属性变化时需要修改相应的目录项（如：文件重命名）

#### 2.单级目录结构

早期操作系统并不支持多级目录，整个系统中只建立一张目录表，每个文件占一个目录项。

![image-20221121135525083](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121135525083.png)

单级目录实现了“按名存取”，但是`不允许文件重名`。

在创建一个文件时，需要先检查目录表中有没有重名文件，确定不重名后才能允许建立文件，并将新文件对应的目录项插入目录表中。

显然，单级目录结构不适用于多用户操作系统。

#### 3.两级目录结构

早期的多用户操作系统，采用两级目录结构。分为`主文件目录`（MFD，Master File Directory）和`用户文件目录`（UFD，User Flie Directory）。

![image-20221121135701814](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121135701814.png)

#### 4.多级目录结构(树形目录结构)

![image-20221121135719465](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121135719465.png)

用户（或用户进程）要访问某个文件时要用文件路径名标识文件，文件路径名是个字符串。各级目录之间用“

/”隔开。`从根目录出发`的路径称为`绝对路径`。

例如：`自拍.jpg 的绝对路径是 “/照片/2015-08/自拍.jpg”`

系统根据绝对路径一层一层地找到下一级目录。刚开始`从外存读入根目录的目录表`；找到“照片”目录的存放位置后，`从外存读入对应的目录表`；再找到“2015-08”目录的存放位置，再从外存读入对应目录表；最后才找到文件“自拍.jpg”的存放位置。整个过程`需要3次读磁盘I/O操作`。

很多时候，用户会连续访问同一目录内的多个文件（比如：接连查看“2015-08”目录内的多个照片文件），显然，每次都从根目录开始查找，是很低效的。因此可以设置一个“`当前目录`”。

例如，此时已经打开了“照片”的目录文件，也就是说，这张目录表已调入内存，那么可以把它设置为“当前目录”。当用户想要访问某个文件时，可以使用`从当前目录出发`的“`相对路径`” 。

在 Linux 中，“.”表示当前目录，因此如果“照片”是当前目录，则”自拍.jpg”`的相对路径为`：“`./2015-08/自拍.jpg`”。从当前路径出发，只需要查询内存中的“照片”目录表，即可知道”2015-08”目录表的存放位置，从外存调入该目录，即可知道“自拍.jpg”存放的位置了。

可见，引入“`当前目录`”和“`相对路径`”后，磁盘I/O的次数减少了。这就ᨀ 升了访问文件的效率。

**无环图目录结构解决文件共享**

`树形目录结构`可以很方便地对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护。但是，树形结构`不便于实现文件的共享`。为此，提出了“`无环图目录结构`”。

#### 5.无环图目录结构

![image-20221121140422121](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121140422121.png)

`可以用不同的文件名指向同一个文件`，甚至可以指向同一个目录（共享同一目录下的所有内容）。

需要为`每个共享结点设置一个共享计数器`，用于记录此时有多少个地方在共享该结点。用户提出删除结点的请求时，只是删除该用户的FCB、并使`共享计数器减1`，并不会直接删除共享结点。`只有共享计数器减为0时，才删除结点`。

注意：共享文件不同于复制文件。在`共享文件中，由于各用户指向的是同一个文件，因此只要其中一个用户修改了文件数据，那么所有用户都可以看到文件数据的变化`。

#### 6.索引节点(FCB的改进)瘦身

![image-20221121140723383](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121140723383.png)

思考有何好处？

假设一个FCB是64B，磁盘块的大小为1KB，则每个盘块中只能存放16个FCB。若一个文件目录中共有640个目录项，则共需要占用640/16 = 40 个盘块。因此按照某文件名检索该目录，`平均需要查询320 个目录项，平均需要启动磁盘20次（每次磁盘I/O读入一块）`。

若`使用索引结点机制`，文件名占14B，索引结点指针站2B，则每个盘块可存放64个目录项，那么按文件名检索目录`平均只需要读入 320/64 = 5 个磁盘块`。显然，这`将大大提升文件检索速度`。

![image-20221121140924306](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121140924306.png)

当找到文件名对应的目录项时，才需要将索引结点调入内存，索引结点中记录了文件的各种信息，包括文件在外存中的存放位置，根据“存放位置”即可找到文件。

存放`在外存中`的索引结点称为“`磁盘索引结点`”，当索引结点`放入内存`后称为“`内存索引结点`”。

相比之下`内存索引结点中需要增加一些信息，`比如：文件是否被修改、此时有几个进程正在访问该文件等。

### 4.1.4 文件的物理结构(连续分配、链接分配[隐式-显式]、索引分配[链接方案-多层索引-混合索引])

![image-20221121141326867](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121141326867.png)

![image-20221121141344676](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121141344676.png)

#### 1.文件块、磁盘块

![image-20221121141945578](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121141945578.png)

在内存管理中，进程的逻辑地址空间被分为一个一个页面同样的，在外存管理中，为了方便对文件数据的管理，`文件的逻辑地址空间也被分为了一个一个的文件“块”`。

于是文件的逻辑地址也可以表示为（`逻辑块号`，`块内地址`）的形式。

![image-20221121142046650](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121142046650.png)

#### 2.连续分配

`连续分配`方式要求`每个文件在磁盘上占有一组连续的块`。

![image-20221121142339104](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121142339104.png)

读取某个磁盘块时，需要移动磁头。访问的两个磁盘块相隔越远，移动磁头所需时间就越长。

结论：`连续分配的文件在顺序读/写时速度最快`

![image-20221121142459626](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121142459626.png)

若此时文件A要拓展，需要再增加一个磁盘块（总共需要连续的4个磁盘块）。由于采用连续结构，因此文件A占用的磁盘块必须是连续的。因此只能将文件A全部“迁移”到绿色区域。

结论：物理上采用`连续分配的文件不方便拓展`。

![image-20221121142543041](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121142543041.png)

结论：物理上采用`连续分配，存储空间利用率低，会产生难以利用的磁盘碎片`可以用`紧凑`来处理碎片，但是需要耗费很大的时间代价。

`优点`：支持顺序访问和直接访问（即随机访问）；连续分配的文件在顺序访问时速度最快

`缺点`：不方便文件拓展；存储空间利用率低，会产生磁盘碎片

#### 3.链接分配

`链接分配`采取离散分配的方式，可以为文件分配离散的磁盘块。分为`隐式链接`和`显式链接`两种。

##### 隐式链接

![image-20221121142846195](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121142846195.png)

用户给出要访问的逻辑块号 i，操作系统找到该文件对应的目录项（FCB）…

从目录项中找到起始块号（即0号块），将0号逻辑块读入内存，由此知道1号逻辑块存放的物理块号，于是读入1号逻辑块，再找到2号逻辑块的存放位置……以此类推。因此，读入i号逻辑块，总共需要 i+1 次磁盘I/O。

结论：采用`链式分配（隐式链接）`方式的文件，`只支持顺序访问，不支持随机访问`，查找效率低。另外，指向下一个盘块的指针也需要耗费少量的存储空间。

![image-20221121142959933](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121142959933.png)

结论：采用隐式链接的`链接分配方式，很方便文件拓展`。另外，所有的空闲磁盘块都可以被利用，`不会有碎片问题，外存利用率高`。

隐式链接——除文件的最后一个盘块之外，每个盘块中都存有指向下一个盘块的指针。文件目录

包括文件第一块的指针和最后一块的指针。

优点：很方便文件拓展，不会有碎片问题，外存利用率高。

缺点：只支持顺序访问，不支持随机访问，查找效率低，指向下一个盘块的指针也需要耗费少量

的存储空间。

##### 显式链接

![image-20221121143226935](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121143226935.png)

假设某个新创建的文件“aaa”依次存放在磁盘块 2 ->5->0->1

假设某个新创建的文件“bbb”依次存放在磁盘块 4 ->23->3

`注意：一个磁盘仅设置一张FAT。开机时，将FAT读入内存，并常驻内存`。 FAT 的各个表项在物理上连续存储，且每一个表项长度相同，因此“物理块号”字段可以是隐含的。

![image-20221121143354219](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121143354219.png)

如何实现文件的逻辑块号到物理块号的转变？

用户给出要访问的逻辑块号 i，操作系统找到该文件对应的目录项（FCB）…

从目录项中找到起始块号，若i>0，则查询内存中的文件分配表FAT，往后找到 i 号逻辑块对应的物理块号。`逻辑块号转换成物理块号的过程不需要读磁盘操作`。

结论：采用`链式分配（显式链接）`方式的文件，支持顺序访问，也`支持随机访问（想访问 i 号逻辑块时，并不需要依次访问之前的 0 ~ i-1号逻辑块）`，由于块号转换的过程不需要访问磁盘，因此相比于隐式链接来说，访问速度快很多。

显然，显式链接也`不会产生外部碎片，也可以很方便地对文件进行拓展`。

##### 链接分配总结

`链接分配`采取离散分配的方式，可以为文件分配离散的磁盘块。分为`隐式链接`和`显式链接`两种。

**隐式链接**——除文件的最后一个盘块之外，每个盘块中都存有指向下一个盘块的指针。文件目录包括文件第一块的指针和最后一块的指针。

`优点`：很方便文件拓展，不会有碎片问题，外存利用率高。

`缺点`：只支持顺序访问，不支持随机访问，查找效率低，指向下一个盘块的指针也需要耗费少量的存储空间。

**显式链接**——把用于链接文件各物理块的指针显式地存放在一张表中，即 `文件分配表`（`FAT`，FileAllocation Table）。一个磁盘只会建立一张文件分配表。开机时文件分配表放入内存，并`常驻内存`。

`优点`：很方便文件拓展，不会有碎片问题，外存利用率高，并且`支持随机访问`。相比于隐式链接来说，`地址转换时不需要访问磁盘，因此文件的访问效率更高`。

`缺点`：文件分配表的需要占用一定的存储空间。

#### 4.索引分配

`索引分配`允许文件离散地分配在各个磁盘块中，系统会`为每个文件建立一张索引表`，索引表中`记录了文件的各个逻辑块对应的物理块`（索引表的功能类似于内存管理中的页表——建立逻辑页面到物理页之间的映射关系）。索引表存放的磁盘块称为`索引块`。文件数据存放的磁盘块称为`数据块`。

![image-20221121143835273](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121143835273.png)

假设某个新创建的文件“aaa”的数据依次存放在磁盘块 2 ->5->13->9 。7号磁盘块作为“aaa”的索引块，索引块中保存了索引表的内容。

注：在显式链接的链式分配方式中，文件分配表FAT 是一个磁盘对应一张。而索引分配方式中，索引表是一个文件对应一张。

可以用固定的长度表示物理块号（如：假设磁盘总容量为1TB=2^40B，磁盘块大小为1KB，则共有 230个磁盘块，则可用4B 表示磁盘块号），因此，索引表中的“逻辑块号”可以是隐含的。

**如何实现逻辑块号到物理块号的转换？**

![image-20221121144052480](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121144052480.png)

用户给出要访问的逻辑块号 i，操作系统找到该文件对应的目录项（FCB）…

从目录项中可知索引表存放位置，将索引表从外存读入内存，并查找索引表即可只 i 号逻辑块在外存中的存放位置。

可见，`索引分配方式可以支持随机访问`。`文件拓展也很容易实现`（只需要给文件分配一个空闲块，并增加一个索引表项即可）但是`索引表需要占用一定的存储空间`

**数据太大，一个索引表装不下那么多的映射怎么办？**

![image-20221121144302060](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121144302060.png)

##### 链接方案

①`链接方案`：如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放。

![image-20221121144357345](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121144357345.png)

假设磁盘块大小为1KB，一个索引表项占4B，则一个磁盘块只能存放256个索引项。

若一个文件大小为 `256*256KB =65,536 KB = 64MB`

该文件共有 `256*256` 个块，也就对应`256*256`个索引项，也就需要 256 个索引块来存储，这些索引块用链接方案连起来。

若想要访问文件的最后一个逻辑块，就必须找到最后一个索引块（第256个索引块），而各个索引块之间是用指针链接起来的，因此必须先顺序地读入前 255 个索引块。

这显然是很低效的。如何解决呢？

##### 多层索引

②`多层索引`：建立多层索引（`原理类似于多级页表`）。使第一层索引块指向第二层的索引块。还可根据文件大小的要求再建立第三层、第四层索引块。

![image-20221121144718661](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121144718661.png)

假设磁盘块大小为1KB，一个索引表项占4B，则一个磁盘块只能存放256 个索引项。

若某文件采用两层索引，则该文件的最大长度可以到`256*256*1KB = 65,536 KB = 64MB`

可根据逻辑块号算出应该查找索引表中的哪个表项。

如：要访问 1026 号逻辑块，则1026/256 = 4，1026%256 = 2

因此可以先将一级索引表调入内存，查询 4 号表项，将其对应的二级索引表调入内存，再查询二级索引表的2号表项即可知道 1026 号逻辑块存放的磁盘块号了。

`访问目标数据块，需要3次磁盘I/O`。(采用 K 层索引结构，且`顶级索引表未调入内存`，则访问一个数据块只需要 K + 1 次读磁盘操作)

若采用三层索引，则文件的最大长度为`256*256*256*1KB = 16GB`类似的，`访问目标数据块，需要4次磁盘I/O`

##### 混合索引

③`混合索引`：多种索引分配方式的结合。例如，一个文件的顶级索引表中，既包含`直接地址索引`（直接指向`数据块`），又包含`一级间接索引`（指向单层索引表）、还包含`两级间接索引`（指向两层索引表） 。

![image-20221121144921882](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121144921882.png)

这种结构的索引支持的最大文件长度为65800KB

##### 索引分配总结

`索引分配`允许文件离散地分配在各个磁盘块中，系统会`为每个文件建立一张索引表`，索引表中`记录了文件的各个逻辑块对应的物理块`（索引表的功能类似于内存管理中的页表——建立逻辑页面到物理页之间的映射关系） 。索引表存放的磁盘块称为`索引块`。文件数据存放的磁盘块称为`数据块`。

若文件太大，索引表项太多，可以采取以下三种方法解决：

①`链接方案`：如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放。缺点：若文件很大，索引表很长，就需要将很多个索引块链接起来。想要找到 i 号索引块，必须先依次读入 0~i-1号索引块，这就导致磁盘I/O次数过多，查找效率低下。

②`多层索引`：建立多层索引（`原理类似于多级页表`）。使第一层索引块指向第二层的索引块。还可根据文件大小的要求再建立第三层、第四层索引块。采用 K 层索引结构，且`顶级索引表未调入内存`，则访问一个数据块只需要 K + 1 次读磁盘操作。`缺点`：即使是小文件，访问一个数据块依然需要K+1次读磁盘。

③`混合索引`：多种索引分配方式的结合。例如，一个文件的顶级索引表中，既包含`直接地址索引`（直接指向数据块），又包含`一级间接索引`（指向单层索引表）、还包含`两级间接索引`（指向两层索引表） 。优点：对于小文件来说，访问一个数据块所需的读磁盘次数更少。

**超级超级超级重要考点**：①要会根据多层索引、混合索引的结构计算出文件的最大长度（`Key`：各级索引表最大不能超过一个块）；②要能自己分析访问某个数据块所需要的读磁盘次数（`Key`：FCB中会存有指向顶级索引块的指针，因此可以根据FCB读入顶级索引块。每次读入下一级的索引块都需要一次读磁盘操作。另外，要`注意题目条件——顶级索引块是否已调入内存`）

#### 5.文件物理结构分配总结

![image-20221121145417788](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121145417788.png)

![image-20221121145442936](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121145442936.png)

### 4.1.5 文件管理空闲磁盘块的几种算法(空闲表法、空闲链表法、位示图法、成组链接法)

![image-20221121152110084](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121152110084.png)

![image-20221121152133314](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121152133314.png)

![image-20221121152213379](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121152213379.png)

#### 1.存储空间的划分与初始化

![image-20221121153339915](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121153339915.png)

#### 2.空闲表法

**如何分配？**

![image-20221121153503239](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121153503239.png)

![image-20221121153533541](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121153533541.png)

**如何回收？**

![image-20221121153607056](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121153607056.png)

![image-20221121153635776](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121153635776.png)

#### 3.空闲链表法

![image-20221121153704068](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121153704068.png)

##### 空闲盘块链

![image-20221121153740091](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121153740091.png)

##### 空闲盘区链

![image-20221121154012986](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121154012986.png)

#### 4.位示图法

![image-20221121154117883](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121154117883.png)

**如何分配与回收？**

![image-20221121154158352](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121154158352.png)

#### 5.成组链接法

![image-20221121154244556](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121154244556.png)

**超级块的作用**

![image-20221121154318019](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121154318019.png)

**如何分配？**
**需要1个空闲磁盘块**

![image-20221121154405629](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121154405629.png)

![image-20221121154436024](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121154436024.png)

**需要100个空心啊磁盘块**

![image-20221121154522966](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121154522966.png)

![image-20221121154553977](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121154553977.png)

**如何回收？**

![image-20221121154642629](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121154642629.png)

![image-20221121154716532](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121154716532.png)

**第二种情况，第一组已满**

![image-20221121154809239](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121154809239.png)

![image-20221121154838633](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121154838633.png)

### 4.1.6 文件的基本操作原理(创建、删除、打开、关闭、读-写)

![image-20221121155115827](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121155115827.png)

![image-20221121155130870](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121155130870.png)

#### 1.创建文件

![image-20221121155253586](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121155253586.png)

#### 2.删除文件

![image-20221121155318307](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121155318307.png)

#### 3.打开文件

![image-20221121155348671](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121155348671.png)

**打开文件表有两种：**

![image-20221121155424369](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121155424369.png)

#### 4.关闭文件

![image-20221121155445565](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121155445565.png)

#### 5.读文件

![image-20221121155516462](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121155516462.png)

#### 6.写文件

![image-20221121155541519](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121155541519.png)

### 4.1.7 文件共享（索引节点-硬链接、符号链接-软链接）

![image-20221121155828457](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121155828457.png)

`注意`:多个用户共享同一个文件，意味着系统中只有“一份”文件数据。并且只要某个用户修改了该文件的数据，其他用户也可以看到文件数据的变化。

如果是多个用户都“复制”了同一个文件，那么系统中会有“好几份”文件数据。其中一个用户修改了自己的那份文件数据，对其他用户的文件数据并没有影响。

![image-20221121155933883](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121155933883.png)

#### 1.基于索引结点的共享方式（硬链接)

知识回顾:索引结点，是一种文件目录瘦身策略。由于检索文件时只需用到文件名，因此可以将除了文件名之外的其他信息放到索引结点中。这样目录项就只需要包含文件名、索引结点指针。

![image-20221121160118731](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121160118731.png)

索引结点中设置一个链接计数变量count，用于表示链接到本索引结点上的用户目录项数。

若count =2，说明此时有两个用户目录项链接到该索引结点上，或者说是有两个用户在共享此文件。若某个用户决定“删除”该文件，则只是要把用户目录中与该文件对应的目录项删除，且索引结点的count值减1。

若count>0，说明还有别的用户要使用该文件，暂时不能把文件数据删除，否则会导致指针悬空。当count = 0时系统负责删除文件。

#### 2.基于符号链的共享方式(软链接)

![image-20221121160156867](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121160156867.png)

当User3访问“ccc”时，操作系统判断文件“ccc”属于Link类型文件，于是会根据其中记录的路径层层查找目录，最终找到User1的目录表中的“aaa”表项，于是就找到了文件1的索引结点。

**例子**

![image-20221121160303256](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121160303256.png)

![image-20221121160359167](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121160359167.png)

**共享的文件不存在时**

![image-20221121160544379](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121160544379.png)

![image-20221121160621186](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121160621186.png)

当user3访问“ccc”时，操作系统判断文件“ccc”属于Link类型文件，于是会根据其中记录的路径层层查找目录，最终找到User1的目录表中的“aaa”表项，于是就找到了文件1的索引结点。

**举例：**

![image-20221121160721715](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121160721715.png)

### 4.1.8 文件保护（口令保护、加密保护、访问控制）

![image-20221121161017361](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121161017361.png)

#### 1.口令保护

![image-20221121161118899](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121161118899.png)

优点:保存口令的空间开销不多，验证口令的时间开销也很小。

缺点:正确的“口令”存放在系统内部，不够安全。

#### 2.加密保护

使用某个“密码”对文件进行加密，在访问文件时需要提供正确的“密码”才能对文件进行正确的解密。、

Eg:一个最简单的加密算法―一异或加密
假设用于加密/解密的“`密码`”为“`01001`”

![image-20221121161223003](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121161223003.png)

![image-20221121161313947](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121161313947.png)

优点:保密性强，不需要在系统中存储“密码”

缺点:编码/译码，或者说加密/解密要花费一定时间。

#### 3.访问控制

在每个文件的FCB（或索引结点）中增加一个`访问控制列表`(Access-Control List,ACL)，该表中记录了各个用户可以对该文件执行哪些操作。

![image-20221121161354430](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121161354430.png)

![image-20221121161419548](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121161419548.png)

##### windows的访问控制

![image-20221121161450364](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121161450364.png)

![image-20221121161505334](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121161505334.png)

![image-20221121161518448](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121161518448.png)



![image-20221121161531161](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121161531161.png)

![image-20221121161546617](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121161546617.png)

### 4.1.9 文件系统的层次结构

![image-20221121162010339](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221121162010339.png)

用一个例子来辅助记忆文件系统的层次结构:
假设某用户请求删除文件“D:/工作目录/学生信息xlsx”的最后100条记录。

1. 用户需要通过操作系统提供的接口发出上述请求―`用户接口`
2. 由于用户提供的是文件的存放路径，因此需要操作系统一层一层地查找目录，找到对应的目录项――`文件目录系统`
3. 不同的用户对文件有不同的操作权限，因此为了保证安全，需要检查用户是否有访问权限-`存取控制模块（存取控制验证层)`
4. 验证了用户的访问权限之后，需要把用户提供的“记录号”转变为对应的逻辑地址――`逻辑文件系统与文件信息缓冲区`
5. 知道了目标记录对应的逻辑地址后，还需要转换成实际的物理地址――`物理文件系统`
6. 要删除这条记录，必定要对磁盘设备发出请求――`设备管理程序模块`
7. 删除这些记录后，会有一些盘块空闲，因此要将这些空闲盘块回收――`辅助分配模块`

## 4.2 磁盘组织与管理

### 4.2.1 磁盘的结构（磁盘、磁道、扇区、盘面、柱面、磁头）

![image-20221122095548365](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122095548365.png)

#### 1.磁盘、磁道、扇区

![image-20221122095727399](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122095727399.png)

#### 2.如何在磁盘中读/写数据

![image-20221122095806756](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122095806756.png)

#### 3.盘面、柱面

![image-20221122095947980](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122095947980.png)

可用(`柱面号，盘面号，扇区号`)来定位任意一个“磁盘块”。在“文件的物理结构”小节中，我们经常提到文件数据存放在外存中的几号块，这个块号就可以转换成（柱面号，盘面号，扇区号)的地址形式。

可根据该地址读取一个“块”
①根据“柱面号”移动磁臂，让磁头指向指定柱面;
②激活指定盘面对应的磁头;
③磁盘旋转的过程中，指定的扇区会从磁头下面划过，这样就完成了对指定扇区的读/写。

#### 4.磁盘的分类

##### 按磁头是否可移动分类

![image-20221122100125334](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122100125334.png)

##### 按盘片是否可更换分类

![image-20221122100138370](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122100138370.png)

### 4.2.2 磁盘调度算法（FCFS、SSTF、SCAN、LOOK、S-SCAN、C-LOOK）

![image-20221122100248814](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122100248814.png)

![image-20221122100308876](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122100308876.png)

#### 1.—次磁盘读/写操作需要的时间

![image-20221122100442950](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122100442950.png)

![image-20221122100545640](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122100545640.png)

![image-20221122100600116](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122100600116.png)

#### 2.先来先服务(FCFS)

根据进程请求访问磁盘的先后顺序进行调度。

假设磁头的初始位置是100号磁道，有多个进程先后陆续地请求访问55、58、39、18、90、160、150、38、184号磁道

按照FCFS 的规则，按照请求到达的顺序，磁头需要依次移动到55、58、39、18、90、160、150、38、184号磁道

![image-20221122100734572](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122100734572.png)

磁头总共移动了45+3+19+21+72+70+10+112+146= 498个磁道

响应一个请求平均需要移动498/9 = 55.3个磁道（平均寻找长度)

优点:公平;如果请求访问的磁道比较集中的话，算法性能还算过的去

缺点:如果有大量进程竞争使用磁盘，请求访问的磁道很分散，则FCFS在性能上很差，寻道时间长。

#### 3.最短寻找时间优先算法(SSTF)

SSTF算法会优先处理的磁道是与当前磁头最近的磁道。可以保证每次的寻道时间最短，但是并不能保证总的寻道时间最短。(其实就是贪心算法的思想，只是选择眼前最优，但是总体未必最优)

假设磁头的初始位置是100号磁道，有多个进程先后陆续地请求访问55、58、39、18、90、160、150、38、184号磁道

![image-20221122100945272](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122100945272.png)

磁头总共移动了(100-18)+(184-18)= 248个磁道
响应一个请求平均需要移动248/9= 27.5个磁道（平均寻找长度)

优点:性能较好，平均寻道时间短
缺点:`可能产生"饥饿"`现象

Eg:本例中，如果在处理18号磁道的访问请求时又来了一个38号磁道的访问请求(产生饥饿的原因在于:磁头在一个小区域内来回来去地移动)，处理38号磁道的访问请求时又来了一个18号磁道的访问请求。如果有源源不断的18号、38号磁道的访问请求到来的话，150、160、184号磁道的访问请求就永远得不到满足，从而产生“饥饿”现象。

#### 4.扫描算法(SCAN)

SSTF 算法会产生饥饿的原因在于:磁头有可能在一个小区域内来回来去地移动。为了防止这个问题，可以规定，`只有磁头移动到最外侧磁道的时候才能往内移动`，移动到最内侧磁道的时候才能往外移动。这就是`扫描算法(SCAN)`的思想。由于磁头移动的方式很像电梯，因此也叫`电梯算法`。

假设某磁盘的磁道为0~200号，磁头的初始位置是100号磁道，且此时磁头正在往磁道号增大的方向移动，有多个进程先后陆续地请求访问55、58、39、18、90、160、150、38、184号磁道

![image-20221122101416204](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122101416204.png)

磁头总共移动了(200-100)+(200-18)= 282个磁道
响应一个请求平均需要移动282/9=31.3个磁道（平均寻找长度)

优点:性能较好，平均寻道时间较短，`不会产生饥饿现象`

缺点:
1.只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了。
2.SCAN算法对于各个位置磁道的响应频率不平均(如:假设此时磁头正在往右移动，且刚处理过90号磁道，那么下次处理90号磁道的请求就需要等磁头移动很长一段距离;而响应了184号磁道的请求之后，很快又可以再次响应184号磁道的请求了)

#### 5.LOOK算法

`扫描算法(SCAN)`中，只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了。`LOOK调度算法`就是为了解决这个问题，`如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向`。(边移动边观察，因此叫LOOK)

假设某磁盘的磁道为0~200号，磁头的初始位置是100号磁道，且`此时磁头正在往磁道号增大的方向移动`，有多个进程先后陆续地请求访问55、58、39、18、90、160、150、38、184号磁道

![image-20221122101810331](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122101810331.png)

磁头总共移动了(184-100)+ (184-18)= 250个磁道
响应一个请求平均需要移动250/9 = 27.5个磁道（平均寻找长度)

优点:比起SCAN算法来，不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时间进一步缩短

#### 6.循环扫描算法(S-SCAN)

SCAN算法对于各个位置磁道的响应频率不平均，而`C-SCAN算法`就是为了解决这个问题。规定只有磁头朝某个特定方向移动时才处理磁道访问请求，而`返回时直接快速移动至起始端而不处理任何请求`。

假设某磁盘的磁道为0~200号，磁头的初始位置是100号磁道，且`此时磁头正在往磁道号增大的方向移动`，有多个进程先后陆续地请求访问55、58、39、18、90、160、150、38、184号磁道

![image-20221122102042049](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122102042049.png)

磁头总共移动了(200-100)+(200-O)+(9O-0)= 390个磁道
响应一个请求平均需要移动390/9=43.3个磁道（平均寻找长度)

优点:比起SCAN来，对于各个位置磁道的响应频率很平均。

缺点:只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了;并且，磁头返回时其实只需要返回到18号磁道即可，不需要返回到最边缘的磁道。另外，比起SCAN算法来，平均寻道时间更长。

#### 7.C-LOOK算法

C-SCAN算法的主要缺点是只有到达最边上的磁道时才能改变磁头移动方向，并且磁头返回时不一定需要返回到最边缘的磁道上。C-LOOK算法就是为了解决这个问题。如果磁头移动的方向上已经没有磁道访问请求了，就可以立即让磁头返回，并且磁头只需要返回到有磁道访问请求的位置即可。

假设某磁盘的磁道为0~200号，磁头的初始位置是100号磁道，且`此时磁头正在往磁道号增大的方向移动`，有多个进程先后陆续地请求访问55、58、39、18、90、160、150、38、184号磁道

![image-20221122102212256](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122102212256.png)

磁头总共移动了(184-100)+(184-18)+(90-18)= 322个磁道
响应一个请求平均需要移动322/9= 35.8个磁道（平均寻找长度)
优点:比起C-SCAN算法来，不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时间进一步缩短

### 4.2.3 减少磁盘延迟时间的方法（交替编号、错位命名）

![image-20221122102337215](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122102337215.png)

#### 1.前情回顾

![image-20221122102500076](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122102500076.png)

#### 2.交替编号

若采用交替编号的策略，即让逻辑上相邻的扇区在物理上有一定的间隔，可以使读取连续的逻辑扇区所需要的延迟时间更小。

![image-20221122102556219](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122102556219.png)

在磁头转到0扇区之前已经做好准备，则可以直接读取0号扇区数据

#### 3.磁盘地址结构的设计

![image-20221122102940249](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122102940249.png)

假设某磁盘有8个柱面/磁道（假设最内侧柱面/磁道号为0 ),4个盘面，8个扇区。则可用3个二进制位表示柱面，2个二进制位表示盘面，3个二进制位表示扇区。

`若物理地址结构是（盘面号，柱面号，扇区号)`，且需要连续读取物理地址(00, 000, 000)~ (00,001,111）的扇区:
(00, 000,000) ~ ( 00, 000,111 ）转两圈可读完之后再读取物理地址相邻的区域，即(00,001, 000)~ ( 00,001,111 )，`需要启动磁头臂，将磁头移动到下一个磁道`

![image-20221122103124697](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122103124697.png)

假设某磁盘有8个柱面/磁道（假设最内侧柱面/磁道号为0 ）,4个盘面，8个扇区。则可用3个二进制位表示柱面，2个二进制位表示盘面，3个二进制位表示扇区。

`若物理地址结构是（柱面号，盘面号，扇区号)`，且需要连续读取物理地址(000, 00,000) ~(000,01,111）的扇区:
(000, 00,000)~ ( o00, 00,111 )由盘面0的磁头读入数据之后再读取物理地址相邻的区域，即( 000,01,000) ~ ( 000,01,111 )，`由于柱面号/磁道号相同，只是盘面号不同，因此不需要移动磁头臂。只需要激活相邻盘面的磁头即可`

![image-20221122103258896](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122103258896.png)

思考:为什么?
磁盘的物理地址是（柱面号，盘面号，扇区号)而不是（盘面号，柱面号，扇区号)

答:读取地址连续的磁盘块时，采用（柱面号，盘面号，扇区号）的地址结构可以减少磁头移动消耗的时间

#### 4.错位命名

![image-20221122103419572](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122103419572.png)

![image-20221122103443522](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122103443522.png)

### 4.2.4 磁盘管理（磁盘初始化、引导块、坏块的管理）

![image-20221122103610308](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122103610308.png)

#### 1.磁盘初始化

![image-20221122103720968](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122103720968.png)

#### 2.引导块

![image-20221122103749714](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122103749714.png)

![image-20221122103818015](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122103818015.png)

#### 3.坏块的管理

![image-20221122103831179](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122103831179.png)



