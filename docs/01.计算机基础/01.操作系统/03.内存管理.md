---
title: 内存管理
date: 2020-05-11 13:54:40
permalink: /pages/793dcb
article: false
---

# 第 3 章 内存管理

## 3.1 内存管理的概念

### 3.1.1 什么是内存？进程的基本原理，深入指令理解其过程

![image-20221114145602715](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114145602715.png)

#### 1.什么是内存?有何作用?

![image-20221114150228963](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114150228963.png)

##### (1)存储单元

内存可存放数据。程序执行前`需要先放到内存中才能被CPU处理`——缓和CPU与硬盘之间的速度矛盾

![image-20221114150305671](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114150305671.png)

##### (2)几个常用数量单位&内存地址

![image-20221114150339317](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114150339317.png)

补充知识：2十次方 = 1K （千）2二十次方 = 1M （兆，百万）2三十次方 = 1G （十亿，千兆）

注：有的题目会告诉我们内存的大小，让我们确定地址长度应该是多少（即要多少个二进制位才能表示相应数目的存储单元）

#### ⒉.进程运行的基本原理

##### (1)指令的工作原理---操作码+若干参数(可能包含地址参数)

- 从X=X+1大致看一下指令的执行过程

![image-20221114151001887](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114151001887.png)

![image-20221114151018675](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114151018675.png)

![image-20221114151044406](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114151044406.png)

![image-20221114151101407](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114151101407.png)

可见，我们写的代码要翻译成CPU能识别的指令。这些指令会告诉CPU应该去内存的哪个地址读/写数据，这个数据应该做什么样的处理。在这个例子中，指令中直接给出了变量 x 的实际存放地址（`物理地址`）。但实际在生成机器指令的时候并不知道该进程的数据会被放到什么位置。所以编译生成的指令中一般是使用`逻辑地址（相对地址)`

`思考`：如果这个进程不是从地址#0 开始存放的，会影响指令的正常执行吗？

##### (2）逻辑地址(相对地址)vs物理地址(绝对地址)

![image-20221114152150732](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114152150732.png)

##### (3）从写程序到程序运行---编译、链接、装入

![image-20221114153506842](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114153506842.png)

编译：由编译程序将用户源代码编译成若干个目标模块（编译就是把高级语言`翻译为机器语言`）

链接：由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块装入（装载）：由装入程序将装入模块装入内存运行

##### (4）装入模块装入内存

**不修改装入模块中的指令地址就直接装入内存的话：**

正确

![image-20221114152527200](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114152527200.png)

错误

![image-20221114152644400](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114152644400.png)

##### (5)装入的三种方式

###### ①绝对装入

`绝对装入`：在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。

Eg：如果知道装入模块要从地址为 100 的地方开始存放…

![image-20221114152903692](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114152903692.png)

绝对装入只适用于`单道程序环境`。

程序中使用的绝对地址，可在编译或汇编时给出，也可由程序员直接赋予。通常情况下都是编译或汇编时再转换为绝对地址。

###### ②静态重定位

`静态重定位`：又称`可重定位装入`。编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行“`重定位`”，将逻辑地址变换为物理地址（地址变换是在装入时一次完成的）。

![image-20221114153118448](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114153118448.png)

静态重定位的特点是在一个作业装入内存时，`必须分配其要求的全部内存空间`，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，`在运行期间就不能再移动`，也不能再申请内存空间。

###### ③动态重定位

`动态重定位`：又称`动态运行时装入`。编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是`把地址转换推迟到程序真正要执行时才进行`。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个`重定位寄存器`的支持。

![image-20221114153230629](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114153230629.png)

![image-20221114153402672](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114153402672.png)

![image-20221114153256757](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114153256757.png)

##### (6)链接的三种方式

###### ①静态链接

![image-20221114153636669](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114153636669.png)

###### ②装入时动态链接

![image-20221114153649828](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114153649828.png)

###### ③运行时动态链接

![image-20221114153700228](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114153700228.png)

### 3.1.2 内存管理管些什么？

![image-20221114154001739](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114154001739.png)

#### 1.内存空间的分配与回收

![image-20221114154118223](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114154118223.png)

#### 2.内存空间的扩展(实现虚拟性)

![image-20221114154136903](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114154136903.png)

#### 3.地址转换

![image-20221114154255867](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114154255867.png)

为了使编程更方便，程序员写程序时应该只需要关注指令、数据的逻辑地址。而`逻辑地址到物理地址的转换`（这个过程称为`地址重定位`(三种装入方式)）应该由操作系统负责，这样就保证了程序员写程序时不需要关注物理内存的实际情况。

##### 三种方式

![image-20221114154321330](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114154321330.png)

#### 4.内存保护

![image-20221114154349429](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114154349429.png)

##### 两种方式

内存保护可采取两种方法：

方法一：在CPU中`设置一对上、下限寄存器`，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界。

![image-20221114154445067](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114154445067.png)

方法二：采用`重定位寄存器`（又称`基址寄存器`）和`界地址寄存器`（又称`限长寄存器`）进行越界检查。重定位寄存器中存放的是进程的`起始物理地址`。界地址寄存器中存放的是进程的`最大逻辑地址`。

![image-20221114154615221](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221114154615221.png)

### 3.1.3 覆盖技术与交换技术的思想

![image-20221115101756145](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115101756145.png)

![image-20221115101654426](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115101654426.png)

#### 1.覆盖技术

![image-20221115101823597](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115101823597.png)

![image-20221115101945617](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115101945617.png)

覆盖技术的思想：将`程序分为多个段`（多个模块）。常用的段常驻内存，不常用的段在需要时调入内存。

内存中分为`一个“固定区”`和`若干个“覆盖区”`。

需要常驻内存的段放在“`固定区`”中，`调入后就不再调出`（除非运行结束）不常用的段放在“`覆盖区`”，`需要用到时调入内存，用不到时调出内存`

![image-20221115102002646](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115102002646.png)

`必须由程序员声明覆盖结构`，操作系统完成自动覆盖。`缺点：对用户不透明`，增加了用户编程负担。覆盖技术只用于早期的操作系统中，现在已成为历史。

#### 2.交换技术

交换（对换）技术的设计思想：内存空间紧张时，系统将内存中某些进程暂时`换出`外存，把外存中某些已具备运行条件的进程`换入`内存（进程在内存与磁盘间动态调度）

![image-20221115102051312](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115102051312.png)

`中级调度（内存调度）`，就是要决定将哪个处于挂起状态的进程重新调入内存。

暂时换出外存等待的进程状态为`挂起状态（挂起态，suspend）`挂起态又可以进一步细分为`就绪挂起、阻塞挂起`两种状态

![image-20221115102219903](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115102219903.png)

![image-20221115102257668](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115102257668.png)

![image-20221115102308472](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115102308472.png)

1. 具有对换功能的操作系统中，通常把磁盘空间分为`文件区`和`对换区`两部分。`文件区`主要用于存放文件，`主要追求存储空间的利用率`，因此对文件区空间的管理`采用离散分配方式`；`对换区`空间只占磁盘空间的小部分，`被换出的进程数据就存放在对换区`。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理`主要追求换入换出速度`，因此通常对换区采用连续分配方式（学过文件管理章节后即可理解）。总之，`对换区的I/O速度比文件区的更快`。

2. 交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如：在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程；如果缺页率明显下降，就可以暂停换出。

3. 可优先换出阻塞进程；可换出优先级低的进程；为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间…（`注意：PCB 会常驻内存`，不会被换出外存）

### 3.1.4 内存的分配与回收

![image-20221115102641540](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115102641540.png)

![image-20221115102713314](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115102713314.png)

#### 1.单—连续分配

在单一连续分配方式中，内存被分为`系统区`和`用户区`。系统区通常位于内存的低地址部分，用于存放操作系统相关数据；用户区用于存放用户进程相关数据。内存中`只能有一道用户程序`，用户程序独占整个用户区空间。

`优点`：实现简单；`无外部碎片`；可以采用覆盖技术扩充内存；不一定需要采取内存保护（eg：早期的 PC 操作系统 MS-DOS）。

`缺点`：只能用于单用户、单任务的操作系统中；`有内部碎片`(分配给某进程的内存区域中，如果有些部分没有用上，就是“内部碎片”)；存储器利用率极低。

![image-20221115103119828](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115103119828.png)

#### 2.固定分区分配

20世纪60年代出现了支持多道程序的系统，为了能在内存中装入多道程序，且这些程序之间又不会相互干扰，于是将整个`用户空间`划分为`若干个固定大小的分区`，在`每个分区中只装入一道作业`，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式。

![image-20221115103256770](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115103256770.png)

分区大小相等：缺乏灵活性，但是很`适合用于用一台计算机控制多个相同对象的场合`（比如：钢铁厂有n个相同的炼钢炉，就可把内存分为n个大小相等的区域存放n个炼钢炉控制程序）

分区大小不等：增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分（比如：划分多个小分区、适量中等分区、少量大分区）

##### (1)分区说明表

操作系统需要建立一个数据结构——`分区说明表`，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的`大小、起始地址、状态`（是否已分配）。

![image-20221115103447344](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115103447344.png)

当某用户程序要装入内存时，由操作系统内核程序根据用户程序大小检索该表，从中找到一个能满足大小的、未分配的分区，将之分配给该程序，然后修改状态为“已分配”。用数据结构的数组（或链表）即可表示这个表

优点：实现简单，`无外部碎片`。

缺点：a. 当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能；b. `会产生内部碎片`，内存利用率低。

#### 3.动态分区分配(可变分区分配)

`动态分区分配`又称为`可变分区分配`。这种分配方式`不会预先划分内存分区`，而是在进程装入内存时，`根据进程的大小动态地建立分区`，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。（eg：假设某计算机内存大小为 64MB，系统区 8MB，用户区共 56 MB…）

![image-20221115104020602](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115104020602.png)

##### (1)系统要用怎样的数据结构记录内存的使用情况呢?

![image-20221115104125016](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115104125016.png)

##### (2)当多个空闲分区都能满足要求时，应该选择哪个分区进行分配?

![image-20221115104141441](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115104141441.png)

##### (3）如何进行分区的分配和回收操作?

**如何分配？**

![image-20221115104338404](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115104338404.png)

![image-20221115104413157](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115104413157.png)

![image-20221115104446590](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115104446590.png)

**如何回收？**

如何进行分区的分配与回收操作？假设系统采用的数据结构是“空闲分区表”...

![image-20221115104613371](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115104613371.png)

![image-20221115104626794](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115104626794.png)

![image-20221115104642340](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115104642340.png)

![image-20221115104655543](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115104655543.png)

#### 4.内部碎片与外部碎片

`动态分区分配`又称为`可变分区分配`。这种分配方式`不会预先划分内存分区`，而是在进程装入内存时，`根据进程的大小动态地建立分区`，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。

动态分区分配`没有内部碎片`，但是`有外部碎片`。

`内部碎片`，分配给某进程的内存区域中，如果有些部分没有用上。

`外部碎片`，是指内存中的某些空闲分区由于太小而难以利用。

如果内存中空闲空间的总和本来可以满足某进程的要求，但由于进程需要的是一整块连续的内存空间，因此这些“碎片”不能满足进程的需求。

可以通过`紧凑（拼凑，Compaction）`技术来解决外部碎片。

![image-20221115105347967](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115105347967.png)

### 3.1.5 动态分区分配的四种算法（首次适应算法、最佳适应算法、最坏适应算法、临近适应算法）

`动态分区分配算法`：在动态分区分配方式中， 当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？

![image-20221115105735762](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115105735762.png)

#### 1.首次适应算法

`算法思想`：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。

`如何实现`：`空闲分区以地址递增的次序排列`。每次分配内存时顺序查找`空闲分区链`（或`空闲分区表`），找到大小能满足要求的第一个空闲分区。

![image-20221115105935983](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115105935983.png)

![image-20221115105952336](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115105952336.png)

![image-20221115110024219](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115110024219.png)

#### 2.最佳适应算法

`算法思想`：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即，优先使用更小的空闲区。

`如何实现`：空闲分区`按容量递增次序链接`。每次分配内存时顺序查找`空闲分区链`（或`空闲分区表`），找到大小能满足要求的第一个空闲分区。

![image-20221115110247759](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115110247759.png)

![image-20221115110312650](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115110312650.png)

![image-20221115110337604](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115110337604.png)

#### 3.最坏(大)适应算法

又称 `最大适应算法（Largest Fit）`

`算法思想`：为了解决最佳适应算法的问题——即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。

如何实现：空闲分区`按容量递减次序链接`。每次分配内存时顺序查找`空闲分区链`（或`空闲分区表`），找到大小能满足要求的第一个空闲分区。

![image-20221115110452531](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115110452531.png)

![image-20221115110516217](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115110516217.png)

![image-20221115110536749](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115110536749.png)

![image-20221115110608586](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115110608586.png)

#### 4.临近适应算法

`算法思想`：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。

`如何实现`：空闲分区以地址递增的顺序排列（可排成一个循环链表）。每次分配内存时`从上次查找结束的位置开始`查找`空闲分区链`（或`空闲分区表`），找到大小能满足要求的第一个空闲分区。

![image-20221115110746729](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115110746729.png)

![image-20221115110812189](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115110812189.png)

![image-20221115110854649](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115110854649.png)

![image-20221115110926717](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115110926717.png)

![image-20221115111003508](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115111003508.png)

#### 5.四种算法归纳比较

| 算法     | 算法思想                                             | 分区排列顺序                                   | 优点                                                         | 缺点                                                         |
| -------- | ---------------------------------------------------- | ---------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 首次适应 | `从头到尾找适合的分区`                               | 空闲分区以地址递增次序排列                     | 综合看性能最好。**算法开销小**，回收分区后一般不需要对空闲分区队列重新排序 |                                                              |
| 最佳适应 | `优先使用更小的分区，以保留更多大分区`               | 空闲分区以容量递增次序排列                     | 会有更多的大分区被保留下来，更能满足大进程需求               | 会产生很多太小的、难以利用的碎片；**算法开销大**，回收分区后可能需要对空闲分区队列重新排序 |
| 最坏适应 | `优先使用更大的分区，以防止产生太小的不可用的碎片`   | 空闲分区以容量递减次序排列                     | 可以减少难以利用的小碎片                                     | 大分区容易被用完，不利于大进程；**算法开销大**（原因同上）   |
| 邻近适应 | `由首次适应演变而来，每次从上次查找结束位置开始查找` | 空闲分区以地址递增次序排列（可排列成循环链表） | 不用每次都从低地址的小分区开始检索。**算法开销**（原因同首次适应算法） | 会使高地址的大分区也被用完                                   |

### 3.1.6 分页存储（页号、页偏移量等）

![image-20221115134215010](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115134215010.png)

`连续分配`：为用户进程分配的必须是一个`连续的内存空间`。

`非连续分配`：为用户进程分配的可以是一些`分散的内存空间`。

![image-20221115134348283](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115134348283.png)

#### 1.为什么学习分页存储?

![image-20221115134546313](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115134546313.png)

#### 2.基本分页存储管理的思想

![image-20221115134646473](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115134646473.png)

#### 3.分页存储管理的重要概念

![image-20221115134713864](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115134713864.png)

**什么是分页存储？**

将内存空间分为一个个`大小相等的分区`（比如：每个分区4KB），每个分区就是一个“`页框`”（`页框=页帧=内存块=物理块=物理页面`）。每个页框有一个编号，即“页框号”（`页框号=页帧号=内存块号=物理块号=物理页号`），页框号**从0开始**。

将`进程的逻辑地址空间`也分为**与页框大小相等**的一个个部分，每个部分称为一个“`页`”或“`页面`” 。每个页面也有一个编号，即“`页号`”，页号也是**从0开始**。

> Tips：初学易混——页、页面 vs 页框、页帧、物理页页号、页面号 vs 页框号、页帧号、物理页号

操作系统`以页框为单位为各个进程分配`内存空间。进程的每个页面分别放入一个页框中。也就是说，进程的`页面`与内存的`页框`有`一一对应`的关系。

各个页面不必连续存放，可以放到不相邻的各个页框中。

（注：进程的最后一个页面可能没有一个页框那么大。也就是说，分页存储有可能产生内部碎片，因此`页框不能太大，否则可能产生过大的内部碎片造成浪费`）

![image-20221115135033813](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115135033813.png)

#### 4.如何实现地址的转换

![image-20221115140145886](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115140145886.png)

![image-20221115140308748](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115140308748.png)

![image-20221115140342412](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115140342412.png)

![image-20221115140403622](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115140403622.png)

![image-20221115140429512](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115140429512.png)

##### 如何计算页号和页偏移量

Eg：在某计算机系统中，页面大小是50B。某进程逻辑地址空间大小为200B，则逻辑地址 110 对应的页号、页内偏移量是多少？

![image-20221115140534578](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115140534578.png)

如何计算：

`页号` = 逻辑地址 / 页面长度 （取除法的`整数`部分）

`页内偏移量` = 逻辑地址 % 页面长度（取除法的`余数`部分）

`页号`= 110 / 50 = 2

`页内偏移量` = 110 % 50 = 10

`逻辑地址` 可以拆分为（`页号，页内偏移量`）

通过页号查询页表，可知页面在内存中的起始地址

页面在内存中的起始地址+页内偏移量 = 实际的物理地址

![image-20221115140654954](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115140654954.png)

##### 为什么页面大小一般设为2的整数次幂？

`页号` = 逻辑地址 / 页面长度 （取除法的`整数`部分）

`页内偏移量` = 逻辑地址 % 页面长度（取除法的`余数`部分）

在计算机内部，地址是用二进制表示的，如果`页面大小`刚好是` 2 的整数幂`，则计算机硬件可以很快速的把逻辑地址拆分成（页号，页内偏移量）

假设某计算机用32 个二进制位表示逻辑地址，页面大小为 4KB	= 2^12B = 4096B

![image-20221115141329422](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115141329422.png)

![image-20221115141447543](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115141447543.png)结论：如果每个页面大小为 2KB，用二进制数表示逻辑地址，则末尾 K 位即为页内偏移量，其余部分就是页号。因此，如果让`每个页面的大小为2的整数幂`，计算机就可以很方便地得出一个逻辑地址对应的页号和页内偏移量。

总结：页面大小 刚好是 2 的整数幂有什么好处？

①逻辑地址的拆分更加迅速——如果每个页面大小为 `2^K`B，用二进制数表示逻辑地址，则`末尾 K 位`即为`页内偏移量`，其余部分就是`页号`。因此，如果让`每个页面的大小为 2 的整数幂`，计算机硬件就可以很方便地得出一个逻辑地址对应的页号和页内偏移量，而无需进行除法运算，从而提升了运行速度。

②物理地址的计算更加迅速——根据逻辑地址得到页号，根据页号查询页表从而找到页面存放的内存块号，将二进制表示的内存块号和页内偏移量拼接起来，就可以得到最终的物理地址。

##### 分页存储的逻辑结构

分页存储管理的逻辑地址结构如下所示：

![image-20221115141810159](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115141810159.png)

地址结构包含两个部分：前一部分为页号，后一部分为页内偏移量 W。在上图所示的例子中，地址长度为 32 位，其中 0~11位 为“`页内偏移量`”，或称“`页内地址`” ；12~31 位为“`页号`”。

`如果有 K 位表示“页内偏移量”，则说明该系统中一个页面的大小是 2^K个内存单元`

`如果有 M 位表示“页号”，则说明在该系统中，一个进程最多允许有 2^M 个页面`

Tips：有些奇葩题目中页面大小有可能不是2的整数次幂，这种情况还是得用最原始的方法计算：

`页号` = 逻辑地址 / 页面长度 （取除法的`整数`部分）

`页内偏移量` = 逻辑地址 % 页面长度（取除法的`余数`部分）

![image-20221115142151156](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115142151156.png)

##### 如何知道页面在内存中的起始地址?

这里引入一个新的概念：`页表`

为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张页表。

> 注：页表通常存在PCB（进程控制块）中

![image-20221115142933240](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115142933240.png)

1. 一个进程对应一张页表

2. 进程的每个页面对应一个页表项

3. 每个`页表项`由“页号”和“块号”组成

4. 页表记录进程`页面`和实际存放的`内存块`之间的`映射关系`

5. 每个页表项的长度是相同的

**每个页表项占多少字节？**

![image-20221115142506702](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115142506702.png)

![image-20221115142613704](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115142613704.png)

![image-20221115142640666](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115142640666.png)

![image-20221115142713146](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221115142713146.png)

### 3.1.7 分页存储管理的基本地址变换结构

![image-20221116095843911](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221116095843911.png)

重点理解、记忆基本地址变换机构（用于实现逻辑地址到物理地址转换的一组硬件机构）的原理和流程

![image-20221116095932671](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221116095932671.png)

#### 1.页表寄存器

基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。
通常会在系统中设置一个`页表寄存器`（PTR)，存放`页表在内存中的起始地址F`和`页表长度M`。

进程未执行时，页表的始址和页表长度`放在进程控制块（PCB）中`，当进程被调度时，操作系统内核会把它们放到页表寄存器中。

注意:`页面大小是2的整数幂`

##### 地址变换过程

设页面大小为L，逻辑地址A到物理地址E的变换过程如下:

![image-20221116100122714](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221116100122714.png)

![image-20221116100144566](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221116100144566.png)

基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。
通常会在系统中设置一个`页表寄存器`（PTR），存放`页表在内存中的起始地址F`和`页表长度M`。进程未执行时，页表的`始址`和页表长度`放在进程控制块（PCB）中`，当进程被调度时，操作系统内核会把它们放到页表寄存器中。

注意:页面大小是2的整数幂
设页面大小为L，逻辑地址A到物理地址E的变换过程如下:

1. 计算页号Р和页内偏移量w（如果用十进制数手算，则P=A/L，W=A%L;但是在计算机实际运行时，逻辑地址结构是固定不变的，因此计算机硬件可以更快地得到二进制表示的页号、页内偏移量)
2. 比较页号p和页表长度M，若P>=M，则产生越界中断，否则继续执行。(注意:页号是从O开始的，而页表长度至少是1，因此P=M时也会越界)
3. 页表中页号p对应的`页表项地址=页表起始地址F＋页号P*页表项长度`，取出该页表项内容b,即为内存块号。（注意区分`页表项长度`、`页表长度`、`页面大小`的区别。`页表长度`指的是这个页表中总共有几个页表项，即总共有几个页;`页表项长度`指的是每个页表项占多大的存储空间;`页面大小`指的是一个页面占多大的存储空间)
4. 计算E= b*L+W，用得到的物理地址E去访存。(如果内存块号、页面偏移量是用二进制表示的，那么把二者拼接起来就是最终的物理地址了)

**一道例题加深印象：**

![image-20221116100839151](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221116100839151.png)

#### 2.对页表项大小的进—步讨论

![image-20221116101016031](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221116101016031.png)

### 3.1.8 快表的地址变换结构

上一篇文章学习了分页存储管理的基本地址变换结构,这一篇文章是对基本地址变换结构的改进版。

![image-20221116101329725](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221116101329725.png)

#### 1.局部性原理引入快表机制

![image-20221116101518524](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221116101518524.png)

引入快表机制

#### 2.快表(TLB)

`快表`，又称`联想寄存器（TLB`， translation	lookaside	buffer	），是一种`访问速度比内存快很多的`高速缓存（`TLB不是内存！`），用来存放`最近访问的页表项的副本`，可以加速地址变换的速度。与此对应，内存中的页表常称为`慢表`。

![image-20221116101719434](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221116101719434.png)

##### 一个例图了解基于快表的地址变换结构

![image-20221116101750851](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221116101750851.png)

**引入快表后，地址变换的过程的文字描述：**

① CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。

② 如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若`快表命中`，则访问某个逻辑地址仅需`一次访存`即可。

③ 如果没有找到匹配的页号，则需要`访问内存中的页表`，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，`访问`该物理地址对应的`内存单元`。因此，若`快表未命中`，则访问某个逻辑地址需要`两次访存`（`注意：在找到页表项后，应同时将其存入快表`，以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换）

由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间。

因为局部性原理，一般来说快表的命中率可以达到 90% 以上。

例：某系统使用基本分页存储管理，并采用了具有快表的地址变换机构。访问一次快表耗时 1us，访问一次内存耗时 100us。若快表的命中率为 90%，那么访问一个逻辑地址的平均耗时是多少？

> (1+100) *	0.9 + (`1`+100+100) *	0.1 = `111 us`

有的系统支持快表和慢表同时查找，如果是这样，平均耗时应该是

>  (1+100) *	0.9 + (100+100) *	0.1 =`110.9 us`

若未采用快表机制，则访问一个逻辑地址需要 100+100 =` 200us`

显然，引入快表机制后，访问一个逻辑地址的速度快多了。

![image-20221116101903030](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221116101903030.png)

#### 3.基本地址变换与快表地址变换的比较

|                        | 地址变换过程                                                 | 访问一个逻辑地址的访存次数                                   |
| ---------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 基本地址变换机构       | ①算页号、页内偏移量<br/>②检查页号合法性<br/>③查页表，找到页面存放的内存块号<br/>④根据内存块号与页内偏移量得到物理地址<br/>⑤访问目标内存单元 | 两次访存                                                     |
| 具有快表的地址变换机构 | ①算页号、页内偏移量<br/>②检查页号合法性<br/>③`查快表`。若命中，即可知道页面存放的内存块号，可直接进行⑤；若未命中则进行④<br/>④查页表，找到页面存放的内存块号，`并且将页表项复制到快表中`<br/>⑤根据内存块号与页内偏移量得到物理地址<br/>⑥访问目标内存单元 | 快表`命中`，只需`一次访存`。<br/>快表`未命中`，需要`两次访存` |

TLB 和 普通 Cache 的区别——TLB 中只有页表项的副本，而普通 Cache 中可能会有其他各种数据的副本

### 3.1.9 二级页表的原理和地址结构

![image-20221116103600504](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221116103600504.png)

#### 1.为什么引入二级页表?

**因为单级页表存在一些问题，所以引入二级页表和多级页表，有两个问题：**

![image-20221116103721605](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221116103721605.png)

某计算机系统按字节寻址，支持 32 位的逻辑地址，采用分页存储管理，页面大小为4KB，页表项长度为 4B。

4KB = 212B，因此页内地址要用12位表示，剩余 20 位表示页号。因此，该系统中用户进程最多有 220 页。相应的，一个进程的页表中，最多会有 220 = 1M = 1,048,576 个页表项，所以一个页表最大需要 220 *	4B = 222 B，共需要 222/212 = 210个页框存储该页表。

根据局部性原理可知，很多时候，`进程在一段时间内只需要访问某几个页面就可以正常运行了`。因此`没有必要让整个页表都常驻内存`。

**上面提到了这两个问题，那么总结一下，并提出解决思想，引入二级页表的概念。**

问题一：页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框。

问题二：没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。

![image-20221116104049606](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221116104049606.png)

可将长长的页表进行分组，使每个内存块刚好可以放入一个分组（比如上个例子中，页面大小4KB，每个页表项4B，每个页面可存放1K个页表项，因此每1K个连续的页表项为一组，每组刚好占一个内存块，再讲各组离散地放到各个内存块中)
另外，要为离散分配的页表再建立一张页表，称为`页目录表`，或称`外层页表`，或称`顶层页表`

#### 2.二级页表的原理和地址结构

- 对页表再次分组

  32位逻辑地址空间，页表项大小为4B，页面大小为 4KB，则页内地址占12位

  ![image-20221116104324521](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221116104324521.png)

- 二级页表的地址结构及对应关系

  ![image-20221116104358307](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221116104358307.png)

#### 3.如何实现二级页表的地址变换?

![image-20221116104449724](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221116104449724.png)

**上面的部分我们解决了问题一，接下来是问题二，这里简单叙述一下，后面的文章会继续深入剖析。**

![image-20221116104619281](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221116104619281.png)

#### 4.几个小细节

1. 若分为两级页表后，页表依然很长，则可以采用更多级页表，一般来说`各级页表的大小不能超过一个页面`

   例：某系统按字节编址，采用 40 位逻辑地址，页面大小为 4KB，页表项大小为 4B，假设采用纯页式存储，则要采用（）级页表，页内偏移量为（）位？

   页面大小 =4KB=2^12B，按字节编址，因此页内偏移量为12位

   页号 =40 - 12	=	28 位

   页面大小 =2^12B，页表项大小 =4B，则每个页面可存放 2^12/4 =	2^10个页表项

   因此各级页表最多包含 2^10个页表项，需要 10位二进制位才能映射到 2^10个页表项，因此每一级的页

   表对应页号应为10位。总共28位的页号至少要分为三级

   ![image-20221116104917711](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221116104917711.png)

2. 两级页表的`访存次数`分析（假设没有快表机构）

   第一次访存：访问内存中的页目录表

   第二次访存：访问内存中的二级页表

   第三次访存：访问目标内存单元

### 3.1.10 基本分段存储管理（段表、地址变换、信息共享）

![image-20221116134253670](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221116134253670.png)

![image-20221116134311424](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221116134311424.png)

#### 1.什么是分段?

进程的地址空间：按照程序`自身的逻辑`关系`划分为若干个段`，每个段都有一个段名（在低级语言

中，程序员使用段名来编程），`每段从0开始编址`

内存分配规则：以段为单位进行分配，`每个段在内存中占据连续空间`，但`各段之间可以不相邻`。

![image-20221116134534728](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221116134534728.png)

##### 分段的逻辑地址结构

分段系统的逻辑地址结构由段号（段名）和段内地址（段内偏移量）所组成。如：

![image-20221116134600402](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221116134600402.png)

#### 2.段表

问题：程序分多个段，各段离散地装入内存，为了保证程序能正常运行，就必须能从物理内存中

找到各个逻辑段的存放位置。为此，需为每个进程建立一张段映射表，简称“`段表`”。

![image-20221116134737760](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221116134737760.png)

1. 每个段对应一个段表项，其中记录了该段在内存中的`起始位置`（又称“`基址`”）和`段的长度`。

2. `各个段表项的长度是相同的`。例如：某系统按字节寻址，采用分段存储管理，逻辑地址结构为（段号16位, 段内地址16位），因此用16位即可表示最大段长。物理内存大小为4GB（可用32位表示整个物理内存地址空间）。因此，可以让每个段表项占 16+32 = 48位，即6B。由于段表项长度相同，因此`段号可以是隐含的，不占存储空间`。若段表存放的起始地址为 M，则 K号段对应的段表项存放的地址为 M + K*6

#### 3.地址变换

![image-20221116135127874](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221116135127874.png)

![image-20221116135210452](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221116135210452.png)

#### 4.分段、分页管理的对比

`页`是`信息的物理单位`。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管

理上的需要，完全是系统行为，`对用户是不可见的`。

`段`是`信息的逻辑单位`。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻

辑模块的信息。`分段对用户是可见的`，用户编程时需要显式地给出段名。

页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。

`分页`的用户进程`地址空间是一维的`，程序员只需给出一个记忆符即可表示一个地址。

`分段`的用户进程`地址空间是二维的`，程序员在标识一个地址时，既要给出段名，也要给出段内地址。

![image-20221116135306842](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221116135306842.png)

`分段`比分页`更容易实现信息的共享和保护`。不能被修改的代码称为`纯代码`或`可重入代码`（不属于临界资源），这样的代码是可以共享的。可修改的代码是不能共享的

访问一个逻辑地址需要几次访存？

`分页（单级页表）`：第一次访存——查内存中的页表，第二次访存——访问目标内存单元。总共`两次访存`

`分段`：第一次访存——查内存中的段表，第二次访存——访问目标内存单元。总共两次访存与分页系统类似，分段系统中`也可以引入快表机构`，将近期访问过的段表项放到快表中，这样`可以少一次访问`，加快地址变换速度。

##### 分段实现信息共享共享

![image-20221116135656304](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221116135656304.png)

##### 为什么分页不方便实现信息共享和保护?

![image-20221116135714588](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221116135714588.png)

### 3.1.11 段页式存储管理（段表、页表、地址转换）

![image-20221116135917545](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221116135917545.png)

![image-20221116135955346](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221116135955346.png)

#### 1.分页、分段的优缺点分析

![image-20221116140347595](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221116140347595.png)

![image-20221116140415151](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221116140415151.png)

#### ⒉.分段+分页=段页式管理

![image-20221116140458069](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221116140458069.png)

`将进程按逻辑模块分段，再将各段分页`(如每个页面4KB)

再将内存空间分为大小相同的内存块/页框/页帧/物理块

##### 段页式管理的逻辑地址结构

![image-20221116140616932](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221116140616932.png)

##### 段页式存储的段表、页表

![image-20221116140646122](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221116140646122.png)

#### 3.段页式管理的地址转换过程

![image-20221116140935034](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221116140935034.png)

## 3.2 虚拟内存管理

### 3.2.1 虚拟内存的基本概念（局部性原理、高速缓存、虚拟内存的实现）

![image-20221117095514891](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221117095514891.png)

![image-20221117095527603](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221117095527603.png)

![image-20221117095555385](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221117095555385.png)

#### 1.传统存储管理的特征、缺点

![image-20221117095747303](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221117095747303.png)

**特征：**

`一次性：作业必须一次性全部装入内存后才能开始运行`(可用虚拟存储技术解决问题)。这会造成两个问题：

①作业很大时，不能全部装入内存，导致`大作业无法运行`；

②当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致`多道程序并发度下降`。

`驻留性`：一旦作业被装入内存，就`会一直驻留在内存`中，直至作业运行结束。事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源。

#### 2.局部性原理

`时间局部性`：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。（因为程序中存在大量的循环）

`空间局部性`：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。（因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的）

![image-20221117100006525](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221117100006525.png)

#### 3.虚拟内存的定义和特征

![image-20221117100149261](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221117100149261.png)

基于局部性原理，在程序装入时，可以将程序中`很快会用到的部分装入内存，暂时用不到的部分留在外存`，就可以让程序开始执行。

在程序执行过程中，当所访问的`信息不在内存时`，由`操作系统负责将所需信息从外存调入内存`，然后继续执行程序。

若内存空间不够，由`操作系统负责`将内存中`暂时用不到的信息换出到外存`。

在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是`虚拟内存`(操作系统虚拟性的一个体现，实际的物理内存大小没有变，只是在逻辑上进行了扩充。)

**易混知识点：**

虚拟内存的`最大容量`是由计算机的地址结构（CPU寻址范围）确定的

虚拟内存的`实际容量` =	min（内存和外存容量之和，CPU寻址范围）

如：某计算机地址结构为32位，按字节编址，内存大小为512MB，外存大小为2GB。

则虚拟内存的`最大容量`为 2^32	B = 4GB

虚拟内存的`实际容量` = min (2^32B, 512MB+2GB) = 2GB+512MB

**虚拟内存有一下三个主要特征：**

`多次性`：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。

`对换性`：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。

`虚拟性`：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。

#### 4.如何实现虚拟内存技术

虚拟内存技术，允许一个作业分多次调入内存。如果采用连续分配方式，会不方便实现。因此，虚拟内存的实现需要建立在离散分配的内存管理方式基础上。

![image-20221117100545402](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221117100545402.png)

### 3.2.2 请求分页管理方式（请求页表、缺页中断机构、地址变换机构）

![image-20221117100707909](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221117100707909.png)

#### 1.知识总览

`请求分页`存储管理与`基本分页`存储管理的主要区别：

在程序执行过程中，当`所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存`(操作系统要提供请求调页功能，将缺失页面从外存调入内存)，然后继续执行程序。

若内存空间不够，由操作系统负责`将内存中暂时用不到的信息换出到外存`(操作系统要提供页面置换的功能，将暂时用不到的页面换出外存)。

![image-20221117101053913](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221117101053913.png)

#### 2.页表机制---请求页表与基本页表的区别

![image-20221117101135075](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221117101135075.png)

#### 3.缺页中断机构

![image-20221117101308854](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221117101308854.png)

![image-20221117101420358](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221117101420358.png)

![image-20221117101516238](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221117101516238.png)

![image-20221117101556625](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221117101556625.png)

`缺页中断`是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此`属于内中断`一条指令在执行期间，`可能产生多次缺页中断`。（如：copy A to B，即将逻辑地址A中的数据复制到逻辑地址B，而A、B属于不同的页面，则有可能产生两次中断）

![image-20221117101823022](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221117101823022.png)

#### 4.地址变换机构

![image-20221117101901783](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221117101901783.png)

![image-20221117101922846](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221117101922846.png)

![image-20221117102004489](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221117102004489.png)

![image-20221117102044890](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221117102044890.png)

### 3.2.3 页面置换算法（最佳置换算法、先进先出置换算法、最近最久未使用置换算法、普通时钟置换算法、改造型时钟置换算法）

`请求分页`存储管理与`基本分页`存储管理的主要区别：

在程序执行过程中，当所`访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存`，然后继续执行程序。

若内存空间不够，由操作系统负责`将内存中暂时用不到的信息换出到外存`。

用页面置换算法决定应该换出哪个页面：

![image-20221117102400661](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221117102400661.png)

![image-20221117102419057](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221117102419057.png)

#### 1.最佳置换算法---OPT

最佳置换算法（OPT，Optimal）：每次选择`淘汰的页面`将是`以后永不使用`，或者`在最长时间内不再被访问的页面`，这样可以保证最低的缺页率。

![image-20221117102906303](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221117102906303.png)

![image-20221117102943724](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221117102943724.png)

整个过程`缺页中断`发生了`9次`，`页面置换`发生了`6次`。

注意：缺页时未必发生页面置换。若还有可用的空闲内存块，就不用进行页面置换。

`缺页率` = 9/20 = 45%

最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面访问序列。因此，`最佳置换算法是无法实现的`。

#### 2.先进先出置换算法---FIFO

先进先出置换算法（FIFO）：每次选择`淘汰的页面`是`最早进入内存的页面`

实现方法：把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可。

队列的最大长度取决于系统为进程分配了多少个内存块。

![image-20221117103254783](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221117103254783.png)

![image-20221117103324658](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221117103324658.png)

`Belady 异常`——当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。

`只有 FIFO 算法会产生 Belady 异常`。另外，FIFO算法虽然`实现简单`，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问。因此，`算法性能差`

#### 3.最近最久未使用置换算法---LRU

最近最久未使用置换算法（LRU，least	recently	used）：每次`淘汰的页面`是`最近最久未使用的页面`

实现方法：赋予每个页面对应的页表项中，用`访问字段记录该页面自上次被访问以来所经历的时间t`。当需要淘汰一个页面时，选择现有页面中 t 值最大的，即最近最久未使用的页面。

该算法的实现需要专门的硬件支持，虽然算法`性能好`，但是`实现困难`，`开销大`

![image-20221117103718057](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221117103718057.png)

![image-20221117103807066](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221117103807066.png)

![image-20221117103834558](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221117103834558.png)

在手动做题时，若需要淘汰页面，可以逆向检查此时在内存中的几个页面号。在`逆向扫描过程中最后一个出现的页号就是要淘汰的页面`。

#### 4.时钟置换算法---CLOCK

最佳置换算法性能最好，但无法实现；先进先出置换算法实现简单，但算法性能差；最近最久未使用置换算法性能好，是最接近OPT算法性能的，但是实现起来需要专门的硬件支持，算法开销大。

`时钟置换算法`是一种性能和开销较均衡的算法，又称`CLOCK算法`，或`最近未用算法`（`NRU`，NRecently Used）

`简单的CLOCK 算法`实现方法：为每个页面设置一个`访问位`，再将内存中的页面都通过链接指针链接成`一个循环队列`。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出；如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描（第二轮扫描中一定会有访问位为0的页面，因此`简单的CLOCK 算法`选择一个淘汰页面`最多会经过两轮扫描` ）

![image-20221117104131191](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221117104131191.png)

![image-20221117104203566](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221117104203566.png)

![image-20221117104220805](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221117104220805.png)

#### 5.改造型时钟置换算法

**只需一轮：**

![image-20221117104505882](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221117104505882.png)

**需要两轮：**

![image-20221117104536396](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221117104536396.png)

**需要三轮：**

![image-20221117104601509](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221117104601509.png)

![image-20221117104629849](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221117104629849.png)

**需要四轮：**

![image-20221117104704269](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221117104704269.png)

![image-20221117104731360](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221117104731360.png)

![image-20221117104758889](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221117104758889.png)

`简单的时钟置换算法`仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过，就不需要执行I/O操作写回外存。`只有被淘汰的页面被修改过时，才需要写回外存`。

因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。`在其他条件都相同时，应优先淘汰没有修改过的页面`，避免I/O操作。这就是改进型的时钟置换算法的思想。

`修改位=0`，表示页面没有被修改过；`修改位=1`，表示页面被修改过。

为方便讨论，用（`访问位，修改位`）的形式表示各页面状态。如（1，1）表示一个页面近期被访问过，且被修改过。

![image-20221117104943052](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221117104943052.png)

### 3.2.4 页面分配策略（驻留集、页面分配、置换策略、抖动现象、工作集）

![image-20221117105111410](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221117105111410.png)

![image-20221117105151216](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221117105151216.png)

#### 1.驻留集

`驻留集`：指请求分页存储管理中给进程分配的物理块的集合。

在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小。

**考虑一个极端情况:**

若某进程共有100个页面，则该进程的驻留集大小为100时进程可以全部放入内存，运行期间不可能再发生缺页。若驻留集大小为1，则进程运行期间必定会极频繁地缺页

#### 2.页面分配、置换策略

`驻留集`:指请求分页存储管理中给进程分配的物理块的集合。
在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小。

若驻留集太小，会导致缺页频繁，系统要花大量的时间来处理缺页，实际用于进程推进的时间很少;

驻留集太大，又会导致多道程序并发度下降，资源利用率降低。所以应该选择一个合适的驻留集大小。

`固定分配`:操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。即，`驻留集大小不变`
`可变分配`:先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。即，`驻留集大小可变`

`局部置换`:发生缺页时只能选进程自己的物理块进行置换。
`全局置换`:可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程。

![image-20221117105600152](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221117105600152.png)

##### 固定分配局部置换、可变分配局部置换、可变分配全局置换

`固定分配局部置换`:系统为每个进程分配一定数量的物理块，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。这种策略的缺点是:很难在刚开始就确定应为每个进程分配多少个物理块才算合理。(采用这种策略的系统可以根据进程大小、优先级、或是根据程序员给出的参数来确定为一个进程分配的内存块数)

`可变分配全局置换`:刚开始会为每个进程分配一定数量的物理块。操作系统会保持一个空闲物理块队列。当某进程发生缺页时，从空闲物理块中取出一块分配给该进程;若已无空闲物理块，则可选择一个`未锁定(系统会锁定一些页面，这些页面中的内容不能置换出外存（如:重要的内核数据可以设为“锁定”))`的页面换出外存，再将该物理块分配给缺页的进程。采用这种策略时，`只要某进程发生缺页，都将获得新的物理块`，仅当空闲物理块用完时，系统才选择一个未锁定的页面调出。被选择调出的页可能是系统中任何一个进程中的页，因此这个`被选中的进程拥有的物理块会减少，缺页率会增加`。

`可变分配局部置换`:刚开始会为每个进程分配一定数量的物理块。当某进程发生缺页时，只允许从该进程自己的物理块中选出一个进行换出外存。如果进程在运行中频繁地缺页，系统会为该进程多分配几个物理块，直至该进程缺页率趋势适当程度;反之，如果进程在运行中缺页率特别低，则可适当减少分配给该进程的物理块。

可变分配`全局`置换:只要缺页就给分配新物理块
可变分配`局部`置换:要根据发生`缺页的频率`来动态地增加或减少进程的物理块

#### 3.何时调入页面?

![image-20221117110158276](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221117110158276.png)

#### 4.从何处调页?

1. 系统拥有足够的对换区空间：页面的调入、调出都是在内存与对换区之间进行，这样可以保证页面的调入、调出速度很快。在进程运行前，需将进程相关的数据从文件区复制到对换区。

2. 系统缺少足够的对换区空间：凡是不会被修改的数据都直接从文件区调入，由于这些页面不会被修改，因此换出时不必写回磁盘，下次需要时再从文件区调入即可。对于可能被修改的部分，换出时需写回磁盘对换区，下次需要时再从对换区调入。

3. UNIX 方式：运行之前进程有关的数据全部放在文件区，故未使用过的页面，都可从文件区调入。若被使用过的页面需要换出，则写回对换区，下次需要时从对换区调入。

![image-20221117110400570](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221117110400570.png)

#### 5.抖动(颠簸)现象

刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为`抖动`，或`颠簸`。产生抖动的`主要原因`是进程频繁访问的页面数目高于可用的物理块数（`分配给进程的物理块不够`）

为进程分配的物理块太少，会使进程发生抖动现象。为进程分配的物理块太多，又会降低系统整体的并发度，降低某些资源的利用率

为了研究为应该为每个进程分配多少个物理块，Denning 提出了进程“工作集”的概念

#### 6.工作集

`驻留集`：指请求分页存储管理中给进程分配的内存块的集合。

`工作集`：指在某段时间间隔里，进程实际访问页面的集合。

操作系统会根据“窗口尺寸”来算出工作集。例：

某进程的页面访问序列如下，`窗口尺寸为 4`，各时刻的工作集为？

![image-20221117110617475](https://path-to-learning-1309071697.cos.ap-shanghai.myqcloud.com/OS/image-20221117110617475.png)

`工作集大小`可能小于窗口尺寸，实际应用中，操作系统可以统计进程的工作集大小，根据工作集大小给进程分配若干内存块。如：窗口尺寸为5，经过一段时间的监测发现某进程的工作集最大为3，那么说明该进程有很好的局部性，可以给这个进程分配3个以上的内存块即可满足进程的运行需要。一般来说，`驻留集大小不能小于工作集大小，否则进程运行过程中将频繁缺页`。

拓展：基于局部性原理可知，进程在一段时间内访问的页面与不久之后会访问的页面是有相关性的。因此，可以根据进程近期访问的页面集合（工作集）来设计一种页面置换算法——选择一个不在工作集中的页面进行淘汰。
