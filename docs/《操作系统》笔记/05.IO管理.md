---
title: I/O管理
date: 2020-05-12 11:01:21
permalink: /pages/33d574
article: false
author: 
  name: xugaoyi
  link: https://github.com/xugaoyi
---

# 第 5 章 I/O管理

## 5.1 I/O管理概述

### 5.1.1 什么是I/O设备？有几类I/O设备？

![image-20221122104213517](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122104213517.png)

#### 1.什么是I/O设备?

“I/O”就是“输入/输出”(Input/Output)
I/O设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件。

![image-20221122104349884](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122104349884.png)

![image-20221122104409642](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122104409642.png)

#### 2.I/O设备的分类

##### (1)按使用特性分类

![image-20221122104442606](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122104442606.png)

##### (2)按传输速率分类

![image-20221122104455017](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122104455017.png)

##### (3)按信息交换单位分类

![image-20221122104508910](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122104508910.png)

### 5.1.2 控制I/O设备的I/O控制器

![image-20221122104847933](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122104847933.png)

#### 1.l/O设备的组成

![image-20221122105010321](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122105010321.png)

##### (1)机械部件

![image-20221122105031058](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122105031058.png)

I/O设备的`机械部件`主要用来执行具体l/O操作。

如我们看得见摸得着的鼠标/键盘的按钮;显示器的LED屏;移动硬盘的磁臂、磁盘盘面。

I/O设备的`电子部件`通常是一块插入主板扩充槽的印刷电路板。

##### (2)电子部件---lO控制器的功能

CPU无法直接控制/o设备的机械部件，因此I/o设备还要有一个电子部件作为CPU和/O设备机械部件之间的“中介”，用于实现CPU对设备的控制。
这个电子部件就是`I/O控制器`，又称`设备控制器`。CPU可控制I/O控制器，又由/o控制器来控制设备的机械部件。

![image-20221122105218577](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122105218577.png)

#### 2.I/O控制器的组成

![image-20221122105313687](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122105313687.png)

**注意：**

![image-20221122105344779](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122105344779.png)

值得注意的小细节:

①一个I/o控制器可能会对应多个设备;
②数据寄存器、控制寄存器、状态寄存器可能有多个(如:每个控制/状态寄存器对应一个具体的设备)，且这些寄存器都要有相应的地址，才能方便CPU操作。有的计算机会让这些寄存器占用内存地址的一部分，称为`内存映像I/O`;另一些计算机则采用I/o专用地址，即`寄存器独立编址`。

#### 3.I/O控制器的两种寄存器编址方式

##### 内存映像---独立编址

![image-20221122105451316](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122105451316.png)

### 5.1.3 控制I/O设备的几种方式？(程序直接控制方式、中断驱动方式、DMA、通道控制)

![image-20221122105607672](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122105607672.png)

需要注意的问题:

1. 完成一次读/写操作的流程;
2. CPU干预的频率;
3. 数据传送的单位;
4. 数据的流向;
5. 主要缺点和主要优点。

#### 1.程序直接控制方式

**key word : 轮询**

- 完成一次读/写操作的流程图(以读操作为例)

  ![image-20221122105835295](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122105835295.png)

**下面以C语言代码和流程图来剖析，程序直接控制方式**

![image-20221122105852793](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122105852793.png)

**分析一下在思维导图中提到的几个问题：**

![image-20221122105914280](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122105914280.png)

#### 2.中断驱动方式

- 由于`程序直接控制方式`CPU利用率低，忙等，所以提出了中断驱动方式。

  ![image-20221122105946564](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122105946564.png)

**分析一下在思维导图中提到的几个问题：**

![image-20221122110008786](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122110008786.png)

#### 3.DMA方式

- 虽然`中断驱动方式解决了程序直接控制方式`的问题，但是每一次只能读/写一个字，导致CPU频繁切换，耗费了很多时间。于是人们又发明了DMA方式。

  ![image-20221122110033244](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122110033244.png)

**DMA控制器：**

![image-20221122110110063](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122110110063.png)

DR(Data Register，数据寄存器):暂存从设备到内存，或从内存到设备的数据。
MAR (Memory Address Register，内存地址寄存器)∶在输入时，MAR表示数据应放到内存中的什么位置;输出时MAR表示要输出的数据放在内存中的什么位置。
DC(Data Counter，数据计数器）:表示剩余要读/写的字节数。
CR (Command Register，命令/状态寄存器）︰用于存放CPU发来的I/O命令，或设备的状态信息。

**分析一下在思维导图中提到的几个问题：**

![image-20221122110138034](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122110138034.png)

#### 4.通道控制方式

`通道`:一种`硬件`，可以理解为是“`弱鸡版的CPU`”。通道可以识别并执行一系列`通道指令`

- 通道控制方式是为了解决DMA方式连续存储的问题

  ![image-20221122110255810](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122110255810.png)

**分析一下在思维导图中提到的几个问题：**

![image-20221122110345151](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122110345151.png)

#### 5.四种方式总结一下

![image-20221122110416416](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122110416416.png)

### 5.1.4 I/O软件的层次结构（用户层软件-设备独立性软件-设备驱动程序-中断处理程序）

![image-20221122140146631](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122140146631.png)

#### 1.用户层软件

![image-20221122140319130](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122140319130.png)

#### ⒉.设备独立性软件

##### 六大功能

`设备独立性软件`，又称`设备无关性软件`。与设备的硬件特性无关的功能几乎都在这一层实现。

![image-20221122140800140](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122140800140.png)

##### 逻辑设备表---LUT

![image-20221122140928263](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122140928263.png)

操作系统系统可以采用两种方式管理`逻辑设备表（LUT)` :
第一种方式，`整个系统只设置一张LUT`，这就意味着所有用户不能使用相同的逻辑设备名，因此这种方式只适用于单用户操作系统。
第二种方式，`为每个用户设置一张LUT`，各个用户使用的逻辑设备名可以重复，适用于多用户操作系统。系统会在用户登录时为其建立一个用户管理进程，而LUT就存放在用户管理进程的PCB中

##### 为什么不同的设备需要不同的驱动程序呢?

![image-20221122141047392](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122141047392.png)

**举几个假设的例子：**

![image-20221122141259673](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122141259673.png)

![image-20221122141349464](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122141349464.png)

![image-20221122141405784](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122141405784.png)

#### 3.设备驱动程序

![image-20221122141423514](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122141423514.png)

注:驱动程序一般会以一个独立进程的方式存在。

#### 4.中断处理程序

![image-20221122142026898](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122142026898.png)

当I/O任务完成时，I/O控制器会发送一个`中断信号`，系统会`根据中断信号类型`找到相应的`中断处理程序`并执行。中断处理程序的处理流程如下:

![image-20221122141920817](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122141920817.png)

#### 5.总结回顾

![image-20221122142054096](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122142054096.png)

理解并记住I/O软件`各个层次之间的顺序`，要能够推理判断某个处理应该是在哪个层次完成的（最常考的是设备独立性软件、设备驱动程序这两层。只需理解一个特点即可:`直接涉及到硬件具体细节、且与中断无关的操作肯定是在设备驱动程序层完成的;没有涉及硬件的、对各种设备都需要进行的管理工作都是在设备独立性软件层完成的`)

## 5.2 I/O核心子系统

### 5.2.1 内核的I/O核心子系统及功能

#### 1.I/O核心子系统以及功能

![image-20221122142340612](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122142340612.png)

#### 2.这些功能在哪个层次实现?

##### 假脱机技术

![image-20221122142443339](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122142443339.png)

注:假脱机技术(SPoOLing 技术）需要请求“磁盘设备”的设备独立性软件的服务，因此一般来说假脱机技术是在用户层软件实现的。但是408大纲又将假脱机技术归为“I/O核心子系统”的功能，因此考试时还是以大纲为准。

##### I/O调度

![image-20221122142530412](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122142530412.png)

`I/O调度:用某种算法确定一个好的顺序来处理各个I/O请求`。

如:磁盘调度（先来先服务算法、最短寻道优先算法、SCAN算法、C-SCAN算法、LOOK算法、C-LOOK算法）。当多个磁盘I/O请求到来时，用某种调度算法确定满足I/o请求的顺序。

同理，打印机等设备也可以用先来先服务算法、优先级算法、短作业优先等算法来确定I/o调度顺序。

##### 设备保护

![image-20221122142616313](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122142616313.png)

操作系统需要实现`文件保护功能`，不同的用户对各个文件有不同的访问权限（如:只读、读和写等）。

在UNIX系统中，`设备被看做是一种特殊的文件`，每个设备也会有对应的FCB。当用户请求访问某个设备时，系统根据FCB中记录的信息来判断该用户是否有相应的访问权限，以此实现“设备保护”的功能。(参考“文件保护”小节)

### 5.2.2 I/O设备假脱机技术(SPOOLing)

![image-20221122142727203](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122142727203.png)

#### 1.什么是脱机技术?

**这里温习一下手工操作阶段：**

![image-20221122143125400](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122143125400.png)

因为手工阶段的速度慢问题，引入了脱机技术

![image-20221122143150908](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122143150908.png)

#### 2.假脱机技术

- 在脱机技术的基础上人们发明了更好的假脱机技术

##### 输入井和输出井

“`假脱机技术`”，又称“`SPOOLing 技术`”是用软件的方式模拟脱机技术。SPOOLing系统的组成如下:

![image-20221122143253418](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122143253418.png)

![image-20221122143520791](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122143520791.png)

##### 输入进程与输出进程

![image-20221122143538020](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122143538020.png)

![image-20221122143552965](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122143552965.png)

##### 输入输出缓冲区

![image-20221122143614433](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122143614433.png)

##### 共享打印机原理分析---假脱机技术的一种应用

**先了解一下独占和共享设备，以此引出假脱机技术如何实现对独占设备的共享：**

独占式设备――`只允许各个进程串行使用的设备`。一段时间内只能满足一个进程的请求。

共享设备――`允许多个进程“同时”使用的设备`（宏观上同时使用，微观上可能是交替使用)。可以同时满足多个进程的使用请求。

![image-20221122143721883](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122143721883.png)

![image-20221122143738323](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122143738323.png)

当多个用户进程提出输出打印的请求时，系统会答应它们的请求，但是并不是真正把打印机分配给他们而是由假脱机管理进程为每个进程做两件事:
(1）在磁盘输出井中为进程申请一个`空闲缓冲区`（也就是说，这个缓冲区是在磁盘上的)，并将要打印的`数据`送入其中;
(2）为用户进程申请一张空白的`打印请求表`，并将用户的打印请求填入表中（其实就是用来说明用户的打印数据存放位置等信息的），再将该表`挂到假脱机文件队列上`。
`当打印机空闲时`，输出进程会从`文件队列的`队头`取出一张打印请求表`，并根据表中的要求将要打印的数据从`输出井`传送到`输出缓冲区`，再`输出到打印机进行打印`。用这种方式可依次处理完全部的打印任务

- 打印请求完成后，请求表从打印队列删除，执行后续队列的打印任务

  ![image-20221122143812853](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122143812853.png)

虽然系统中只有一个台打印机，但每个进程提出打印请求时，系统都会为在输出井中为其分配一个存储区（相当于分配了一个逻辑设备），使每个用户进程都觉得自己在独占一台打印机，从而实现对打印机的共享。
SPOOLing技术可以把一台物理设备`虚拟`成逻辑上的多台设备，`可将独占式设备改造成共享设备`。

### 5.2.3 I/O设备的分配与回收（DCT-COCT-CHCT-SDT）

![image-20221122144121013](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122144121013.png)

#### 1.设备分配时应该考虑的因素

##### 设备的固有属性

![image-20221122144440864](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122144440864.png)

设备的固有属性可分为三种:独占设备、共享设备、虚拟设备。

`独占设备`――一个时段只能分配给一个进程（如打印机)
`共享设备`――可同时分配给多个进程使用（如磁盘)﹐各进程往往是宏观上同时共享使用设备，而微观上交替使用。
`虚拟设备`――采用SPOOLing技术将独占设备改造成虚拟的共享设备，可同时分配给多个进程使用（如采用SPOOLing技术实现的共享打印机)

##### 设备的分配算法

先来先服务
优先级高者优先
短任务优先
.....

##### 设备分配中的安全性

![image-20221122144721907](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122144721907.png)

#### 2.静态分配与动态分配

![image-20221122144742461](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122144742461.png)

#### 3.设备分配管理中的数据结构

**设备、控制器、通道之间的关系：**

![image-20221122144818119](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122144818119.png)

一个通道可控制多个设备控制器，每个设备控制器可控制多个设备。

##### 设备控制表---DCT

`设备控制表（DCT）`:系统为每个设备配置一张DCT，用于记录设备情况

![image-20221122144909447](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122144909447.png)

注:“进程管理”章节中曾经提到过“系统会根据阻塞原因不同，将进程PCB挂到不同的阻塞队列中”

##### 控制器控制表---COCT

`控制器控制表(COCT)`:每个设备控制器都会对应一张COCT。操作系统根据COCT的信息对控制器进行操作和管理。

![image-20221122144952315](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122144952315.png)

##### 通道控制表---CHCT

`通道控制表(CHCT)`:每个通道都会对应一张CHCT。操作系统根据CHCT的信息对通道进行操作和管理。

![image-20221122145017243](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122145017243.png)

##### 系统设备表---SDT

`系统设备表(SDT)`:记录了系统中全部设备的情况，每个设备对应一个表目。

![image-20221122145044860](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122145044860.png)

#### 4.设备分配的步骤

![image-20221122145302562](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122145302562.png)

**注∶只有设备、控制器、通道三者都分配成功时，这次设备分配才算成功，之后便可启动I/O设备进行数据传送**

##### 设备分配的改进步骤

①根据进程请求的`物理设备名`查找SDT（注:物理设备名是进程请求分配设备时提供的参数)
②根据SDT找到DCT，若`设备`忙碌则将进程PCB挂到`设备等待队列`中，不忙碌则将`设备`分配给进程。
③根据DCT找到COCT，若`控制器`忙碌则将进程PCB挂到`控制器等待队列`中，不忙碌则将`控制器`分配给进程。
④根据COCT找到CHCT，若`通道`忙碌则将进程PCB挂到`通道等待队列`中，不忙碌则将`通道`分配给进程。

![image-20221122145512047](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122145512047.png)

①根据进程请求的`逻辑设备名`查找SDT(`注:用户编程时提供的逻辑设备名其实就是“设备类型”`)
②查找SDT，找到用户进程`指定类型的、并且空闲`的设备，将其分配给该进程。操作系统`在逻辑设备表（LUT）中新增一个表项`。
③根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程。
④根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程

![image-20221122145746764](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122145746764.png)

![image-20221122145903210](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122145903210.png)

`逻辑设备表（LUT)建立了逻辑设备名与物理设备名之间的映射关系`。
某用户进程第一次使用设备时使用逻辑设备名向操作系统发出请求，操作系统根据用户进程指定的设备类型（逻辑设备名）查找系统设备表，找到一个空闲设备分配给进程，并在LUT中增加相应表项。
`如果之后用户进程再次通过相同的逻辑设备名请求使用设备，则操作系统通过LUT表即可知道用户进程实际要使用的是哪个物理设备了，并且也能知道该设备的驱动程序入口地址`。

逻辑设备表的设置问题:
整个系统只有一张LUT:各用户所用的`逻辑设备名不允许重复`，适用于单用户操作系统
每个用户一张LUT:`不同用户的逻辑设备名可重复`，适用于多用户操作系统

### 5.2.4 缓冲区管理（单缓冲-双缓冲-循环缓冲-缓冲池）

![image-20221122150115426](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122150115426.png)

#### 1.什么是缓冲区?有什么作用?

缓冲区是一个存储区域，可以由专门的硬件寄存器组成，也可利用内存作为缓冲区。
使用`硬件作为缓冲区`的`成本较高`，`容量也较小`，一般仅用在对速度要求非常高的场合（如存储器管理中所用的联想寄存器，由于对页表的访问频率极高，因此使用速度很快的联想寄存器来存放页表项的副本)
一般情况下，更多的是利用`内存作为缓冲区`，“设备独立性软件”的缓冲区管理就是要组织管理好这些缓冲区

![image-20221122150309607](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122150309607.png)

![image-20221122150337132](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122150337132.png)

#### 2.单缓冲

假设某用户进程请求某种块设备读入若干块的数据。若采用单缓冲的策略，操作系统会`在主存中为其分配一个缓冲区`（若题目中没有特别说明，一个缓冲区的大小就是一个块）。
`注意:当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出;当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满以后，才能从缓冲区把数据传出`。

![image-20221122150411259](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122150411259.png)

**T>C时的例子：**

![image-20221122150842048](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122150842048.png)

![image-20221122150542230](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122150542230.png)

![image-20221122150613150](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122150613150.png)

**T<C时：**

![image-20221122150655644](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122150655644.png)

![image-20221122150718039](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122150718039.png)

**结论:采用单缓冲策略，处理一块数据平均耗时Max(C,T)+M**

#### 3.双缓冲

假设某用户进程请求某种块设备读入若干块的数据。若采用`双缓冲`的策略，操作系统会`在主存中为其分配两个缓冲区`（若题目中没有特别说明，一个缓冲区的大小就是一个块)
双缓冲题目中，假设初始状态为:`工作区空，其中一个缓冲区满，另一个缓冲区空`

**T>C+M时：**(处理一块数据的平均用时=T)

![image-20221122151103236](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122151103236.png)

**T<C+M时：**

![image-20221122151130233](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122151130233.png)

注: M(1)表示“将缓冲区1中的数据传送到工作区”;M(2)表示“将缓冲区2中的数据传送到工作区”

**结论:采用双缓冲策略，处理一个数据块的平均耗时为Max(T,C+M)**

#### 4.单缓冲和双缓冲通信时的区别

两台机器之间通信时，可以配置缓冲区用于数据的发送和接受。

![image-20221122151235788](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122151235788.png)

显然，若两个相互通信的机器只设置单缓冲区，在任一时刻只能实现数据的单向传输。

![image-20221122151303026](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122151303026.png)

若两个相互通信的机器设置双缓冲区，则同一时刻可以实现双向的数据传输。
**注:管道通信中的“管道”其实就是缓冲区。要实现数据的双向传输，必须设置两个管道**

#### 5.循环缓冲区

将多个`大小相等`的缓冲区链接成一个`循环队列`。
注:以下图示中，橙色表示已充满数据的缓冲区，绿色表示空缓冲区。

![image-20221122151359638](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122151359638.png)

#### 6.缓冲池

`缓冲池`由系统中共用的缓冲区组成。这些缓冲区按使用状况可以分为:空缓冲队列、装满输入数据的缓冲队列（输入队列)、装满输出数据的缓冲队列（输出队列）。
另外，根据一个缓冲区在实际运算中扮演的功能不同，又设置了四种工作缓冲区:用于收容输入数据的工作缓冲区（hin)、用于提取输入数据的工作缓冲区（sin)、用于收容输出数据的工作缓冲区(hout） 、用于提取输出数据的工作缓冲区( sout)

![image-20221122151623027](https://gitee.com/kiteflyer/picture/raw/master/OS/image-20221122151623027.png)